(function() {
  "use strict";
  class LocalConnection {
    constructor() {
      this.mode = "local";
      this.authHash = null;
      this.onMessage = null;
      console.log("ðŸ”Œ Note Relay: Local HTTP mode");
    }
    /**
     * Hash password using SHA-256
     */
    async hashString(str2) {
      const encoder = new TextEncoder();
      const data = encoder.encode(str2);
      const hashBuffer = await crypto.subtle.digest("SHA-256", data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    /**
     * Connect to local plugin HTTP server
     */
    async connect(password, onStatusUpdate) {
      this.onStatusUpdate = onStatusUpdate || ((msg) => console.log(msg));
      this.authHash = await this.hashString(password);
      this.onStatusUpdate("Connecting to local vault...");
      const response = await fetch("http://localhost:5474/api/command", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ cmd: "PING", authHash: this.authHash })
      });
      if (!response.ok) {
        throw new Error("Authentication Failed");
      }
      const pingResult = await response.json();
      if (pingResult.data && pingResult.data.css) {
        let styleTag = document.getElementById("obsidian-theme-vars");
        if (!styleTag) {
          styleTag = document.createElement("style");
          styleTag.id = "obsidian-theme-vars";
          document.head.appendChild(styleTag);
        }
        styleTag.textContent = pingResult.data.css;
      }
      console.log("ðŸ“¡ PING response received");
      this.onStatusUpdate("Authenticated. Loading vault...");
      if (this.onMessage) {
        this.onMessage({ type: "CONNECTED", data: {} });
      }
      await this.send("GET_TREE");
      await this.send("LOAD_TAGS");
      await this.send("LOAD_GRAPH");
      return true;
    }
    /**
     * Send command via HTTP
     */
    async send(cmd, extraData = {}) {
      const response = await fetch("http://localhost:5474/api/command", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ cmd, authHash: this.authHash, ...extraData })
      });
      if (!response.ok) {
        throw new Error(`HTTP request failed: ${response.status}`);
      }
      const result = await response.json();
      if (this.onMessage && result) {
        this.onMessage(result);
      }
      return result;
    }
    /**
     * Disconnect (no-op for HTTP)
     */
    disconnect() {
      console.log("Local connection closed");
    }
  }
  function processFileData(data) {
    const files = data.files || data;
    const folders = data.folders || [];
    const masterFileList2 = files;
    const folderTree2 = { _files: [], _sub: {} };
    const tagTree2 = { _files: [], _sub: {} };
    const allFolders = new Set(folders);
    files.forEach((f2) => {
      const parts = f2.path.split("/");
      parts.pop();
      let folderPath = "";
      parts.forEach((part) => {
        folderPath = folderPath ? `${folderPath}/${part}` : part;
        allFolders.add(folderPath);
      });
    });
    allFolders.forEach((folderPath) => {
      const parts = folderPath.split("/");
      let current = folderTree2;
      parts.forEach((part) => {
        if (!current._sub[part]) {
          current._sub[part] = { _files: [], _sub: {} };
        }
        current = current._sub[part];
      });
    });
    files.forEach((f2) => {
      const parts = f2.path.split("/");
      parts.pop();
      if (parts.length === 0) {
        folderTree2._files.push(f2);
      } else {
        let current = folderTree2;
        parts.forEach((part) => {
          current = current._sub[part];
        });
        current._files.push(f2);
      }
      if (f2.tags) {
        f2.tags.forEach((rawTag) => {
          const parts2 = rawTag.replace("#", "").split("/");
          let tCurrent = tagTree2;
          parts2.forEach((part) => {
            if (!tCurrent._sub[part]) {
              tCurrent._sub[part] = { _files: [], _sub: {} };
            }
            tCurrent = tCurrent._sub[part];
            tCurrent._files.push(f2);
          });
        });
      }
    });
    return { masterFileList: masterFileList2, folderTree: folderTree2, tagTree: tagTree2 };
  }
  function renderNode(node, container, level, parentPath, currentView2, icons, onNodeClick) {
    if (level === 0 && currentView2 === "folders" && node._files && node._files.length > 0) {
      const rootDiv = document.createElement("div");
      rootDiv.className = "tree-item-wrapper";
      const rootLabel = document.createElement("div");
      rootLabel.className = "tree-label file-tree-item";
      rootLabel.setAttribute("data-path", "/");
      rootLabel.setAttribute("data-type", "root");
      rootLabel.style.paddingLeft = "0px";
      const rootIcon = document.createElement("span");
      rootIcon.className = "tree-icon";
      rootIcon.innerHTML = '<i class="fa-solid fa-home"></i>';
      const rootText = document.createElement("span");
      rootText.className = "tree-text";
      rootText.textContent = `Root Notes (${node._files.length})`;
      rootLabel.appendChild(rootIcon);
      rootLabel.appendChild(rootText);
      rootLabel.onclick = () => {
        document.querySelectorAll(".tree-label").forEach((d2) => d2.classList.remove("selected"));
        rootLabel.classList.add("selected");
        if (onNodeClick) {
          onNodeClick("/", node._files);
        }
      };
      rootDiv.appendChild(rootLabel);
      container.appendChild(rootDiv);
    }
    Object.keys(node._sub || {}).sort().forEach((key) => {
      const child = node._sub[key];
      const hasSub = Object.keys(child._sub || {}).length > 0;
      const fileCount = child._files ? child._files.length : 0;
      const fullPath = parentPath + key + "/";
      const isFolder = currentView2 === "folders";
      const div = document.createElement("div");
      div.className = "tree-item-wrapper";
      const label = document.createElement("div");
      label.className = "tree-label file-tree-item";
      label.setAttribute("data-path", fullPath);
      label.setAttribute("data-type", isFolder ? "folder" : "tag");
      label.style.paddingLeft = `${level * 12}px`;
      const caret = document.createElement("span");
      caret.className = hasSub ? "caret" : "caret empty";
      caret.innerHTML = hasSub ? "â–¶" : "";
      const icon = document.createElement("span");
      icon.className = "tree-icon";
      icon.innerHTML = isFolder ? icons.folder || '<i class="fa-solid fa-folder"></i>' : icons.tag || '<i class="fa-solid fa-hashtag"></i>';
      const text = document.createElement("span");
      text.className = "tree-text";
      text.textContent = key + (fileCount > 0 ? ` (${fileCount})` : "");
      label.appendChild(caret);
      label.appendChild(icon);
      label.appendChild(text);
      const childrenDiv = document.createElement("div");
      childrenDiv.className = "tree-children";
      div.appendChild(label);
      div.appendChild(childrenDiv);
      label.onclick = (e2) => {
        if (e2.target.closest(".caret") && hasSub) return;
        document.querySelectorAll(".tree-label").forEach((d2) => d2.classList.remove("selected"));
        label.classList.add("selected");
        if (onNodeClick) {
          onNodeClick(fullPath, child._files);
        }
      };
      if (hasSub) {
        caret.onclick = (e2) => {
          e2.stopPropagation();
          childrenDiv.classList.toggle("open");
          caret.innerHTML = childrenDiv.classList.contains("open") ? "â–¼" : "â–¶";
        };
      }
      container.appendChild(div);
      if (hasSub) {
        renderNode(child, childrenDiv, level + 1, fullPath, currentView2, icons, onNodeClick);
      }
    });
  }
  function prepareList(files) {
    return files.sort((a2, b) => {
      const aName = a2.path.split("/").pop().toLowerCase();
      const bName = b.path.split("/").pop().toLowerCase();
      return aName.localeCompare(bName);
    });
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n2) {
    if (n2.__esModule) return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a2 = function a3() {
        if (this instanceof a3) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a2.prototype = f2.prototype;
    } else a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k2) {
      var d2 = Object.getOwnPropertyDescriptor(n2, k2);
      Object.defineProperty(a2, k2, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n2[k2];
        }
      });
    });
    return a2;
  }
  var codemirror = { exports: {} };
  (function(module, exports$1) {
    (function(global2, factory) {
      module.exports = factory();
    })(commonjsGlobal, function() {
      var userAgent = navigator.userAgent;
      var platform = navigator.platform;
      var gecko = /gecko\/\d/i.test(userAgent);
      var ie_upto10 = /MSIE \d/.test(userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
      var edge = /Edge\/(\d+)/.exec(userAgent);
      var ie = ie_upto10 || ie_11up || edge;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
      var webkit = !edge && /WebKit\//.test(userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
      var chrome = !edge && /Chrome\/(\d+)/.exec(userAgent);
      var chrome_version = chrome && +chrome[1];
      var presto = /Opera\//.test(userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
      var phantom = /PhantomJS/.test(userAgent);
      var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
      var android = /Android/.test(userAgent);
      var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
      var mac = ios || /Mac/.test(platform);
      var chromeOS = /\bCrOS\b/.test(userAgent);
      var windows = /win/i.test(platform);
      var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
      if (presto_version) {
        presto_version = Number(presto_version[1]);
      }
      if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
      }
      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || ie && ie_version >= 9;
      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }
      var rmClass = function(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };
      function removeChildren(e2) {
        for (var count = e2.childNodes.length; count > 0; --count) {
          e2.removeChild(e2.firstChild);
        }
        return e2;
      }
      function removeChildrenAndAdd(parent, e2) {
        return removeChildren(parent).appendChild(e2);
      }
      function elt(tag2, content, className, style) {
        var e2 = document.createElement(tag2);
        if (className) {
          e2.className = className;
        }
        if (style) {
          e2.style.cssText = style;
        }
        if (typeof content == "string") {
          e2.appendChild(document.createTextNode(content));
        } else if (content) {
          for (var i3 = 0; i3 < content.length; ++i3) {
            e2.appendChild(content[i3]);
          }
        }
        return e2;
      }
      function eltP(tag2, content, className, style) {
        var e2 = elt(tag2, content, className, style);
        e2.setAttribute("role", "presentation");
        return e2;
      }
      var range;
      if (document.createRange) {
        range = function(node, start2, end, endNode) {
          var r2 = document.createRange();
          r2.setEnd(endNode || node, end);
          r2.setStart(node, start2);
          return r2;
        };
      } else {
        range = function(node, start2, end) {
          var r2 = document.body.createTextRange();
          try {
            r2.moveToElementText(node.parentNode);
          } catch (e2) {
            return r2;
          }
          r2.collapse(true);
          r2.moveEnd("character", end);
          r2.moveStart("character", start2);
          return r2;
        };
      }
      function contains(parent, child) {
        if (child.nodeType == 3) {
          child = child.parentNode;
        }
        if (parent.contains) {
          return parent.contains(child);
        }
        do {
          if (child.nodeType == 11) {
            child = child.host;
          }
          if (child == parent) {
            return true;
          }
        } while (child = child.parentNode);
      }
      function activeElt(rootNode2) {
        var doc2 = rootNode2.ownerDocument || rootNode2;
        var activeElement;
        try {
          activeElement = rootNode2.activeElement;
        } catch (e2) {
          activeElement = doc2.body || null;
        }
        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
        return activeElement;
      }
      function addClass(node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current)) {
          node.className += (current ? " " : "") + cls;
        }
      }
      function joinClasses(a2, b) {
        var as = a2.split(" ");
        for (var i3 = 0; i3 < as.length; i3++) {
          if (as[i3] && !classTest(as[i3]).test(b)) {
            b += " " + as[i3];
          }
        }
        return b;
      }
      var selectInput = function(node) {
        node.select();
      };
      if (ios) {
        selectInput = function(node) {
          node.selectionStart = 0;
          node.selectionEnd = node.value.length;
        };
      } else if (ie) {
        selectInput = function(node) {
          try {
            node.select();
          } catch (_e) {
          }
        };
      }
      function doc(cm) {
        return cm.display.wrapper.ownerDocument;
      }
      function root2(cm) {
        return rootNode(cm.display.wrapper);
      }
      function rootNode(element) {
        return element.getRootNode ? element.getRootNode() : element.ownerDocument;
      }
      function win(cm) {
        return doc(cm).defaultView;
      }
      function bind(f2) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          return f2.apply(null, args);
        };
      }
      function copyObj(obj, target, overwrite) {
        if (!target) {
          target = {};
        }
        for (var prop2 in obj) {
          if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
            target[prop2] = obj[prop2];
          }
        }
        return target;
      }
      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1) {
            end = string.length;
          }
        }
        for (var i3 = startIndex || 0, n2 = startValue || 0; ; ) {
          var nextTab = string.indexOf("	", i3);
          if (nextTab < 0 || nextTab >= end) {
            return n2 + (end - i3);
          }
          n2 += nextTab - i3;
          n2 += tabSize - n2 % tabSize;
          i3 = nextTab + 1;
        }
      }
      var Delayed = function() {
        this.id = null;
        this.f = null;
        this.time = 0;
        this.handler = bind(this.onTimeout, this);
      };
      Delayed.prototype.onTimeout = function(self2) {
        self2.id = 0;
        if (self2.time <= +/* @__PURE__ */ new Date()) {
          self2.f();
        } else {
          setTimeout(self2.handler, self2.time - +/* @__PURE__ */ new Date());
        }
      };
      Delayed.prototype.set = function(ms, f2) {
        this.f = f2;
        var time = +/* @__PURE__ */ new Date() + ms;
        if (!this.id || time < this.time) {
          clearTimeout(this.id);
          this.id = setTimeout(this.handler, ms);
          this.time = time;
        }
      };
      function indexOf(array2, elt2) {
        for (var i3 = 0; i3 < array2.length; ++i3) {
          if (array2[i3] == elt2) {
            return i3;
          }
        }
        return -1;
      }
      var scrollerGap = 50;
      var Pass = { toString: function() {
        return "CodeMirror.Pass";
      } };
      var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
      function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0; ; ) {
          var nextTab = string.indexOf("	", pos);
          if (nextTab == -1) {
            nextTab = string.length;
          }
          var skipped = nextTab - pos;
          if (nextTab == string.length || col + skipped >= goal) {
            return pos + Math.min(skipped, goal - col);
          }
          col += nextTab - pos;
          col += tabSize - col % tabSize;
          pos = nextTab + 1;
          if (col >= goal) {
            return pos;
          }
        }
      }
      var spaceStrs = [""];
      function spaceStr(n2) {
        while (spaceStrs.length <= n2) {
          spaceStrs.push(lst(spaceStrs) + " ");
        }
        return spaceStrs[n2];
      }
      function lst(arr) {
        return arr[arr.length - 1];
      }
      function map2(array2, f2) {
        var out = [];
        for (var i3 = 0; i3 < array2.length; i3++) {
          out[i3] = f2(array2[i3], i3);
        }
        return out;
      }
      function insertSorted(array2, value, score) {
        var pos = 0, priority = score(value);
        while (pos < array2.length && score(array2[pos]) <= priority) {
          pos++;
        }
        array2.splice(pos, 0, value);
      }
      function nothing() {
      }
      function createObj(base, props) {
        var inst;
        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }
        if (props) {
          copyObj(props, inst);
        }
        return inst;
      }
      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > "Â€" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
      }
      function isWordChar(ch, helper) {
        if (!helper) {
          return isWordCharBasic(ch);
        }
        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
          return true;
        }
        return helper.test(ch);
      }
      function isEmpty(obj) {
        for (var n2 in obj) {
          if (obj.hasOwnProperty(n2) && obj[n2]) {
            return false;
          }
        }
        return true;
      }
      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
      }
      function skipExtendingChars(str2, pos, dir) {
        while ((dir < 0 ? pos > 0 : pos < str2.length) && isExtendingChar(str2.charAt(pos))) {
          pos += dir;
        }
        return pos;
      }
      function findFirst(pred, from, to) {
        var dir = from > to ? -1 : 1;
        for (; ; ) {
          if (from == to) {
            return from;
          }
          var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
          if (mid == from) {
            return pred(mid) ? from : to;
          }
          if (pred(mid)) {
            to = mid;
          } else {
            from = mid + dir;
          }
        }
      }
      function iterateBidiSections(order, from, to, f2) {
        if (!order) {
          return f2(from, to, "ltr", 0);
        }
        var found = false;
        for (var i3 = 0; i3 < order.length; ++i3) {
          var part = order[i3];
          if (part.from < to && part.to > from || from == to && part.to == from) {
            f2(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i3);
            found = true;
          }
        }
        if (!found) {
          f2(from, to, "ltr");
        }
      }
      var bidiOther = null;
      function getBidiPartAt(order, ch, sticky) {
        var found;
        bidiOther = null;
        for (var i3 = 0; i3 < order.length; ++i3) {
          var cur = order[i3];
          if (cur.from < ch && cur.to > ch) {
            return i3;
          }
          if (cur.to == ch) {
            if (cur.from != cur.to && sticky == "before") {
              found = i3;
            } else {
              bidiOther = i3;
            }
          }
          if (cur.from == ch) {
            if (cur.from != cur.to && sticky != "before") {
              found = i3;
            } else {
              bidiOther = i3;
            }
          }
        }
        return found != null ? found : bidiOther;
      }
      var bidiOrdering = /* @__PURE__ */ function() {
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
        var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
        function charType(code) {
          if (code <= 247) {
            return lowTypes.charAt(code);
          } else if (1424 <= code && code <= 1524) {
            return "R";
          } else if (1536 <= code && code <= 1785) {
            return arabicTypes.charAt(code - 1536);
          } else if (1774 <= code && code <= 2220) {
            return "r";
          } else if (8192 <= code && code <= 8203) {
            return "w";
          } else if (code == 8204) {
            return "b";
          } else {
            return "L";
          }
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
        function BidiSpan(level, from, to) {
          this.level = level;
          this.from = from;
          this.to = to;
        }
        return function(str2, direction) {
          var outerType = direction == "ltr" ? "L" : "R";
          if (str2.length == 0 || direction == "ltr" && !bidiRE.test(str2)) {
            return false;
          }
          var len = str2.length, types2 = [];
          for (var i3 = 0; i3 < len; ++i3) {
            types2.push(charType(str2.charCodeAt(i3)));
          }
          for (var i$13 = 0, prev = outerType; i$13 < len; ++i$13) {
            var type2 = types2[i$13];
            if (type2 == "m") {
              types2[i$13] = prev;
            } else {
              prev = type2;
            }
          }
          for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
            var type$1 = types2[i$22];
            if (type$1 == "1" && cur == "r") {
              types2[i$22] = "n";
            } else if (isStrong.test(type$1)) {
              cur = type$1;
              if (type$1 == "r") {
                types2[i$22] = "R";
              }
            }
          }
          for (var i$3 = 1, prev$1 = types2[0]; i$3 < len - 1; ++i$3) {
            var type$2 = types2[i$3];
            if (type$2 == "+" && prev$1 == "1" && types2[i$3 + 1] == "1") {
              types2[i$3] = "1";
            } else if (type$2 == "," && prev$1 == types2[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
              types2[i$3] = prev$1;
            }
            prev$1 = type$2;
          }
          for (var i$4 = 0; i$4 < len; ++i$4) {
            var type$3 = types2[i$4];
            if (type$3 == ",") {
              types2[i$4] = "N";
            } else if (type$3 == "%") {
              var end = void 0;
              for (end = i$4 + 1; end < len && types2[end] == "%"; ++end) {
              }
              var replace = i$4 && types2[i$4 - 1] == "!" || end < len && types2[end] == "1" ? "1" : "N";
              for (var j2 = i$4; j2 < end; ++j2) {
                types2[j2] = replace;
              }
              i$4 = end - 1;
            }
          }
          for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
            var type$4 = types2[i$5];
            if (cur$1 == "L" && type$4 == "1") {
              types2[i$5] = "L";
            } else if (isStrong.test(type$4)) {
              cur$1 = type$4;
            }
          }
          for (var i$6 = 0; i$6 < len; ++i$6) {
            if (isNeutral.test(types2[i$6])) {
              var end$1 = void 0;
              for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types2[end$1]); ++end$1) {
              }
              var before = (i$6 ? types2[i$6 - 1] : outerType) == "L";
              var after = (end$1 < len ? types2[end$1] : outerType) == "L";
              var replace$1 = before == after ? before ? "L" : "R" : outerType;
              for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                types2[j$1] = replace$1;
              }
              i$6 = end$1 - 1;
            }
          }
          var order = [], m2;
          for (var i$7 = 0; i$7 < len; ) {
            if (countsAsLeft.test(types2[i$7])) {
              var start2 = i$7;
              for (++i$7; i$7 < len && countsAsLeft.test(types2[i$7]); ++i$7) {
              }
              order.push(new BidiSpan(0, start2, i$7));
            } else {
              var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
              for (++i$7; i$7 < len && types2[i$7] != "L"; ++i$7) {
              }
              for (var j$2 = pos; j$2 < i$7; ) {
                if (countsAsNum.test(types2[j$2])) {
                  if (pos < j$2) {
                    order.splice(at, 0, new BidiSpan(1, pos, j$2));
                    at += isRTL;
                  }
                  var nstart = j$2;
                  for (++j$2; j$2 < i$7 && countsAsNum.test(types2[j$2]); ++j$2) {
                  }
                  order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                  at += isRTL;
                  pos = j$2;
                } else {
                  ++j$2;
                }
              }
              if (pos < i$7) {
                order.splice(at, 0, new BidiSpan(1, pos, i$7));
              }
            }
          }
          if (direction == "ltr") {
            if (order[0].level == 1 && (m2 = str2.match(/^\s+/))) {
              order[0].from = m2[0].length;
              order.unshift(new BidiSpan(0, 0, m2[0].length));
            }
            if (lst(order).level == 1 && (m2 = str2.match(/\s+$/))) {
              lst(order).to -= m2[0].length;
              order.push(new BidiSpan(0, len - m2[0].length, len));
            }
          }
          return direction == "rtl" ? order.reverse() : order;
        };
      }();
      function getOrder(line, direction) {
        var order = line.order;
        if (order == null) {
          order = line.order = bidiOrdering(line.text, direction);
        }
        return order;
      }
      var noHandlers = [];
      var on = function(emitter, type2, f2) {
        if (emitter.addEventListener) {
          emitter.addEventListener(type2, f2, false);
        } else if (emitter.attachEvent) {
          emitter.attachEvent("on" + type2, f2);
        } else {
          var map3 = emitter._handlers || (emitter._handlers = {});
          map3[type2] = (map3[type2] || noHandlers).concat(f2);
        }
      };
      function getHandlers(emitter, type2) {
        return emitter._handlers && emitter._handlers[type2] || noHandlers;
      }
      function off(emitter, type2, f2) {
        if (emitter.removeEventListener) {
          emitter.removeEventListener(type2, f2, false);
        } else if (emitter.detachEvent) {
          emitter.detachEvent("on" + type2, f2);
        } else {
          var map3 = emitter._handlers, arr = map3 && map3[type2];
          if (arr) {
            var index2 = indexOf(arr, f2);
            if (index2 > -1) {
              map3[type2] = arr.slice(0, index2).concat(arr.slice(index2 + 1));
            }
          }
        }
      }
      function signal(emitter, type2) {
        var handlers = getHandlers(emitter, type2);
        if (!handlers.length) {
          return;
        }
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i3 = 0; i3 < handlers.length; ++i3) {
          handlers[i3].apply(null, args);
        }
      }
      function signalDOMEvent(cm, e2, override) {
        if (typeof e2 == "string") {
          e2 = { type: e2, preventDefault: function() {
            this.defaultPrevented = true;
          } };
        }
        signal(cm, override || e2.type, cm, e2);
        return e_defaultPrevented(e2) || e2.codemirrorIgnore;
      }
      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr) {
          return;
        }
        var set2 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i3 = 0; i3 < arr.length; ++i3) {
          if (indexOf(set2, arr[i3]) == -1) {
            set2.push(arr[i3]);
          }
        }
      }
      function hasHandler(emitter, type2) {
        return getHandlers(emitter, type2).length > 0;
      }
      function eventMixin(ctor) {
        ctor.prototype.on = function(type2, f2) {
          on(this, type2, f2);
        };
        ctor.prototype.off = function(type2, f2) {
          off(this, type2, f2);
        };
      }
      function e_preventDefault(e2) {
        if (e2.preventDefault) {
          e2.preventDefault();
        } else {
          e2.returnValue = false;
        }
      }
      function e_stopPropagation(e2) {
        if (e2.stopPropagation) {
          e2.stopPropagation();
        } else {
          e2.cancelBubble = true;
        }
      }
      function e_defaultPrevented(e2) {
        return e2.defaultPrevented != null ? e2.defaultPrevented : e2.returnValue == false;
      }
      function e_stop(e2) {
        e_preventDefault(e2);
        e_stopPropagation(e2);
      }
      function e_target(e2) {
        return e2.target || e2.srcElement;
      }
      function e_button(e2) {
        var b = e2.which;
        if (b == null) {
          if (e2.button & 1) {
            b = 1;
          } else if (e2.button & 2) {
            b = 3;
          } else if (e2.button & 4) {
            b = 2;
          }
        }
        if (mac && e2.ctrlKey && b == 1) {
          b = 3;
        }
        return b;
      }
      var dragAndDrop = function() {
        if (ie && ie_version < 9) {
          return false;
        }
        var div = elt("div");
        return "draggable" in div || "dragDrop" in div;
      }();
      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "â€‹");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0) {
            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
          }
        }
        var node = zwspSupported ? elt("span", "â€‹") : elt("span", "Â ", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
      }
      var badBidiRects;
      function hasBadBidiRects(measure) {
        if (badBidiRects != null) {
          return badBidiRects;
        }
        var txt = removeChildrenAndAdd(measure, document.createTextNode("AØ®A"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        removeChildren(measure);
        if (!r0 || r0.left == r0.right) {
          return false;
        }
        return badBidiRects = r1.right - r0.right < 3;
      }
      var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
        var pos = 0, result = [], l2 = string.length;
        while (pos <= l2) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1) {
            nl = string.length;
          }
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result;
      } : function(string) {
        return string.split(/\r\n?|\n/);
      };
      var hasSelection = window.getSelection ? function(te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e2) {
          return false;
        }
      } : function(te) {
        var range2;
        try {
          range2 = te.ownerDocument.selection.createRange();
        } catch (e2) {
        }
        if (!range2 || range2.parentElement() != te) {
          return false;
        }
        return range2.compareEndPoints("StartToEnd", range2) != 0;
      };
      var hasCopyEvent = function() {
        var e2 = elt("div");
        if ("oncopy" in e2) {
          return true;
        }
        e2.setAttribute("oncopy", "return;");
        return typeof e2.oncopy == "function";
      }();
      var badZoomedRects = null;
      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null) {
          return badZoomedRects;
        }
        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
      }
      var modes = {}, mimeModes = {};
      function defineMode(name, mode) {
        if (arguments.length > 2) {
          mode.dependencies = Array.prototype.slice.call(arguments, 2);
        }
        modes[name] = mode;
      }
      function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
      }
      function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          if (typeof found == "string") {
            found = { name: found };
          }
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return resolveMode("application/xml");
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
          return resolveMode("application/json");
        }
        if (typeof spec == "string") {
          return { name: spec };
        } else {
          return spec || { name: "null" };
        }
      }
      function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) {
          return getMode(options, "text/plain");
        }
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop2 in exts) {
            if (!exts.hasOwnProperty(prop2)) {
              continue;
            }
            if (modeObj.hasOwnProperty(prop2)) {
              modeObj["_" + prop2] = modeObj[prop2];
            }
            modeObj[prop2] = exts[prop2];
          }
        }
        modeObj.name = spec.name;
        if (spec.helperType) {
          modeObj.helperType = spec.helperType;
        }
        if (spec.modeProps) {
          for (var prop$1 in spec.modeProps) {
            modeObj[prop$1] = spec.modeProps[prop$1];
          }
        }
        return modeObj;
      }
      var modeExtensions = {};
      function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
      }
      function copyState(mode, state) {
        if (state === true) {
          return state;
        }
        if (mode.copyState) {
          return mode.copyState(state);
        }
        var nstate = {};
        for (var n2 in state) {
          var val = state[n2];
          if (val instanceof Array) {
            val = val.concat([]);
          }
          nstate[n2] = val;
        }
        return nstate;
      }
      function innerMode(mode, state) {
        var info;
        while (mode.innerMode) {
          info = mode.innerMode(state);
          if (!info || info.mode == mode) {
            break;
          }
          state = info.state;
          mode = info.mode;
        }
        return info || { mode, state };
      }
      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      }
      var StringStream = function(string, tabSize, lineOracle) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
        this.lineOracle = lineOracle;
      };
      StringStream.prototype.eol = function() {
        return this.pos >= this.string.length;
      };
      StringStream.prototype.sol = function() {
        return this.pos == this.lineStart;
      };
      StringStream.prototype.peek = function() {
        return this.string.charAt(this.pos) || void 0;
      };
      StringStream.prototype.next = function() {
        if (this.pos < this.string.length) {
          return this.string.charAt(this.pos++);
        }
      };
      StringStream.prototype.eat = function(match) {
        var ch = this.string.charAt(this.pos);
        var ok;
        if (typeof match == "string") {
          ok = ch == match;
        } else {
          ok = ch && (match.test ? match.test(ch) : match(ch));
        }
        if (ok) {
          ++this.pos;
          return ch;
        }
      };
      StringStream.prototype.eatWhile = function(match) {
        var start2 = this.pos;
        while (this.eat(match)) {
        }
        return this.pos > start2;
      };
      StringStream.prototype.eatSpace = function() {
        var start2 = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
          ++this.pos;
        }
        return this.pos > start2;
      };
      StringStream.prototype.skipToEnd = function() {
        this.pos = this.string.length;
      };
      StringStream.prototype.skipTo = function(ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
          this.pos = found;
          return true;
        }
      };
      StringStream.prototype.backUp = function(n2) {
        this.pos -= n2;
      };
      StringStream.prototype.column = function() {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
          this.lastColumnPos = this.start;
        }
        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };
      StringStream.prototype.indentation = function() {
        return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };
      StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function(str2) {
            return caseInsensitive ? str2.toLowerCase() : str2;
          };
          var substr = this.string.substr(this.pos, pattern.length);
          if (cased(substr) == cased(pattern)) {
            if (consume !== false) {
              this.pos += pattern.length;
            }
            return true;
          }
        } else {
          var match = this.string.slice(this.pos).match(pattern);
          if (match && match.index > 0) {
            return null;
          }
          if (match && consume !== false) {
            this.pos += match[0].length;
          }
          return match;
        }
      };
      StringStream.prototype.current = function() {
        return this.string.slice(this.start, this.pos);
      };
      StringStream.prototype.hideFirstChars = function(n2, inner) {
        this.lineStart += n2;
        try {
          return inner();
        } finally {
          this.lineStart -= n2;
        }
      };
      StringStream.prototype.lookAhead = function(n2) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n2);
      };
      StringStream.prototype.baseToken = function() {
        var oracle = this.lineOracle;
        return oracle && oracle.baseToken(this.pos);
      };
      function getLine2(doc2, n2) {
        n2 -= doc2.first;
        if (n2 < 0 || n2 >= doc2.size) {
          throw new Error("There is no line " + (n2 + doc2.first) + " in the document.");
        }
        var chunk = doc2;
        while (!chunk.lines) {
          for (var i3 = 0; ; ++i3) {
            var child = chunk.children[i3], sz = child.chunkSize();
            if (n2 < sz) {
              chunk = child;
              break;
            }
            n2 -= sz;
          }
        }
        return chunk.lines[n2];
      }
      function getBetween(doc2, start2, end) {
        var out = [], n2 = start2.line;
        doc2.iter(start2.line, end.line + 1, function(line) {
          var text = line.text;
          if (n2 == end.line) {
            text = text.slice(0, end.ch);
          }
          if (n2 == start2.line) {
            text = text.slice(start2.ch);
          }
          out.push(text);
          ++n2;
        });
        return out;
      }
      function getLines(doc2, from, to) {
        var out = [];
        doc2.iter(from, to, function(line) {
          out.push(line.text);
        });
        return out;
      }
      function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff) {
          for (var n2 = line; n2; n2 = n2.parent) {
            n2.height += diff;
          }
        }
      }
      function lineNo(line) {
        if (line.parent == null) {
          return null;
        }
        var cur = line.parent, no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i3 = 0; ; ++i3) {
            if (chunk.children[i3] == cur) {
              break;
            }
            no += chunk.children[i3].chunkSize();
          }
        }
        return no + cur.first;
      }
      function lineAtHeight(chunk, h) {
        var n2 = chunk.first;
        outer: do {
          for (var i$13 = 0; i$13 < chunk.children.length; ++i$13) {
            var child = chunk.children[i$13], ch = child.height;
            if (h < ch) {
              chunk = child;
              continue outer;
            }
            h -= ch;
            n2 += child.chunkSize();
          }
          return n2;
        } while (!chunk.lines);
        var i3 = 0;
        for (; i3 < chunk.lines.length; ++i3) {
          var line = chunk.lines[i3], lh = line.height;
          if (h < lh) {
            break;
          }
          h -= lh;
        }
        return n2 + i3;
      }
      function isLine(doc2, l2) {
        return l2 >= doc2.first && l2 < doc2.first + doc2.size;
      }
      function lineNumberFor(options, i3) {
        return String(options.lineNumberFormatter(i3 + options.firstLineNumber));
      }
      function Pos(line, ch, sticky) {
        if (sticky === void 0) sticky = null;
        if (!(this instanceof Pos)) {
          return new Pos(line, ch, sticky);
        }
        this.line = line;
        this.ch = ch;
        this.sticky = sticky;
      }
      function cmp(a2, b) {
        return a2.line - b.line || a2.ch - b.ch;
      }
      function equalCursorPos(a2, b) {
        return a2.sticky == b.sticky && cmp(a2, b) == 0;
      }
      function copyPos(x2) {
        return Pos(x2.line, x2.ch);
      }
      function maxPos(a2, b) {
        return cmp(a2, b) < 0 ? b : a2;
      }
      function minPos(a2, b) {
        return cmp(a2, b) < 0 ? a2 : b;
      }
      function clipLine(doc2, n2) {
        return Math.max(doc2.first, Math.min(n2, doc2.first + doc2.size - 1));
      }
      function clipPos(doc2, pos) {
        if (pos.line < doc2.first) {
          return Pos(doc2.first, 0);
        }
        var last = doc2.first + doc2.size - 1;
        if (pos.line > last) {
          return Pos(last, getLine2(doc2, last).text.length);
        }
        return clipToLen(pos, getLine2(doc2, pos.line).text.length);
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen) {
          return Pos(pos.line, linelen);
        } else if (ch < 0) {
          return Pos(pos.line, 0);
        } else {
          return pos;
        }
      }
      function clipPosArray(doc2, array2) {
        var out = [];
        for (var i3 = 0; i3 < array2.length; i3++) {
          out[i3] = clipPos(doc2, array2[i3]);
        }
        return out;
      }
      var SavedContext = function(state, lookAhead) {
        this.state = state;
        this.lookAhead = lookAhead;
      };
      var Context = function(doc2, state, line, lookAhead) {
        this.state = state;
        this.doc = doc2;
        this.line = line;
        this.maxLookAhead = lookAhead || 0;
        this.baseTokens = null;
        this.baseTokenPos = 1;
      };
      Context.prototype.lookAhead = function(n2) {
        var line = this.doc.getLine(this.line + n2);
        if (line != null && n2 > this.maxLookAhead) {
          this.maxLookAhead = n2;
        }
        return line;
      };
      Context.prototype.baseToken = function(n2) {
        if (!this.baseTokens) {
          return null;
        }
        while (this.baseTokens[this.baseTokenPos] <= n2) {
          this.baseTokenPos += 2;
        }
        var type2 = this.baseTokens[this.baseTokenPos + 1];
        return {
          type: type2 && type2.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - n2
        };
      };
      Context.prototype.nextLine = function() {
        this.line++;
        if (this.maxLookAhead > 0) {
          this.maxLookAhead--;
        }
      };
      Context.fromSaved = function(doc2, saved, line) {
        if (saved instanceof SavedContext) {
          return new Context(doc2, copyState(doc2.mode, saved.state), line, saved.lookAhead);
        } else {
          return new Context(doc2, copyState(doc2.mode, saved), line);
        }
      };
      Context.prototype.save = function(copy2) {
        var state = copy2 !== false ? copyState(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
      };
      function highlightLine(cm, line, context, forceToEnd) {
        var st = [cm.state.modeGen], lineClasses = {};
        runMode(
          cm,
          line.text,
          cm.doc.mode,
          context,
          function(end, style) {
            return st.push(end, style);
          },
          lineClasses,
          forceToEnd
        );
        var state = context.state;
        var loop = function(o3) {
          context.baseTokens = st;
          var overlay2 = cm.state.overlays[o3], i3 = 1, at = 0;
          context.state = true;
          runMode(cm, line.text, overlay2.mode, context, function(end, style) {
            var start2 = i3;
            while (at < end) {
              var i_end = st[i3];
              if (i_end > end) {
                st.splice(i3, 1, end, st[i3 + 1], i_end);
              }
              i3 += 2;
              at = Math.min(end, i_end);
            }
            if (!style) {
              return;
            }
            if (overlay2.opaque) {
              st.splice(start2, i3 - start2, end, "overlay " + style);
              i3 = start2 + 2;
            } else {
              for (; start2 < i3; start2 += 2) {
                var cur = st[start2 + 1];
                st[start2 + 1] = (cur ? cur + " " : "") + "overlay " + style;
              }
            }
          }, lineClasses);
          context.state = state;
          context.baseTokens = null;
          context.baseTokenPos = 1;
        };
        for (var o2 = 0; o2 < cm.state.overlays.length; ++o2) loop(o2);
        return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
      }
      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var context = getContextBefore(cm, lineNo(line));
          var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
          var result = highlightLine(cm, line, context);
          if (resetState) {
            context.state = resetState;
          }
          line.stateAfter = context.save(!resetState);
          line.styles = result.styles;
          if (result.classes) {
            line.styleClasses = result.classes;
          } else if (line.styleClasses) {
            line.styleClasses = null;
          }
          if (updateFrontier === cm.doc.highlightFrontier) {
            cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
          }
        }
        return line.styles;
      }
      function getContextBefore(cm, n2, precise) {
        var doc2 = cm.doc, display = cm.display;
        if (!doc2.mode.startState) {
          return new Context(doc2, true, n2);
        }
        var start2 = findStartLine(cm, n2, precise);
        var saved = start2 > doc2.first && getLine2(doc2, start2 - 1).stateAfter;
        var context = saved ? Context.fromSaved(doc2, saved, start2) : new Context(doc2, startState(doc2.mode), start2);
        doc2.iter(start2, n2, function(line) {
          processLine(cm, line.text, context);
          var pos = context.line;
          line.stateAfter = pos == n2 - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
          context.nextLine();
        });
        if (precise) {
          doc2.modeFrontier = context.line;
        }
        return context;
      }
      function processLine(cm, text, context, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize, context);
        stream.start = stream.pos = startAt || 0;
        if (text == "") {
          callBlankLine(mode, context.state);
        }
        while (!stream.eol()) {
          readToken(mode, stream, context.state);
          stream.start = stream.pos;
        }
      }
      function callBlankLine(mode, state) {
        if (mode.blankLine) {
          return mode.blankLine(state);
        }
        if (!mode.innerMode) {
          return;
        }
        var inner = innerMode(mode, state);
        if (inner.mode.blankLine) {
          return inner.mode.blankLine(inner.state);
        }
      }
      function readToken(mode, stream, state, inner) {
        for (var i3 = 0; i3 < 10; i3++) {
          if (inner) {
            inner[0] = innerMode(mode, state).mode;
          }
          var style = mode.token(stream, state);
          if (stream.pos > stream.start) {
            return style;
          }
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
      }
      var Token = function(stream, type2, state) {
        this.start = stream.start;
        this.end = stream.pos;
        this.string = stream.current();
        this.type = type2 || null;
        this.state = state;
      };
      function takeToken(cm, pos, precise, asArray) {
        var doc2 = cm.doc, mode = doc2.mode, style;
        pos = clipPos(doc2, pos);
        var line = getLine2(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
        if (asArray) {
          tokens = [];
        }
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken(mode, stream, context.state);
          if (asArray) {
            tokens.push(new Token(stream, style, copyState(doc2.mode, context.state)));
          }
        }
        return asArray ? tokens : new Token(stream, style, context.state);
      }
      function extractLineClasses(type2, output) {
        if (type2) {
          for (; ; ) {
            var lineClass = type2.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!lineClass) {
              break;
            }
            type2 = type2.slice(0, lineClass.index) + type2.slice(lineClass.index + lineClass[0].length);
            var prop2 = lineClass[1] ? "bgClass" : "textClass";
            if (output[prop2] == null) {
              output[prop2] = lineClass[2];
            } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
              output[prop2] += " " + lineClass[2];
            }
          }
        }
        return type2;
      }
      function runMode(cm, text, mode, context, f2, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null) {
          flattenSpans = cm.options.flattenSpans;
        }
        var curStart = 0, curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize, context), style;
        var inner = cm.options.addModeClass && [null];
        if (text == "") {
          extractLineClasses(callBlankLine(mode, context.state), lineClasses);
        }
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd) {
              processLine(cm, text, context, stream.pos);
            }
            stream.pos = text.length;
            style = null;
          } else {
            style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
          }
          if (inner) {
            var mName = inner[0].name;
            if (mName) {
              style = "m-" + (style ? mName + " " + style : mName);
            }
          }
          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 5e3);
              f2(curStart, curStyle);
            }
            curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          var pos = Math.min(stream.pos, curStart + 5e3);
          f2(pos, curStyle);
          curStart = pos;
        }
      }
      function findStartLine(cm, n2, precise) {
        var minindent, minline, doc2 = cm.doc;
        var lim = precise ? -1 : n2 - (cm.doc.mode.innerMode ? 1e3 : 100);
        for (var search = n2; search > lim; --search) {
          if (search <= doc2.first) {
            return doc2.first;
          }
          var line = getLine2(doc2, search - 1), after = line.stateAfter;
          if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {
            return search;
          }
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline;
      }
      function retreatFrontier(doc2, n2) {
        doc2.modeFrontier = Math.min(doc2.modeFrontier, n2);
        if (doc2.highlightFrontier < n2 - 10) {
          return;
        }
        var start2 = doc2.first;
        for (var line = n2 - 1; line > start2; line--) {
          var saved = getLine2(doc2, line).stateAfter;
          if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n2)) {
            start2 = line + 1;
            break;
          }
        }
        doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start2);
      }
      var sawReadOnlySpans = false, sawCollapsedSpans = false;
      function seeReadOnlySpans() {
        sawReadOnlySpans = true;
      }
      function seeCollapsedSpans() {
        sawCollapsedSpans = true;
      }
      function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
      }
      function getMarkedSpanFor(spans, marker) {
        if (spans) {
          for (var i3 = 0; i3 < spans.length; ++i3) {
            var span = spans[i3];
            if (span.marker == marker) {
              return span;
            }
          }
        }
      }
      function removeMarkedSpan(spans, span) {
        var r2;
        for (var i3 = 0; i3 < spans.length; ++i3) {
          if (spans[i3] != span) {
            (r2 || (r2 = [])).push(spans[i3]);
          }
        }
        return r2;
      }
      function addMarkedSpan(line, span, op) {
        var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));
        if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
          line.markedSpans.push(span);
        } else {
          line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
          if (inThisOp) {
            inThisOp.add(line.markedSpans);
          }
        }
        span.marker.attachLine(line);
      }
      function markedSpansBefore(old, startCh, isInsert) {
        var nw;
        if (old) {
          for (var i3 = 0; i3 < old.length; ++i3) {
            var span = old[i3], marker = span.marker;
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
            if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
          }
        }
        return nw;
      }
      function markedSpansAfter(old, endCh, isInsert) {
        var nw;
        if (old) {
          for (var i3 = 0; i3 < old.length; ++i3) {
            var span = old[i3], marker = span.marker;
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
            if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
              (nw || (nw = [])).push(new MarkedSpan(
                marker,
                startsBefore ? null : span.from - endCh,
                span.to == null ? null : span.to - endCh
              ));
            }
          }
        }
        return nw;
      }
      function stretchSpansOverChange(doc2, change) {
        if (change.full) {
          return null;
        }
        var oldFirst = isLine(doc2, change.from.line) && getLine2(doc2, change.from.line).markedSpans;
        var oldLast = isLine(doc2, change.to.line) && getLine2(doc2, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) {
          return null;
        }
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          for (var i3 = 0; i3 < first.length; ++i3) {
            var span = first[i3];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found) {
                span.to = startCh;
              } else if (sameLine) {
                span.to = found.to == null ? null : found.to + offset;
              }
            }
          }
        }
        if (last) {
          for (var i$13 = 0; i$13 < last.length; ++i$13) {
            var span$1 = last[i$13];
            if (span$1.to != null) {
              span$1.to += offset;
            }
            if (span$1.from == null) {
              var found$1 = getMarkedSpanFor(first, span$1.marker);
              if (!found$1) {
                span$1.from = offset;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            } else {
              span$1.from += offset;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          }
        }
        if (first) {
          first = clearEmptySpans(first);
        }
        if (last && last != first) {
          last = clearEmptySpans(last);
        }
        var newMarkers = [first];
        if (!sameLine) {
          var gap = change.text.length - 2, gapMarkers;
          if (gap > 0 && first) {
            for (var i$22 = 0; i$22 < first.length; ++i$22) {
              if (first[i$22].to == null) {
                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
              }
            }
          }
          for (var i$3 = 0; i$3 < gap; ++i$3) {
            newMarkers.push(gapMarkers);
          }
          newMarkers.push(last);
        }
        return newMarkers;
      }
      function clearEmptySpans(spans) {
        for (var i3 = 0; i3 < spans.length; ++i3) {
          var span = spans[i3];
          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
            spans.splice(i3--, 1);
          }
        }
        if (!spans.length) {
          return null;
        }
        return spans;
      }
      function removeReadOnlyRanges(doc2, from, to) {
        var markers = null;
        doc2.iter(from.line, to.line + 1, function(line) {
          if (line.markedSpans) {
            for (var i4 = 0; i4 < line.markedSpans.length; ++i4) {
              var mark = line.markedSpans[i4].marker;
              if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                (markers || (markers = [])).push(mark);
              }
            }
          }
        });
        if (!markers) {
          return null;
        }
        var parts = [{ from, to }];
        for (var i3 = 0; i3 < markers.length; ++i3) {
          var mk = markers[i3], m2 = mk.find(0);
          for (var j2 = 0; j2 < parts.length; ++j2) {
            var p2 = parts[j2];
            if (cmp(p2.to, m2.from) < 0 || cmp(p2.from, m2.to) > 0) {
              continue;
            }
            var newParts = [j2, 1], dfrom = cmp(p2.from, m2.from), dto = cmp(p2.to, m2.to);
            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
              newParts.push({ from: p2.from, to: m2.from });
            }
            if (dto > 0 || !mk.inclusiveRight && !dto) {
              newParts.push({ from: m2.to, to: p2.to });
            }
            parts.splice.apply(parts, newParts);
            j2 += newParts.length - 3;
          }
        }
        return parts;
      }
      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans) {
          return;
        }
        for (var i3 = 0; i3 < spans.length; ++i3) {
          spans[i3].marker.detachLine(line);
        }
        line.markedSpans = null;
      }
      function attachMarkedSpans(line, spans) {
        if (!spans) {
          return;
        }
        for (var i3 = 0; i3 < spans.length; ++i3) {
          spans[i3].marker.attachLine(line);
        }
        line.markedSpans = spans;
      }
      function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
      }
      function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
      }
      function compareCollapsedMarkers(a2, b) {
        var lenDiff = a2.lines.length - b.lines.length;
        if (lenDiff != 0) {
          return lenDiff;
        }
        var aPos = a2.find(), bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a2) - extraLeft(b);
        if (fromCmp) {
          return -fromCmp;
        }
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a2) - extraRight(b);
        if (toCmp) {
          return toCmp;
        }
        return b.id - a2.id;
      }
      function collapsedSpanAtSide(line, start2) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) {
          for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
            sp = sps[i3];
            if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }
        return found;
      }
      function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
      }
      function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
      }
      function collapsedSpanAround(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) {
          for (var i3 = 0; i3 < sps.length; ++i3) {
            var sp = sps[i3];
            if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }
        return found;
      }
      function conflictingCollapsedRange(doc2, lineNo2, from, to, marker) {
        var line = getLine2(doc2, lineNo2);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
          for (var i3 = 0; i3 < sps.length; ++i3) {
            var sp = sps[i3];
            if (!sp.marker.collapsed) {
              continue;
            }
            var found = sp.marker.find(0);
            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
              continue;
            }
            if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
              return true;
            }
          }
        }
      }
      function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line)) {
          line = merged.find(-1, true).line;
        }
        return line;
      }
      function visualLineEnd(line) {
        var merged;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }
        return line;
      }
      function visualLineContinued(line) {
        var merged, lines;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          (lines || (lines = [])).push(line);
        }
        return lines;
      }
      function visualLineNo(doc2, lineN) {
        var line = getLine2(doc2, lineN), vis = visualLine(line);
        if (line == vis) {
          return lineN;
        }
        return lineNo(vis);
      }
      function visualLineEndNo(doc2, lineN) {
        if (lineN > doc2.lastLine()) {
          return lineN;
        }
        var line = getLine2(doc2, lineN), merged;
        if (!lineIsHidden(doc2, line)) {
          return lineN;
        }
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }
        return lineNo(line) + 1;
      }
      function lineIsHidden(doc2, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
          for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
            sp = sps[i3];
            if (!sp.marker.collapsed) {
              continue;
            }
            if (sp.from == null) {
              return true;
            }
            if (sp.marker.widgetNode) {
              continue;
            }
            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line, sp)) {
              return true;
            }
          }
        }
      }
      function lineIsHiddenInner(doc2, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc2, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length) {
          return true;
        }
        for (var sp = void 0, i3 = 0; i3 < line.markedSpans.length; ++i3) {
          sp = line.markedSpans[i3];
          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line, sp)) {
            return true;
          }
        }
      }
      function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0, chunk = lineObj.parent;
        for (var i3 = 0; i3 < chunk.lines.length; ++i3) {
          var line = chunk.lines[i3];
          if (line == lineObj) {
            break;
          } else {
            h += line.height;
          }
        }
        for (var p2 = chunk.parent; p2; chunk = p2, p2 = chunk.parent) {
          for (var i$13 = 0; i$13 < p2.children.length; ++i$13) {
            var cur = p2.children[i$13];
            if (cur == chunk) {
              break;
            } else {
              h += cur.height;
            }
          }
        }
        return h;
      }
      function lineLength(line) {
        if (line.height == 0) {
          return 0;
        }
        var len = line.text.length, merged, cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found$1 = merged.find(0, true);
          len -= cur.text.length - found$1.from.ch;
          cur = found$1.to.line;
          len += cur.text.length - found$1.to.ch;
        }
        return len;
      }
      function findMaxLine(cm) {
        var d2 = cm.display, doc2 = cm.doc;
        d2.maxLine = getLine2(doc2, doc2.first);
        d2.maxLineLength = lineLength(d2.maxLine);
        d2.maxLineChanged = true;
        doc2.iter(function(line) {
          var len = lineLength(line);
          if (len > d2.maxLineLength) {
            d2.maxLineLength = len;
            d2.maxLine = line;
          }
        });
      }
      var Line = function(text, markedSpans, estimateHeight2) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight2 ? estimateHeight2(this) : 1;
      };
      Line.prototype.lineNo = function() {
        return lineNo(this);
      };
      eventMixin(Line);
      function updateLine(line, text, markedSpans, estimateHeight2) {
        line.text = text;
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        if (line.styles) {
          line.styles = null;
        }
        if (line.order != null) {
          line.order = null;
        }
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      }
      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }
      var styleToClassCache = {}, styleToClassCacheWithMode = {};
      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) {
          return null;
        }
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
      }
      function buildLineContent(cm, lineView) {
        var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
          pre: eltP("pre", [content], "CodeMirror-line"),
          content,
          col: 0,
          pos: 0,
          cm,
          trailingSpace: false,
          splitSpaces: cm.getOption("lineWrapping")
        };
        lineView.measure = {};
        for (var i3 = 0; i3 <= (lineView.rest ? lineView.rest.length : 0); i3++) {
          var line = i3 ? lineView.rest[i3 - 1] : lineView.line, order = void 0;
          builder.pos = 0;
          builder.addToken = buildToken;
          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
            builder.addToken = buildTokenBadBidi(builder.addToken, order);
          }
          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
          if (line.styleClasses) {
            if (line.styleClasses.bgClass) {
              builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
            }
            if (line.styleClasses.textClass) {
              builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
            }
          }
          if (builder.map.length == 0) {
            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
          }
          if (i3 == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
            (lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        }
        if (webkit) {
          var last = builder.content.lastChild;
          if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
            builder.content.className = "cm-tab-wrap-hack";
          }
        }
        signal(cm, "renderLine", cm, lineView.line, builder.pre);
        if (builder.pre.className) {
          builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        }
        return builder;
      }
      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "â€¢", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
      }
      function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
        if (!text) {
          return;
        }
        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
        var special = builder.cm.state.specialChars, mustWrap = false;
        var content;
        if (!special.test(text)) {
          builder.col += text.length;
          content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text.length, content);
          if (ie && ie_version < 9) {
            mustWrap = true;
          }
          builder.pos += text.length;
        } else {
          content = document.createDocumentFragment();
          var pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m2 = special.exec(text);
            var skipped = m2 ? m2.index - pos : text.length - pos;
            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt]));
              } else {
                content.appendChild(txt);
              }
              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }
            if (!m2) {
              break;
            }
            pos += skipped + 1;
            var txt$1 = void 0;
            if (m2[0] == "	") {
              var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
              txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt$1.setAttribute("role", "presentation");
              txt$1.setAttribute("cm-text", "	");
              builder.col += tabWidth;
            } else if (m2[0] == "\r" || m2[0] == "\n") {
              txt$1 = content.appendChild(elt("span", m2[0] == "\r" ? "â" : "â¤", "cm-invalidchar"));
              txt$1.setAttribute("cm-text", m2[0]);
              builder.col += 1;
            } else {
              txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);
              txt$1.setAttribute("cm-text", m2[0]);
              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt$1]));
              } else {
                content.appendChild(txt$1);
              }
              builder.col += 1;
            }
            builder.map.push(builder.pos, builder.pos + 1, txt$1);
            builder.pos++;
          }
        }
        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
        if (style || startStyle || endStyle || mustWrap || css || attributes) {
          var fullStyle = style || "";
          if (startStyle) {
            fullStyle += startStyle;
          }
          if (endStyle) {
            fullStyle += endStyle;
          }
          var token = elt("span", [content], fullStyle, css);
          if (attributes) {
            for (var attr in attributes) {
              if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                token.setAttribute(attr, attributes[attr]);
              }
            }
          }
          return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
      }
      function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text)) {
          return text;
        }
        var spaceBefore = trailingBefore, result = "";
        for (var i3 = 0; i3 < text.length; i3++) {
          var ch = text.charAt(i3);
          if (ch == " " && spaceBefore && (i3 == text.length - 1 || text.charCodeAt(i3 + 1) == 32)) {
            ch = "Â ";
          }
          result += ch;
          spaceBefore = ch == " ";
        }
        return result;
      }
      function buildTokenBadBidi(inner, order) {
        return function(builder, text, style, startStyle, endStyle, css, attributes) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start2 = builder.pos, end = start2 + text.length;
          for (; ; ) {
            var part = void 0;
            for (var i3 = 0; i3 < order.length; i3++) {
              part = order[i3];
              if (part.to > start2 && part.from <= start2) {
                break;
              }
            }
            if (part.to >= end) {
              return inner(builder, text, style, startStyle, endStyle, css, attributes);
            }
            inner(builder, text.slice(0, part.to - start2), style, startStyle, null, css, attributes);
            startStyle = null;
            text = text.slice(part.to - start2);
            start2 = part.to;
          }
        };
      }
      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget) {
          builder.map.push(builder.pos, builder.pos + size, widget);
        }
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget) {
            widget = builder.content.appendChild(document.createElement("span"));
          }
          widget.setAttribute("cm-marker", marker.id);
        }
        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }
        builder.pos += size;
        builder.trailingSpace = false;
      }
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (!spans) {
          for (var i$13 = 1; i$13 < styles.length; i$13 += 2) {
            builder.addToken(builder, allText.slice(at, at = styles[i$13]), interpretTokenStyle(styles[i$13 + 1], builder.cm.options));
          }
          return;
        }
        var len = allText.length, pos = 0, i3 = 1, text = "", style, css;
        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
        for (; ; ) {
          if (nextChange == pos) {
            spanStyle = spanEndStyle = spanStartStyle = css = "";
            attributes = null;
            collapsed = null;
            nextChange = Infinity;
            var foundBookmarks = [], endStyles = void 0;
            for (var j2 = 0; j2 < spans.length; ++j2) {
              var sp = spans[j2], m2 = sp.marker;
              if (m2.type == "bookmark" && sp.from == pos && m2.widgetNode) {
                foundBookmarks.push(m2);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }
                if (m2.className) {
                  spanStyle += " " + m2.className;
                }
                if (m2.css) {
                  css = (css ? css + ";" : "") + m2.css;
                }
                if (m2.startStyle && sp.from == pos) {
                  spanStartStyle += " " + m2.startStyle;
                }
                if (m2.endStyle && sp.to == nextChange) {
                  (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);
                }
                if (m2.title) {
                  (attributes || (attributes = {})).title = m2.title;
                }
                if (m2.attributes) {
                  for (var attr in m2.attributes) {
                    (attributes || (attributes = {}))[attr] = m2.attributes[attr];
                  }
                }
                if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {
                  collapsed = sp;
                }
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }
            if (endStyles) {
              for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                if (endStyles[j$1 + 1] == nextChange) {
                  spanEndStyle += " " + endStyles[j$1];
                }
              }
            }
            if (!collapsed || collapsed.from == pos) {
              for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
              }
            }
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(
                builder,
                (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                collapsed.marker,
                collapsed.from == null
              );
              if (collapsed.to == null) {
                return;
              }
              if (collapsed.to == pos) {
                collapsed = false;
              }
            }
          }
          if (pos >= len) {
            break;
          }
          var upto = Math.min(len, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(
                  builder,
                  tokenText,
                  style ? style + spanStyle : spanStyle,
                  spanStartStyle,
                  pos + tokenText.length == nextChange ? spanEndStyle : "",
                  css,
                  attributes
                );
              }
              if (end >= upto) {
                text = text.slice(upto - pos);
                pos = upto;
                break;
              }
              pos = end;
              spanStartStyle = "";
            }
            text = allText.slice(at, at = styles[i3++]);
            style = interpretTokenStyle(styles[i3++], builder.cm.options);
          }
        }
      }
      function LineView(doc2, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc2, line);
      }
      function buildViewArray(cm, from, to) {
        var array2 = [], nextPos;
        for (var pos = from; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine2(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array2.push(view);
        }
        return array2;
      }
      var operationGroup = null;
      function pushOperation(op) {
        if (operationGroup) {
          operationGroup.ops.push(op);
        } else {
          op.ownsGroup = operationGroup = {
            ops: [op],
            delayedCallbacks: []
          };
        }
      }
      function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks, i3 = 0;
        do {
          for (; i3 < callbacks.length; i3++) {
            callbacks[i3].call(null);
          }
          for (var j2 = 0; j2 < group.ops.length; j2++) {
            var op = group.ops[j2];
            if (op.cursorActivityHandlers) {
              while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
              }
            }
          }
        } while (i3 < callbacks.length);
      }
      function finishOperation(op, endCb) {
        var group = op.ownsGroup;
        if (!group) {
          return;
        }
        try {
          fireCallbacksForOps(group);
        } finally {
          operationGroup = null;
          endCb(group);
        }
      }
      var orphanDelayedCallbacks = null;
      function signalLater(emitter, type2) {
        var arr = getHandlers(emitter, type2);
        if (!arr.length) {
          return;
        }
        var args = Array.prototype.slice.call(arguments, 2), list;
        if (operationGroup) {
          list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list = orphanDelayedCallbacks;
        } else {
          list = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }
        var loop = function(i4) {
          list.push(function() {
            return arr[i4].apply(null, args);
          });
        };
        for (var i3 = 0; i3 < arr.length; ++i3)
          loop(i3);
      }
      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i3 = 0; i3 < delayed.length; ++i3) {
          delayed[i3]();
        }
      }
      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j2 = 0; j2 < lineView.changes.length; j2++) {
          var type2 = lineView.changes[j2];
          if (type2 == "text") {
            updateLineText(cm, lineView);
          } else if (type2 == "gutter") {
            updateLineGutter(cm, lineView, lineN, dims);
          } else if (type2 == "class") {
            updateLineClasses(cm, lineView);
          } else if (type2 == "widget") {
            updateLineWidgets(cm, lineView, dims);
          }
        }
        lineView.changes = null;
      }
      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");
          if (lineView.text.parentNode) {
            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
          }
          lineView.node.appendChild(lineView.text);
          if (ie && ie_version < 8) {
            lineView.node.style.zIndex = 2;
          }
        }
        return lineView.node;
      }
      function updateLineBackground(cm, lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls) {
          cls += " CodeMirror-linebackground";
        }
        if (lineView.background) {
          if (cls) {
            lineView.background.className = cls;
          } else {
            lineView.background.parentNode.removeChild(lineView.background);
            lineView.background = null;
          }
        } else if (cls) {
          var wrap = ensureLineWrapped(lineView);
          lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
          cm.display.input.setUneditable(lineView.background);
        }
      }
      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built;
        }
        return buildLineContent(cm, lineView);
      }
      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node) {
          lineView.node = built.pre;
        }
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(cm, lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }
      function updateLineClasses(cm, lineView) {
        updateLineBackground(cm, lineView);
        if (lineView.line.wrapClass) {
          ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        } else if (lineView.node != lineView.text) {
          lineView.node.className = "";
        }
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }
      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
          var wrap = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt(
            "div",
            null,
            "CodeMirror-gutter-background " + lineView.line.gutterClass,
            "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"
          );
          cm.display.input.setUneditable(lineView.gutterBackground);
          wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
          var wrap$1 = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
          gutterWrap.setAttribute("aria-hidden", "true");
          cm.display.input.setUneditable(gutterWrap);
          wrap$1.insertBefore(gutterWrap, lineView.text);
          if (lineView.line.gutterClass) {
            gutterWrap.className += " " + lineView.line.gutterClass;
          }
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
            lineView.lineNumber = gutterWrap.appendChild(
              elt(
                "div",
                lineNumberFor(cm.options, lineN),
                "CodeMirror-linenumber CodeMirror-gutter-elt",
                "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"
              )
            );
          }
          if (markers) {
            for (var k2 = 0; k2 < cm.display.gutterSpecs.length; ++k2) {
              var id2 = cm.display.gutterSpecs[k2].className, found = markers.hasOwnProperty(id2) && markers[id2];
              if (found) {
                gutterWrap.appendChild(elt(
                  "div",
                  [found],
                  "CodeMirror-gutter-elt",
                  "left: " + dims.gutterLeft[id2] + "px; width: " + dims.gutterWidth[id2] + "px"
                ));
              }
            }
          }
        }
      }
      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable) {
          lineView.alignable = null;
        }
        var isWidget = classTest("CodeMirror-linewidget");
        for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
          next = node.nextSibling;
          if (isWidget.test(node.className)) {
            lineView.node.removeChild(node);
          }
        }
        insertLineWidgets(cm, lineView, dims);
      }
      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass) {
          lineView.bgClass = built.bgClass;
        }
        if (built.textClass) {
          lineView.textClass = built.textClass;
        }
        updateLineClasses(cm, lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
      }
      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest) {
          for (var i3 = 0; i3 < lineView.rest.length; i3++) {
            insertLineWidgetsFor(cm, lineView.rest[i3], lineView, dims, false);
          }
        }
      }
      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets) {
          return;
        }
        var wrap = ensureLineWrapped(lineView);
        for (var i3 = 0, ws = line.widgets; i3 < ws.length; ++i3) {
          var widget = ws[i3], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
          if (!widget.handleMouseEvents) {
            node.setAttribute("cm-ignore-events", "true");
          }
          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);
          if (allowAbove && widget.above) {
            wrap.insertBefore(node, lineView.gutter || lineView.text);
          } else {
            wrap.appendChild(node);
          }
          signalLater(widget, "redraw");
        }
      }
      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
          (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll) {
            node.style.marginLeft = -dims.gutterTotalWidth + "px";
          }
        }
      }
      function widgetHeight(widget) {
        if (widget.height != null) {
          return widget.height;
        }
        var cm = widget.doc.cm;
        if (!cm) {
          return 0;
        }
        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";
          if (widget.coverGutter) {
            parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
          }
          if (widget.noHScroll) {
            parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
          }
          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight;
      }
      function eventInWidget(display, e2) {
        for (var n2 = e_target(e2); n2 != display.wrapper; n2 = n2.parentNode) {
          if (!n2 || n2.nodeType == 1 && n2.getAttribute("cm-ignore-events") == "true" || n2.parentNode == display.sizer && n2 != display.mover) {
            return true;
          }
        }
      }
      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }
      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }
      function paddingH(display) {
        if (display.cachedPaddingH) {
          return display.cachedPaddingH;
        }
        var e2 = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
        var style = window.getComputedStyle ? window.getComputedStyle(e2) : e2.currentStyle;
        var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
        if (!isNaN(data.left) && !isNaN(data.right)) {
          display.cachedPaddingH = data;
        }
        return data;
      }
      function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
      }
      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
      }
      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
      }
      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];
          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();
            for (var i3 = 0; i3 < rects.length - 1; i3++) {
              var cur = rects[i3], next = rects[i3 + 1];
              if (Math.abs(cur.bottom - next.bottom) > 2) {
                heights.push((cur.bottom + next.top) / 2 - rect.top);
              }
            }
          }
          heights.push(rect.bottom - rect.top);
        }
      }
      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) {
          return { map: lineView.measure.map, cache: lineView.measure.cache };
        }
        if (lineView.rest) {
          for (var i3 = 0; i3 < lineView.rest.length; i3++) {
            if (lineView.rest[i3] == line) {
              return { map: lineView.measure.maps[i3], cache: lineView.measure.caches[i3] };
            }
          }
          for (var i$13 = 0; i$13 < lineView.rest.length; i$13++) {
            if (lineNo(lineView.rest[i$13]) > lineN) {
              return { map: lineView.measure.maps[i$13], cache: lineView.measure.caches[i$13], before: true };
            }
          }
        }
      }
      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
      }
      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
      }
      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
          return cm.display.view[findViewIndex(cm, lineN)];
        }
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
          return ext;
        }
      }
      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }
        if (!view) {
          view = updateExternalMeasurement(cm, line);
        }
        var info = mapFromLineView(view, line, lineN);
        return {
          line,
          view,
          rect: null,
          map: info.map,
          cache: info.cache,
          before: info.before,
          hasHeights: false
        };
      }
      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before) {
          ch = -1;
        }
        var key = ch + (bias || ""), found;
        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect) {
            prepared.rect = prepared.view.text.getBoundingClientRect();
          }
          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }
          found = measureCharInner(cm, prepared, ch, bias);
          if (!found.bogus) {
            prepared.cache[key] = found;
          }
        }
        return {
          left: found.left,
          right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom
        };
      }
      var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
      function nodeAndOffsetInLineMap(map3, ch, bias) {
        var node, start2, end, collapse, mStart, mEnd;
        for (var i3 = 0; i3 < map3.length; i3 += 3) {
          mStart = map3[i3];
          mEnd = map3[i3 + 1];
          if (ch < mStart) {
            start2 = 0;
            end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start2 = ch - mStart;
            end = start2 + 1;
          } else if (i3 == map3.length - 3 || ch == mEnd && map3[i3 + 3] > ch) {
            end = mEnd - mStart;
            start2 = end - 1;
            if (ch >= mEnd) {
              collapse = "right";
            }
          }
          if (start2 != null) {
            node = map3[i3 + 2];
            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
              collapse = bias;
            }
            if (bias == "left" && start2 == 0) {
              while (i3 && map3[i3 - 2] == map3[i3 - 3] && map3[i3 - 1].insertLeft) {
                node = map3[(i3 -= 3) + 2];
                collapse = "left";
              }
            }
            if (bias == "right" && start2 == mEnd - mStart) {
              while (i3 < map3.length - 3 && map3[i3 + 3] == map3[i3 + 4] && !map3[i3 + 5].insertLeft) {
                node = map3[(i3 += 3) + 2];
                collapse = "right";
              }
            }
            break;
          }
        }
        return { node, start: start2, end, collapse, coverStart: mStart, coverEnd: mEnd };
      }
      function getUsefulRect(rects, bias) {
        var rect = nullRect;
        if (bias == "left") {
          for (var i3 = 0; i3 < rects.length; i3++) {
            if ((rect = rects[i3]).left != rect.right) {
              break;
            }
          }
        } else {
          for (var i$13 = rects.length - 1; i$13 >= 0; i$13--) {
            if ((rect = rects[i$13]).left != rect.right) {
              break;
            }
          }
        }
        return rect;
      }
      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node, start2 = place.start, end = place.end, collapse = place.collapse;
        var rect;
        if (node.nodeType == 3) {
          for (var i$13 = 0; i$13 < 4; i$13++) {
            while (start2 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start2))) {
              --start2;
            }
            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
              ++end;
            }
            if (ie && ie_version < 9 && start2 == 0 && end == place.coverEnd - place.coverStart) {
              rect = node.parentNode.getBoundingClientRect();
            } else {
              rect = getUsefulRect(range(node, start2, end).getClientRects(), bias);
            }
            if (rect.left || rect.right || start2 == 0) {
              break;
            }
            end = start2;
            start2 = start2 - 1;
            collapse = "right";
          }
          if (ie && ie_version < 11) {
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
          }
        } else {
          if (start2 > 0) {
            collapse = bias = "right";
          }
          var rects;
          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          } else {
            rect = node.getBoundingClientRect();
          }
        }
        if (ie && ie_version < 9 && !start2 && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];
          if (rSpan) {
            rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
          } else {
            rect = nullRect;
          }
        }
        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        var i3 = 0;
        for (; i3 < heights.length - 1; i3++) {
          if (mid < heights[i3]) {
            break;
          }
        }
        var top = i3 ? heights[i3 - 1] : 0, bot = heights[i3];
        var result = {
          left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
          right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
          top,
          bottom: bot
        };
        if (!rect.left && !rect.right) {
          result.bogus = true;
        }
        if (!cm.options.singleCursorHeightPerLine) {
          result.rtop = rtop;
          result.rbottom = rbot;
        }
        return result;
      }
      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
          return rect;
        }
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: rect.left * scaleX,
          right: rect.right * scaleX,
          top: rect.top * scaleY,
          bottom: rect.bottom * scaleY
        };
      }
      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;
          if (lineView.rest) {
            for (var i3 = 0; i3 < lineView.rest.length; i3++) {
              lineView.measure.caches[i3] = {};
            }
          }
        }
      }
      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for (var i3 = 0; i3 < cm.display.view.length; i3++) {
          clearLineMeasurementCacheFor(cm.display.view[i3]);
        }
      }
      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping) {
          cm.display.maxLineChanged = true;
        }
        cm.display.lineNumChars = null;
      }
      function pageScrollX(doc2) {
        if (chrome && android) {
          return -(doc2.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc2.body).marginLeft));
        }
        return doc2.defaultView.pageXOffset || (doc2.documentElement || doc2.body).scrollLeft;
      }
      function pageScrollY(doc2) {
        if (chrome && android) {
          return -(doc2.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc2.body).marginTop));
        }
        return doc2.defaultView.pageYOffset || (doc2.documentElement || doc2.body).scrollTop;
      }
      function widgetTopHeight(lineObj) {
        var ref = visualLine(lineObj);
        var widgets = ref.widgets;
        var height = 0;
        if (widgets) {
          for (var i3 = 0; i3 < widgets.length; ++i3) {
            if (widgets[i3].above) {
              height += widgetHeight(widgets[i3]);
            }
          }
        }
        return height;
      }
      function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets) {
          var height = widgetTopHeight(lineObj);
          rect.top += height;
          rect.bottom += height;
        }
        if (context == "line") {
          return rect;
        }
        if (!context) {
          context = "local";
        }
        var yOff = heightAtLine(lineObj);
        if (context == "local") {
          yOff += paddingTop(cm.display);
        } else {
          yOff -= cm.display.viewOffset;
        }
        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));
          rect.left += xOff;
          rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
      }
      function fromCoordSystem(cm, coords, context) {
        if (context == "div") {
          return coords;
        }
        var left = coords.left, top = coords.top;
        if (context == "page") {
          left -= pageScrollX(doc(cm));
          top -= pageScrollY(doc(cm));
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
      }
      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) {
          lineObj = getLine2(cm.doc, pos.line);
        }
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
      }
      function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine2(cm.doc, pos.line);
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        function get2(ch2, right) {
          var m2 = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
          if (right) {
            m2.left = m2.right;
          } else {
            m2.right = m2.left;
          }
          return intoCoordSystem(cm, lineObj, m2, context);
        }
        var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
        if (ch >= lineObj.text.length) {
          ch = lineObj.text.length;
          sticky = "before";
        } else if (ch <= 0) {
          ch = 0;
          sticky = "after";
        }
        if (!order) {
          return get2(sticky == "before" ? ch - 1 : ch, sticky == "before");
        }
        function getBidi(ch2, partPos2, invert) {
          var part = order[partPos2], right = part.level == 1;
          return get2(invert ? ch2 - 1 : ch2, right != invert);
        }
        var partPos = getBidiPartAt(order, ch, sticky);
        var other = bidiOther;
        var val = getBidi(ch, partPos, sticky == "before");
        if (other != null) {
          val.other = getBidi(ch, other, sticky != "before");
        }
        return val;
      }
      function estimateCoords(cm, pos) {
        var left = 0;
        pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping) {
          left = charWidth(cm.display) * pos.ch;
        }
        var lineObj = getLine2(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return { left, right: left, top, bottom: top + lineObj.height };
      }
      function PosWithInfo(line, ch, sticky, outside, xRel) {
        var pos = Pos(line, ch, sticky);
        pos.xRel = xRel;
        if (outside) {
          pos.outside = outside;
        }
        return pos;
      }
      function coordsChar(cm, x2, y2) {
        var doc2 = cm.doc;
        y2 += cm.display.viewOffset;
        if (y2 < 0) {
          return PosWithInfo(doc2.first, 0, null, -1, -1);
        }
        var lineN = lineAtHeight(doc2, y2), last = doc2.first + doc2.size - 1;
        if (lineN > last) {
          return PosWithInfo(doc2.first + doc2.size - 1, getLine2(doc2, last).text.length, null, 1, 1);
        }
        if (x2 < 0) {
          x2 = 0;
        }
        var lineObj = getLine2(doc2, lineN);
        for (; ; ) {
          var found = coordsCharInner(cm, lineObj, lineN, x2, y2);
          var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
          if (!collapsed) {
            return found;
          }
          var rangeEnd = collapsed.find(1);
          if (rangeEnd.line == lineN) {
            return rangeEnd;
          }
          lineObj = getLine2(doc2, lineN = rangeEnd.line);
        }
      }
      function wrappedLineExtent(cm, lineObj, preparedMeasure, y2) {
        y2 -= widgetTopHeight(lineObj);
        var end = lineObj.text.length;
        var begin = findFirst(function(ch) {
          return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y2;
        }, end, 0);
        end = findFirst(function(ch) {
          return measureCharPrepared(cm, preparedMeasure, ch).top > y2;
        }, begin, end);
        return { begin, end };
      }
      function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
      }
      function boxIsAfter(box, x2, y2, left) {
        return box.bottom <= y2 ? false : box.top > y2 ? true : (left ? box.left : box.right) > x2;
      }
      function coordsCharInner(cm, lineObj, lineNo2, x2, y2) {
        y2 -= heightAtLine(lineObj);
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        var widgetHeight2 = widgetTopHeight(lineObj);
        var begin = 0, end = lineObj.text.length, ltr = true;
        var order = getOrder(lineObj, cm.doc.direction);
        if (order) {
          var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x2, y2);
          ltr = part.level != 1;
          begin = ltr ? part.from : part.to - 1;
          end = ltr ? part.to : part.from - 1;
        }
        var chAround = null, boxAround = null;
        var ch = findFirst(function(ch2) {
          var box = measureCharPrepared(cm, preparedMeasure, ch2);
          box.top += widgetHeight2;
          box.bottom += widgetHeight2;
          if (!boxIsAfter(box, x2, y2, false)) {
            return false;
          }
          if (box.top <= y2 && box.left <= x2) {
            chAround = ch2;
            boxAround = box;
          }
          return true;
        }, begin, end);
        var baseX, sticky, outside = false;
        if (boxAround) {
          var atLeft = x2 - boxAround.left < boxAround.right - x2, atStart = atLeft == ltr;
          ch = chAround + (atStart ? 0 : 1);
          sticky = atStart ? "after" : "before";
          baseX = atLeft ? boxAround.left : boxAround.right;
        } else {
          if (!ltr && (ch == end || ch == begin)) {
            ch++;
          }
          sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y2 == ltr ? "after" : "before";
          var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
          baseX = coords.left;
          outside = y2 < coords.top ? -1 : y2 >= coords.bottom ? 1 : 0;
        }
        ch = skipExtendingChars(lineObj.text, ch, 1);
        return PosWithInfo(lineNo2, ch, sticky, outside, x2 - baseX);
      }
      function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x2, y2) {
        var index2 = findFirst(function(i3) {
          var part2 = order[i3], ltr2 = part2.level != 1;
          return boxIsAfter(cursorCoords(
            cm,
            Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"),
            "line",
            lineObj,
            preparedMeasure
          ), x2, y2, true);
        }, 0, order.length - 1);
        var part = order[index2];
        if (index2 > 0) {
          var ltr = part.level != 1;
          var start2 = cursorCoords(
            cm,
            Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"),
            "line",
            lineObj,
            preparedMeasure
          );
          if (boxIsAfter(start2, x2, y2, true) && start2.top > y2) {
            part = order[index2 - 1];
          }
        }
        return part;
      }
      function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x2, y2) {
        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y2);
        var begin = ref.begin;
        var end = ref.end;
        if (/\s/.test(lineObj.text.charAt(end - 1))) {
          end--;
        }
        var part = null, closestDist = null;
        for (var i3 = 0; i3 < order.length; i3++) {
          var p2 = order[i3];
          if (p2.from >= end || p2.to <= begin) {
            continue;
          }
          var ltr = p2.level != 1;
          var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p2.to) - 1 : Math.max(begin, p2.from)).right;
          var dist = endX < x2 ? x2 - endX + 1e9 : endX - x2;
          if (!part || closestDist > dist) {
            part = p2;
            closestDist = dist;
          }
        }
        if (!part) {
          part = order[order.length - 1];
        }
        if (part.from < begin) {
          part = { from: begin, to: part.to, level: part.level };
        }
        if (part.to > end) {
          part = { from: part.from, to: end, level: part.level };
        }
        return part;
      }
      var measureText;
      function textHeight(display) {
        if (display.cachedTextHeight != null) {
          return display.cachedTextHeight;
        }
        if (measureText == null) {
          measureText = elt("pre", null, "CodeMirror-line-like");
          for (var i3 = 0; i3 < 49; ++i3) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3) {
          display.cachedTextHeight = height;
        }
        removeChildren(display.measure);
        return height || 1;
      }
      function charWidth(display) {
        if (display.cachedCharWidth != null) {
          return display.cachedCharWidth;
        }
        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor], "CodeMirror-line-like");
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        if (width > 2) {
          display.cachedCharWidth = width;
        }
        return width || 10;
      }
      function getDimensions(cm) {
        var d2 = cm.display, left = {}, width = {};
        var gutterLeft = d2.gutters.clientLeft;
        for (var n2 = d2.gutters.firstChild, i3 = 0; n2; n2 = n2.nextSibling, ++i3) {
          var id2 = cm.display.gutterSpecs[i3].className;
          left[id2] = n2.offsetLeft + n2.clientLeft + gutterLeft;
          width[id2] = n2.clientWidth;
        }
        return {
          fixedPos: compensateForHScroll(d2),
          gutterTotalWidth: d2.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d2.wrapper.clientWidth
        };
      }
      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
      }
      function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
          if (lineIsHidden(cm.doc, line)) {
            return 0;
          }
          var widgetsHeight = 0;
          if (line.widgets) {
            for (var i3 = 0; i3 < line.widgets.length; i3++) {
              if (line.widgets[i3].height) {
                widgetsHeight += line.widgets[i3].height;
              }
            }
          }
          if (wrapping) {
            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
          } else {
            return widgetsHeight + th;
          }
        };
      }
      function estimateLineHeights(cm) {
        var doc2 = cm.doc, est = estimateHeight(cm);
        doc2.iter(function(line) {
          var estHeight = est(line);
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        });
      }
      function posFromMouse(cm, e2, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e2).getAttribute("cm-not-content") == "true") {
          return null;
        }
        var x2, y2, space = display.lineSpace.getBoundingClientRect();
        try {
          x2 = e2.clientX - space.left;
          y2 = e2.clientY - space.top;
        } catch (e$1) {
          return null;
        }
        var coords = coordsChar(cm, x2, y2), line;
        if (forRect && coords.xRel > 0 && (line = getLine2(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x2 - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
      }
      function findViewIndex(cm, n2) {
        if (n2 >= cm.display.viewTo) {
          return null;
        }
        n2 -= cm.display.viewFrom;
        if (n2 < 0) {
          return null;
        }
        var view = cm.display.view;
        for (var i3 = 0; i3 < view.length; i3++) {
          n2 -= view[i3].size;
          if (n2 < 0) {
            return i3;
          }
        }
      }
      function regChange(cm, from, to, lendiff) {
        if (from == null) {
          from = cm.doc.first;
        }
        if (to == null) {
          to = cm.doc.first + cm.doc.size;
        }
        if (!lendiff) {
          lendiff = 0;
        }
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
          display.updateLineNumbers = from;
        }
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
          if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
            resetView(cm);
          }
        } else if (to <= display.viewFrom) {
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
          resetView(cm);
        } else if (from <= display.viewFrom) {
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) {
          var cut$1 = viewCuttingPoint(cm, from, from, -1);
          if (cut$1) {
            display.view = display.view.slice(0, cut$1.index);
            display.viewTo = cut$1.lineN;
          } else {
            resetView(cm);
          }
        } else {
          var cutTop = viewCuttingPoint(cm, from, from, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }
        var ext = display.externalMeasured;
        if (ext) {
          if (to < ext.lineN) {
            ext.lineN += lendiff;
          } else if (from < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
        }
      }
      function regLineChange(cm, line, type2) {
        cm.curOp.viewChanged = true;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
        if (line < display.viewFrom || line >= display.viewTo) {
          return;
        }
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null) {
          return;
        }
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type2) == -1) {
          arr.push(type2);
        }
      }
      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }
      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index2 = findViewIndex(cm, oldN), diff, view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
          return { index: index2, lineN: newN };
        }
        var n2 = cm.display.viewFrom;
        for (var i3 = 0; i3 < index2; i3++) {
          n2 += view[i3].size;
        }
        if (n2 != oldN) {
          if (dir > 0) {
            if (index2 == view.length - 1) {
              return null;
            }
            diff = n2 + view[index2].size - oldN;
            index2++;
          } else {
            diff = n2 - oldN;
          }
          oldN += diff;
          newN += diff;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
          if (index2 == (dir < 0 ? 0 : view.length - 1)) {
            return null;
          }
          newN += dir * view[index2 - (dir < 0 ? 1 : 0)].size;
          index2 += dir;
        }
        return { index: index2, lineN: newN };
      }
      function adjustView(cm, from, to) {
        var display = cm.display, view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from, to);
          display.viewFrom = from;
        } else {
          if (display.viewFrom > from) {
            display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
          } else if (display.viewFrom < from) {
            display.view = display.view.slice(findViewIndex(cm, from));
          }
          display.viewFrom = from;
          if (display.viewTo < to) {
            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
          } else if (display.viewTo > to) {
            display.view = display.view.slice(0, findViewIndex(cm, to));
          }
        }
        display.viewTo = to;
      }
      function countDirtyView(cm) {
        var view = cm.display.view, dirty = 0;
        for (var i3 = 0; i3 < view.length; i3++) {
          var lineView = view[i3];
          if (!lineView.hidden && (!lineView.node || lineView.changes)) {
            ++dirty;
          }
        }
        return dirty;
      }
      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }
      function prepareSelection(cm, primary) {
        if (primary === void 0) primary = true;
        var doc2 = cm.doc, result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        var customCursor = cm.options.$customCursor;
        if (customCursor) {
          primary = true;
        }
        for (var i3 = 0; i3 < doc2.sel.ranges.length; i3++) {
          if (!primary && i3 == doc2.sel.primIndex) {
            continue;
          }
          var range2 = doc2.sel.ranges[i3];
          if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
            continue;
          }
          var collapsed = range2.empty();
          if (customCursor) {
            var head = customCursor(cm, range2);
            if (head) {
              drawSelectionCursor(cm, head, curFragment);
            }
          } else if (collapsed || cm.options.showCursorWhenSelecting) {
            drawSelectionCursor(cm, range2.head, curFragment);
          }
          if (!collapsed) {
            drawSelectionRange(cm, range2, selFragment);
          }
        }
        return result;
      }
      function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt("div", "Â ", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
          var charPos = charCoords(cm, head, "div", null, null);
          var width = charPos.right - charPos.left;
          cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
        }
        if (pos.other) {
          var otherCursor = output.appendChild(elt("div", "Â ", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
        }
      }
      function cmpCoords(a2, b) {
        return a2.top - b.top || a2.left - b.left;
      }
      function drawSelectionRange(cm, range2, output) {
        var display = cm.display, doc2 = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display), leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        var docLTR = doc2.direction == "ltr";
        function add2(left, top, width, bottom) {
          if (top < 0) {
            top = 0;
          }
          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
        }
        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine2(doc2, line);
          var lineLen = lineObj.text.length;
          var start2, end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }
          function wrapX(pos, dir, side) {
            var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
            var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
            var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
            return coords(ch, prop2)[prop2];
          }
          var order = getOrder(lineObj, doc2.direction);
          iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i3) {
            var ltr = dir == "ltr";
            var fromPos = coords(from, ltr ? "left" : "right");
            var toPos = coords(to - 1, ltr ? "right" : "left");
            var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
            var first = i3 == 0, last = !order || i3 == order.length - 1;
            if (toPos.top - fromPos.top <= 3) {
              var openLeft = (docLTR ? openStart : openEnd) && first;
              var openRight = (docLTR ? openEnd : openStart) && last;
              var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
              var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
              add2(left, fromPos.top, right - left, fromPos.bottom);
            } else {
              var topLeft, topRight, botLeft, botRight;
              if (ltr) {
                topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                botRight = docLTR && openEnd && last ? rightSide : toPos.right;
              } else {
                topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
              }
              add2(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
              if (fromPos.bottom < toPos.top) {
                add2(leftSide, fromPos.bottom, null, toPos.top);
              }
              add2(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
            }
            if (!start2 || cmpCoords(fromPos, start2) < 0) {
              start2 = fromPos;
            }
            if (cmpCoords(toPos, start2) < 0) {
              start2 = toPos;
            }
            if (!end || cmpCoords(fromPos, end) < 0) {
              end = fromPos;
            }
            if (cmpCoords(toPos, end) < 0) {
              end = toPos;
            }
          });
          return { start: start2, end };
        }
        var sFrom = range2.from(), sTo = range2.to();
        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine2(doc2, sFrom.line), toLine = getLine2(doc2, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add2(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add2(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add2(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top) {
            add2(leftSide, leftEnd.bottom, null, rightStart.top);
          }
        }
        output.appendChild(fragment);
      }
      function restartBlink(cm) {
        if (!cm.state.focused) {
          return;
        }
        var display = cm.display;
        clearInterval(display.blinker);
        var on2 = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0) {
          display.blinker = setInterval(function() {
            if (!cm.hasFocus()) {
              onBlur(cm);
            }
            display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
          }, cm.options.cursorBlinkRate);
        } else if (cm.options.cursorBlinkRate < 0) {
          display.cursorDiv.style.visibility = "hidden";
        }
      }
      function ensureFocus(cm) {
        if (!cm.hasFocus()) {
          cm.display.input.focus();
          if (!cm.state.focused) {
            onFocus(cm);
          }
        }
      }
      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
          if (cm.state.delayingBlurEvent) {
            cm.state.delayingBlurEvent = false;
            if (cm.state.focused) {
              onBlur(cm);
            }
          }
        }, 100);
      }
      function onFocus(cm, e2) {
        if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
          cm.state.delayingBlurEvent = false;
        }
        if (cm.options.readOnly == "nocursor") {
          return;
        }
        if (!cm.state.focused) {
          signal(cm, "focus", cm, e2);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused");
          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();
            if (webkit) {
              setTimeout(function() {
                return cm.display.input.reset(true);
              }, 20);
            }
          }
          cm.display.input.receivedFocus();
        }
        restartBlink(cm);
      }
      function onBlur(cm, e2) {
        if (cm.state.delayingBlurEvent) {
          return;
        }
        if (cm.state.focused) {
          signal(cm, "blur", cm, e2);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function() {
          if (!cm.state.focused) {
            cm.display.shift = false;
          }
        }, 150);
      }
      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
        var oldHeight = display.lineDiv.getBoundingClientRect().top;
        var mustScroll = 0;
        for (var i3 = 0; i3 < display.view.length; i3++) {
          var cur = display.view[i3], wrapping = cm.options.lineWrapping;
          var height = void 0, width = 0;
          if (cur.hidden) {
            continue;
          }
          oldHeight += cur.line.height;
          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = cur.node.getBoundingClientRect();
            height = box.bottom - box.top;
            if (!wrapping && cur.text.firstChild) {
              width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
            }
          }
          var diff = cur.line.height - height;
          if (diff > 5e-3 || diff < -5e-3) {
            if (oldHeight < viewTop) {
              mustScroll -= diff;
            }
            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);
            if (cur.rest) {
              for (var j2 = 0; j2 < cur.rest.length; j2++) {
                updateWidgetHeight(cur.rest[j2]);
              }
            }
          }
          if (width > cm.display.sizerWidth) {
            var chWidth = Math.ceil(width / charWidth(cm.display));
            if (chWidth > cm.display.maxLineLength) {
              cm.display.maxLineLength = chWidth;
              cm.display.maxLine = cur.line;
              cm.display.maxLineChanged = true;
            }
          }
        }
        if (Math.abs(mustScroll) > 2) {
          display.scroller.scrollTop += mustScroll;
        }
      }
      function updateWidgetHeight(line) {
        if (line.widgets) {
          for (var i3 = 0; i3 < line.widgets.length; ++i3) {
            var w2 = line.widgets[i3], parent = w2.node.parentNode;
            if (parent) {
              w2.height = parent.offsetHeight;
            }
          }
        }
      }
      function visibleLines(display, doc2, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from = lineAtHeight(doc2, top), to = lineAtHeight(doc2, bottom);
        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
          if (ensureFrom < from) {
            from = ensureFrom;
            to = lineAtHeight(doc2, heightAtLine(getLine2(doc2, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc2.lastLine()) >= to) {
            from = lineAtHeight(doc2, heightAtLine(getLine2(doc2, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }
        return { from, to: Math.max(to, from + 1) };
      }
      function maybeScrollWindow(cm, rect) {
        if (signalDOMEvent(cm, "scrollCursorIntoView")) {
          return;
        }
        var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
        var doc2 = display.wrapper.ownerDocument;
        if (rect.top + box.top < 0) {
          doScroll = true;
        } else if (rect.bottom + box.top > (doc2.defaultView.innerHeight || doc2.documentElement.clientHeight)) {
          doScroll = false;
        }
        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "â€‹", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      }
      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) {
          margin = 0;
        }
        var rect;
        if (!cm.options.lineWrapping && pos == end) {
          end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
          pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
        }
        for (var limit = 0; limit < 5; limit++) {
          var changed = false;
          var coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          rect = {
            left: Math.min(coords.left, endCoords.left),
            top: Math.min(coords.top, endCoords.top) - margin,
            right: Math.max(coords.left, endCoords.left),
            bottom: Math.max(coords.bottom, endCoords.bottom) + margin
          };
          var scrollPos = calculateScrollPos(cm, rect);
          var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
              changed = true;
            }
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
              changed = true;
            }
          }
          if (!changed) {
            break;
          }
        }
        return rect;
      }
      function scrollIntoView(cm, rect) {
        var scrollPos = calculateScrollPos(cm, rect);
        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
        }
      }
      function calculateScrollPos(cm, rect) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        if (rect.top < 0) {
          rect.top = 0;
        }
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen2 = displayHeight(cm), result = {};
        if (rect.bottom - rect.top > screen2) {
          rect.bottom = rect.top + screen2;
        }
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
        if (rect.top < screentop) {
          result.scrollTop = atTop ? 0 : rect.top;
        } else if (rect.bottom > screentop + screen2) {
          var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
          if (newTop != screentop) {
            result.scrollTop = newTop;
          }
        }
        var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
        var screenw = displayWidth(cm) - display.gutters.offsetWidth;
        var tooWide = rect.right - rect.left > screenw;
        if (tooWide) {
          rect.right = rect.left + screenw;
        }
        if (rect.left < 10) {
          result.scrollLeft = 0;
        } else if (rect.left < screenleft) {
          result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
        } else if (rect.right > screenw + screenleft - 3) {
          result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
        }
        return result;
      }
      function addToScrollTop(cm, top) {
        if (top == null) {
          return;
        }
        resolveScrollToPos(cm);
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
      }
      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor();
        cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
      }
      function scrollToCoords(cm, x2, y2) {
        if (x2 != null || y2 != null) {
          resolveScrollToPos(cm);
        }
        if (x2 != null) {
          cm.curOp.scrollLeft = x2;
        }
        if (y2 != null) {
          cm.curOp.scrollTop = y2;
        }
      }
      function scrollToRange(cm, range2) {
        resolveScrollToPos(cm);
        cm.curOp.scrollToPos = range2;
      }
      function resolveScrollToPos(cm) {
        var range2 = cm.curOp.scrollToPos;
        if (range2) {
          cm.curOp.scrollToPos = null;
          var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
          scrollToCoordsRange(cm, from, to, range2.margin);
        }
      }
      function scrollToCoordsRange(cm, from, to, margin) {
        var sPos = calculateScrollPos(cm, {
          left: Math.min(from.left, to.left),
          top: Math.min(from.top, to.top) - margin,
          right: Math.max(from.right, to.right),
          bottom: Math.max(from.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
      }
      function updateScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) {
          return;
        }
        if (!gecko) {
          updateDisplaySimple(cm, { top: val });
        }
        setScrollTop(cm, val, true);
        if (gecko) {
          updateDisplaySimple(cm);
        }
        startWorker(cm, 100);
      }
      function setScrollTop(cm, val, forceScroll) {
        val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
        if (cm.display.scroller.scrollTop == val && !forceScroll) {
          return;
        }
        cm.doc.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (cm.display.scroller.scrollTop != val) {
          cm.display.scroller.scrollTop = val;
        }
      }
      function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
          return;
        }
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val) {
          cm.display.scroller.scrollLeft = val;
        }
        cm.display.scrollbars.setScrollLeft(val);
      }
      function measureForScrollbars(cm) {
        var d2 = cm.display, gutterW = d2.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d2.scroller.clientHeight,
          viewHeight: d2.wrapper.clientHeight,
          scrollWidth: d2.scroller.scrollWidth,
          clientWidth: d2.scroller.clientWidth,
          viewWidth: d2.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d2.barHeight,
          nativeBarWidth: d2.nativeBarWidth,
          gutterWidth: gutterW
        };
      }
      var NativeScrollbars = function(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        vert.tabIndex = horiz.tabIndex = -1;
        place(vert);
        place(horiz);
        on(vert, "scroll", function() {
          if (vert.clientHeight) {
            scroll(vert.scrollTop, "vertical");
          }
        });
        on(horiz, "scroll", function() {
          if (horiz.clientWidth) {
            scroll(horiz.scrollLeft, "horizontal");
          }
        });
        this.checkedZeroWidth = false;
        if (ie && ie_version < 8) {
          this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
        }
      };
      NativeScrollbars.prototype.update = function(measure) {
        var needsH = measure.scrollWidth > measure.clientWidth + 1;
        var needsV = measure.scrollHeight > measure.clientHeight + 1;
        var sWidth = measure.nativeBarWidth;
        if (needsV) {
          this.vert.style.display = "block";
          this.vert.style.bottom = needsH ? sWidth + "px" : "0";
          var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
          this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
        } else {
          this.vert.scrollTop = 0;
          this.vert.style.display = "";
          this.vert.firstChild.style.height = "0";
        }
        if (needsH) {
          this.horiz.style.display = "block";
          this.horiz.style.right = needsV ? sWidth + "px" : "0";
          this.horiz.style.left = measure.barLeft + "px";
          var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
          this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
        } else {
          this.horiz.style.display = "";
          this.horiz.firstChild.style.width = "0";
        }
        if (!this.checkedZeroWidth && measure.clientHeight > 0) {
          if (sWidth == 0) {
            this.zeroWidthHack();
          }
          this.checkedZeroWidth = true;
        }
        return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
      };
      NativeScrollbars.prototype.setScrollLeft = function(pos) {
        if (this.horiz.scrollLeft != pos) {
          this.horiz.scrollLeft = pos;
        }
        if (this.disableHoriz) {
          this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
        }
      };
      NativeScrollbars.prototype.setScrollTop = function(pos) {
        if (this.vert.scrollTop != pos) {
          this.vert.scrollTop = pos;
        }
        if (this.disableVert) {
          this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
        }
      };
      NativeScrollbars.prototype.zeroWidthHack = function() {
        var w2 = mac && !mac_geMountainLion ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = w2;
        this.horiz.style.visibility = this.vert.style.visibility = "hidden";
        this.disableHoriz = new Delayed();
        this.disableVert = new Delayed();
      };
      NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type2) {
        bar.style.visibility = "";
        function maybeDisable() {
          var box = bar.getBoundingClientRect();
          var elt2 = type2 == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
          if (elt2 != bar) {
            bar.style.visibility = "hidden";
          } else {
            delay.set(1e3, maybeDisable);
          }
        }
        delay.set(1e3, maybeDisable);
      };
      NativeScrollbars.prototype.clear = function() {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz);
        parent.removeChild(this.vert);
      };
      var NullScrollbars = function() {
      };
      NullScrollbars.prototype.update = function() {
        return { bottom: 0, right: 0 };
      };
      NullScrollbars.prototype.setScrollLeft = function() {
      };
      NullScrollbars.prototype.setScrollTop = function() {
      };
      NullScrollbars.prototype.clear = function() {
      };
      function updateScrollbars(cm, measure) {
        if (!measure) {
          measure = measureForScrollbars(cm);
        }
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i3 = 0; i3 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i3++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
            updateHeightsInViewport(cm);
          }
          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth;
          startHeight = cm.display.barHeight;
        }
      }
      function updateScrollbarsInner(cm, measure) {
        var d2 = cm.display;
        var sizes = d2.scrollbars.update(measure);
        d2.sizer.style.paddingRight = (d2.barWidth = sizes.right) + "px";
        d2.sizer.style.paddingBottom = (d2.barHeight = sizes.bottom) + "px";
        d2.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
        if (sizes.right && sizes.bottom) {
          d2.scrollbarFiller.style.display = "block";
          d2.scrollbarFiller.style.height = sizes.bottom + "px";
          d2.scrollbarFiller.style.width = sizes.right + "px";
        } else {
          d2.scrollbarFiller.style.display = "";
        }
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d2.gutterFiller.style.display = "block";
          d2.gutterFiller.style.height = sizes.bottom + "px";
          d2.gutterFiller.style.width = measure.gutterWidth + "px";
        } else {
          d2.gutterFiller.style.display = "";
        }
      }
      var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();
          if (cm.display.scrollbars.addClass) {
            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
          on(node, "mousedown", function() {
            if (cm.state.focused) {
              setTimeout(function() {
                return cm.display.input.focus();
              }, 0);
            }
          });
          node.setAttribute("cm-not-content", "true");
        }, function(pos, axis) {
          if (axis == "horizontal") {
            setScrollLeft(cm, pos);
          } else {
            updateScrollTop(cm, pos);
          }
        }, cm);
        if (cm.display.scrollbars.addClass) {
          addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      var nextOpId = 0;
      function startOperation(cm) {
        cm.curOp = {
          cm,
          viewChanged: false,
          // Flag that indicates that lines might need to be redrawn
          startHeight: cm.doc.height,
          // Used to detect need to update scrollbar
          forceUpdate: false,
          // Used to force a redraw
          updateInput: 0,
          // Whether to reset the input textarea
          typing: false,
          // Whether this reset should be careful to leave existing text (for compositing)
          changeObjs: null,
          // Accumulated changes, for firing change events
          cursorActivityHandlers: null,
          // Set of handlers to fire cursorActivity on
          cursorActivityCalled: 0,
          // Tracks which cursorActivity handlers have been called already
          selectionChanged: false,
          // Whether the selection needs to be redrawn
          updateMaxLine: false,
          // Set when the widest line needs to be determined anew
          scrollLeft: null,
          scrollTop: null,
          // Intermediate scroll position, not pushed to DOM yet
          scrollToPos: null,
          // Used to scroll to a specific position
          focus: false,
          id: ++nextOpId,
          // Unique ID
          markArrays: null
          // Used by addMarkedSpan
        };
        pushOperation(cm.curOp);
      }
      function endOperation(cm) {
        var op = cm.curOp;
        if (op) {
          finishOperation(op, function(group) {
            for (var i3 = 0; i3 < group.ops.length; i3++) {
              group.ops[i3].cm.curOp = null;
            }
            endOperations(group);
          });
        }
      }
      function endOperations(group) {
        var ops = group.ops;
        for (var i3 = 0; i3 < ops.length; i3++) {
          endOperation_R1(ops[i3]);
        }
        for (var i$13 = 0; i$13 < ops.length; i$13++) {
          endOperation_W1(ops[i$13]);
        }
        for (var i$22 = 0; i$22 < ops.length; i$22++) {
          endOperation_R2(ops[i$22]);
        }
        for (var i$3 = 0; i$3 < ops.length; i$3++) {
          endOperation_W2(ops[i$3]);
        }
        for (var i$4 = 0; i$4 < ops.length; i$4++) {
          endOperation_finish(ops[i$4]);
        }
      }
      function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine) {
          findMaxLine(cm);
        }
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
      }
      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }
      function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        if (op.updatedDisplay) {
          updateHeightsInViewport(cm);
        }
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged) {
          op.preparedSelection = display.input.prepareSelection();
        }
      }
      function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
          if (op.maxScrollLeft < cm.doc.scrollLeft) {
            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
          }
          cm.display.maxLineChanged = false;
        }
        var takeFocus = op.focus && op.focus == activeElt(root2(cm));
        if (op.preparedSelection) {
          cm.display.input.showSelection(op.preparedSelection, takeFocus);
        }
        if (op.updatedDisplay || op.startHeight != cm.doc.height) {
          updateScrollbars(cm, op.barMeasure);
        }
        if (op.updatedDisplay) {
          setDocumentHeight(cm, op.barMeasure);
        }
        if (op.selectionChanged) {
          restartBlink(cm);
        }
        if (cm.state.focused && op.updateInput) {
          cm.display.input.reset(op.typing);
        }
        if (takeFocus) {
          ensureFocus(op.cm);
        }
      }
      function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc2 = cm.doc;
        if (op.updatedDisplay) {
          postUpdateDisplay(cm, op.update);
        }
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
          display.wheelStartX = display.wheelStartY = null;
        }
        if (op.scrollTop != null) {
          setScrollTop(cm, op.scrollTop, op.forceScroll);
        }
        if (op.scrollLeft != null) {
          setScrollLeft(cm, op.scrollLeft, true, true);
        }
        if (op.scrollToPos) {
          var rect = scrollPosIntoView(
            cm,
            clipPos(doc2, op.scrollToPos.from),
            clipPos(doc2, op.scrollToPos.to),
            op.scrollToPos.margin
          );
          maybeScrollWindow(cm, rect);
        }
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden) {
          for (var i3 = 0; i3 < hidden.length; ++i3) {
            if (!hidden[i3].lines.length) {
              signal(hidden[i3], "hide");
            }
          }
        }
        if (unhidden) {
          for (var i$13 = 0; i$13 < unhidden.length; ++i$13) {
            if (unhidden[i$13].lines.length) {
              signal(unhidden[i$13], "unhide");
            }
          }
        }
        if (display.wrapper.offsetHeight) {
          doc2.scrollTop = cm.display.scroller.scrollTop;
        }
        if (op.changeObjs) {
          signal(cm, "changes", cm, op.changeObjs);
        }
        if (op.update) {
          op.update.finish();
        }
      }
      function runInOp(cm, f2) {
        if (cm.curOp) {
          return f2();
        }
        startOperation(cm);
        try {
          return f2();
        } finally {
          endOperation(cm);
        }
      }
      function operation(cm, f2) {
        return function() {
          if (cm.curOp) {
            return f2.apply(cm, arguments);
          }
          startOperation(cm);
          try {
            return f2.apply(cm, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function methodOp(f2) {
        return function() {
          if (this.curOp) {
            return f2.apply(this, arguments);
          }
          startOperation(this);
          try {
            return f2.apply(this, arguments);
          } finally {
            endOperation(this);
          }
        };
      }
      function docMethodOp(f2) {
        return function() {
          var cm = this.cm;
          if (!cm || cm.curOp) {
            return f2.apply(this, arguments);
          }
          startOperation(cm);
          try {
            return f2.apply(this, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function startWorker(cm, time) {
        if (cm.doc.highlightFrontier < cm.display.viewTo) {
          cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
      }
      function highlightWorker(cm) {
        var doc2 = cm.doc;
        if (doc2.highlightFrontier >= cm.display.viewTo) {
          return;
        }
        var end = +/* @__PURE__ */ new Date() + cm.options.workTime;
        var context = getContextBefore(cm, doc2.highlightFrontier);
        var changedLines = [];
        doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line) {
          if (context.line >= cm.display.viewFrom) {
            var oldStyles = line.styles;
            var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;
            var highlighted = highlightLine(cm, line, context, true);
            if (resetState) {
              context.state = resetState;
            }
            line.styles = highlighted.styles;
            var oldCls = line.styleClasses, newCls = highlighted.classes;
            if (newCls) {
              line.styleClasses = newCls;
            } else if (oldCls) {
              line.styleClasses = null;
            }
            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
            for (var i3 = 0; !ischange && i3 < oldStyles.length; ++i3) {
              ischange = oldStyles[i3] != line.styles[i3];
            }
            if (ischange) {
              changedLines.push(context.line);
            }
            line.stateAfter = context.save();
            context.nextLine();
          } else {
            if (line.text.length <= cm.options.maxHighlightLength) {
              processLine(cm, line.text, context);
            }
            line.stateAfter = context.line % 5 == 0 ? context.save() : null;
            context.nextLine();
          }
          if (+/* @__PURE__ */ new Date() > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        doc2.highlightFrontier = context.line;
        doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);
        if (changedLines.length) {
          runInOp(cm, function() {
            for (var i3 = 0; i3 < changedLines.length; i3++) {
              regLineChange(cm, changedLines[i3], "text");
            }
          });
        }
      }
      var DisplayUpdate = function(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      };
      DisplayUpdate.prototype.signal = function(emitter, type2) {
        if (hasHandler(emitter, type2)) {
          this.events.push(arguments);
        }
      };
      DisplayUpdate.prototype.finish = function() {
        for (var i3 = 0; i3 < this.events.length; i3++) {
          signal.apply(null, this.events[i3]);
        }
      };
      function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }
      function selectionSnapshot(cm) {
        if (cm.hasFocus()) {
          return null;
        }
        var active = activeElt(root2(cm));
        if (!active || !contains(cm.display.lineDiv, active)) {
          return null;
        }
        var result = { activeElt: active };
        if (window.getSelection) {
          var sel = win(cm).getSelection();
          if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
            result.anchorNode = sel.anchorNode;
            result.anchorOffset = sel.anchorOffset;
            result.focusNode = sel.focusNode;
            result.focusOffset = sel.focusOffset;
          }
        }
        return result;
      }
      function restoreSelection(snapshot) {
        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(rootNode(snapshot.activeElt))) {
          return;
        }
        snapshot.activeElt.focus();
        if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
          var doc2 = snapshot.activeElt.ownerDocument;
          var sel = doc2.defaultView.getSelection(), range2 = doc2.createRange();
          range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
          range2.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range2);
          sel.extend(snapshot.focusNode, snapshot.focusOffset);
        }
      }
      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc2 = cm.doc;
        if (update.editorIsHidden) {
          resetView(cm);
          return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
          return false;
        }
        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        }
        var end = doc2.first + doc2.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc2.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20) {
          from = Math.max(doc2.first, display.viewFrom);
        }
        if (display.viewTo > to && display.viewTo - to < 20) {
          to = Math.min(end, display.viewTo);
        }
        if (sawCollapsedSpans) {
          from = visualLineNo(cm.doc, from);
          to = visualLineEndNo(cm.doc, to);
        }
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = heightAtLine(getLine2(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
          return false;
        }
        var selSnapshot = selectionSnapshot(cm);
        if (toUpdate > 4) {
          display.lineDiv.style.display = "none";
        }
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4) {
          display.lineDiv.style.display = "";
        }
        display.renderedView = display.view;
        restoreSelection(selSnapshot);
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;
        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
      }
      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;
        for (var first = true; ; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            if (viewport && viewport.top != null) {
              viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
            }
            update.visible = visibleLines(cm.display, cm.doc, viewport);
            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
              break;
            }
          } else if (first) {
            update.visible = visibleLines(cm.display, cm.doc, viewport);
          }
          if (!updateDisplayIfNeeded(cm, update)) {
            break;
          }
          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.force = false;
        }
        update.signal(cm, "update", cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom;
          cm.display.reportedViewTo = cm.display.viewTo;
        }
      }
      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.finish();
        }
      }
      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display, lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv, cur = container.firstChild;
        function rm(node2) {
          var next = node2.nextSibling;
          if (webkit && mac && cm.display.currentWheelTarget == node2) {
            node2.style.display = "none";
          } else {
            node2.parentNode.removeChild(node2);
          }
          return next;
        }
        var view = display.view, lineN = display.viewFrom;
        for (var i3 = 0; i3 < view.length; i3++) {
          var lineView = view[i3];
          if (lineView.hidden) ;
          else if (!lineView.node || lineView.node.parentNode != container) {
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else {
            while (cur != lineView.node) {
              cur = rm(cur);
            }
            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1) {
                updateNumber = false;
              }
              updateLineForChanges(cm, lineView, lineN, dims);
            }
            if (updateNumber) {
              removeChildren(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }
            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }
        while (cur) {
          cur = rm(cur);
        }
      }
      function updateGutterSpace(display) {
        var width = display.gutters.offsetWidth;
        display.sizer.style.marginLeft = width + "px";
        signalLater(display, "gutterChanged", display);
      }
      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
      }
      function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
          return;
        }
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth, left = comp + "px";
        for (var i3 = 0; i3 < view.length; i3++) {
          if (!view[i3].hidden) {
            if (cm.options.fixedGutter) {
              if (view[i3].gutter) {
                view[i3].gutter.style.left = left;
              }
              if (view[i3].gutterBackground) {
                view[i3].gutterBackground.style.left = left;
              }
            }
            var align = view[i3].alignable;
            if (align) {
              for (var j2 = 0; j2 < align.length; j2++) {
                align[j2].style.left = left;
              }
            }
          }
        }
        if (cm.options.fixedGutter) {
          display.gutters.style.left = comp + gutterW + "px";
        }
      }
      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) {
          return false;
        }
        var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt(
            "div",
            [elt("div", last)],
            "CodeMirror-linenumber CodeMirror-gutter-elt"
          ));
          var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm.display);
          return true;
        }
        return false;
      }
      function getGutters(gutters, lineNumbers) {
        var result = [], sawLineNumbers = false;
        for (var i3 = 0; i3 < gutters.length; i3++) {
          var name = gutters[i3], style = null;
          if (typeof name != "string") {
            style = name.style;
            name = name.className;
          }
          if (name == "CodeMirror-linenumbers") {
            if (!lineNumbers) {
              continue;
            } else {
              sawLineNumbers = true;
            }
          }
          result.push({ className: name, style });
        }
        if (lineNumbers && !sawLineNumbers) {
          result.push({ className: "CodeMirror-linenumbers", style: null });
        }
        return result;
      }
      function renderGutters(display) {
        var gutters = display.gutters, specs = display.gutterSpecs;
        removeChildren(gutters);
        display.lineGutter = null;
        for (var i3 = 0; i3 < specs.length; ++i3) {
          var ref = specs[i3];
          var className = ref.className;
          var style = ref.style;
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
          if (style) {
            gElt.style.cssText = style;
          }
          if (className == "CodeMirror-linenumbers") {
            display.lineGutter = gElt;
            gElt.style.width = (display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = specs.length ? "" : "none";
        updateGutterSpace(display);
      }
      function updateGutters(cm) {
        renderGutters(cm.display);
        regChange(cm);
        alignHorizontally(cm);
      }
      function Display(place, doc2, input, options) {
        var d2 = this;
        this.input = input;
        d2.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d2.scrollbarFiller.setAttribute("cm-not-content", "true");
        d2.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d2.gutterFiller.setAttribute("cm-not-content", "true");
        d2.lineDiv = eltP("div", null, "CodeMirror-code");
        d2.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d2.cursorDiv = elt("div", null, "CodeMirror-cursors");
        d2.measure = elt("div", null, "CodeMirror-measure");
        d2.lineMeasure = elt("div", null, "CodeMirror-measure");
        d2.lineSpace = eltP(
          "div",
          [d2.measure, d2.lineMeasure, d2.selectionDiv, d2.cursorDiv, d2.lineDiv],
          null,
          "position: relative; outline: none"
        );
        var lines = eltP("div", [d2.lineSpace], "CodeMirror-lines");
        d2.mover = elt("div", [lines], null, "position: relative");
        d2.sizer = elt("div", [d2.mover], "CodeMirror-sizer");
        d2.sizerWidth = null;
        d2.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
        d2.gutters = elt("div", null, "CodeMirror-gutters");
        d2.lineGutter = null;
        d2.scroller = elt("div", [d2.sizer, d2.heightForcer, d2.gutters], "CodeMirror-scroll");
        d2.scroller.setAttribute("tabIndex", "-1");
        d2.wrapper = elt("div", [d2.scrollbarFiller, d2.gutterFiller, d2.scroller], "CodeMirror");
        if (chrome && chrome_version === 105) {
          d2.wrapper.style.clipPath = "inset(0px)";
        }
        d2.wrapper.setAttribute("translate", "no");
        if (ie && ie_version < 8) {
          d2.gutters.style.zIndex = -1;
          d2.scroller.style.paddingRight = 0;
        }
        if (!webkit && !(gecko && mobile)) {
          d2.scroller.draggable = true;
        }
        if (place) {
          if (place.appendChild) {
            place.appendChild(d2.wrapper);
          } else {
            place(d2.wrapper);
          }
        }
        d2.viewFrom = d2.viewTo = doc2.first;
        d2.reportedViewFrom = d2.reportedViewTo = doc2.first;
        d2.view = [];
        d2.renderedView = null;
        d2.externalMeasured = null;
        d2.viewOffset = 0;
        d2.lastWrapHeight = d2.lastWrapWidth = 0;
        d2.updateLineNumbers = null;
        d2.nativeBarWidth = d2.barHeight = d2.barWidth = 0;
        d2.scrollbarsClipped = false;
        d2.lineNumWidth = d2.lineNumInnerWidth = d2.lineNumChars = null;
        d2.alignWidgets = false;
        d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
        d2.maxLine = null;
        d2.maxLineLength = 0;
        d2.maxLineChanged = false;
        d2.wheelDX = d2.wheelDY = d2.wheelStartX = d2.wheelStartY = null;
        d2.shift = false;
        d2.selForContextMenu = null;
        d2.activeTouch = null;
        d2.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
        renderGutters(d2);
        input.init(d2);
      }
      var wheelSamples = 0, wheelPixelsPerUnit = null;
      if (ie) {
        wheelPixelsPerUnit = -0.53;
      } else if (gecko) {
        wheelPixelsPerUnit = 15;
      } else if (chrome) {
        wheelPixelsPerUnit = -0.7;
      } else if (safari) {
        wheelPixelsPerUnit = -1 / 3;
      }
      function wheelEventDelta(e2) {
        var dx = e2.wheelDeltaX, dy = e2.wheelDeltaY;
        if (dx == null && e2.detail && e2.axis == e2.HORIZONTAL_AXIS) {
          dx = e2.detail;
        }
        if (dy == null && e2.detail && e2.axis == e2.VERTICAL_AXIS) {
          dy = e2.detail;
        } else if (dy == null) {
          dy = e2.wheelDelta;
        }
        return { x: dx, y: dy };
      }
      function wheelEventPixels(e2) {
        var delta = wheelEventDelta(e2);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
      }
      function onScrollWheel(cm, e2) {
        if (chrome && chrome_version == 102) {
          if (cm.display.chromeScrollHack == null) {
            cm.display.sizer.style.pointerEvents = "none";
          } else {
            clearTimeout(cm.display.chromeScrollHack);
          }
          cm.display.chromeScrollHack = setTimeout(function() {
            cm.display.chromeScrollHack = null;
            cm.display.sizer.style.pointerEvents = "";
          }, 100);
        }
        var delta = wheelEventDelta(e2), dx = delta.x, dy = delta.y;
        var pixelsPerUnit = wheelPixelsPerUnit;
        if (e2.deltaMode === 0) {
          dx = e2.deltaX;
          dy = e2.deltaY;
          pixelsPerUnit = 1;
        }
        var display = cm.display, scroll = display.scroller;
        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (!(dx && canScrollX || dy && canScrollY)) {
          return;
        }
        if (dy && mac && webkit) {
          outer: for (var cur = e2.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i3 = 0; i3 < view.length; i3++) {
              if (view[i3].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
        }
        if (dx && !gecko && !presto && pixelsPerUnit != null) {
          if (dy && canScrollY) {
            updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
          }
          setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
          if (!dy || dy && canScrollY) {
            e_preventDefault(e2);
          }
          display.wheelStartX = null;
          return;
        }
        if (dy && pixelsPerUnit != null) {
          var pixels = dy * pixelsPerUnit;
          var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
          if (pixels < 0) {
            top = Math.max(0, top + pixels - 50);
          } else {
            bot = Math.min(cm.doc.height, bot + pixels + 50);
          }
          updateDisplaySimple(cm, { top, bottom: bot });
        }
        if (wheelSamples < 20 && e2.deltaMode !== 0) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;
            display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;
            display.wheelDY = dy;
            setTimeout(function() {
              if (display.wheelStartX == null) {
                return;
              }
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
              display.wheelStartX = display.wheelStartY = null;
              if (!sample) {
                return;
              }
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;
            display.wheelDY += dy;
          }
        }
      }
      var Selection2 = function(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      };
      Selection2.prototype.primary = function() {
        return this.ranges[this.primIndex];
      };
      Selection2.prototype.equals = function(other) {
        if (other == this) {
          return true;
        }
        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
          return false;
        }
        for (var i3 = 0; i3 < this.ranges.length; i3++) {
          var here = this.ranges[i3], there = other.ranges[i3];
          if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
            return false;
          }
        }
        return true;
      };
      Selection2.prototype.deepCopy = function() {
        var out = [];
        for (var i3 = 0; i3 < this.ranges.length; i3++) {
          out[i3] = new Range(copyPos(this.ranges[i3].anchor), copyPos(this.ranges[i3].head));
        }
        return new Selection2(out, this.primIndex);
      };
      Selection2.prototype.somethingSelected = function() {
        for (var i3 = 0; i3 < this.ranges.length; i3++) {
          if (!this.ranges[i3].empty()) {
            return true;
          }
        }
        return false;
      };
      Selection2.prototype.contains = function(pos, end) {
        if (!end) {
          end = pos;
        }
        for (var i3 = 0; i3 < this.ranges.length; i3++) {
          var range2 = this.ranges[i3];
          if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
            return i3;
          }
        }
        return -1;
      };
      var Range = function(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      };
      Range.prototype.from = function() {
        return minPos(this.anchor, this.head);
      };
      Range.prototype.to = function() {
        return maxPos(this.anchor, this.head);
      };
      Range.prototype.empty = function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      };
      function normalizeSelection(cm, ranges, primIndex) {
        var mayTouch = cm && cm.options.selectionsMayTouch;
        var prim = ranges[primIndex];
        ranges.sort(function(a2, b) {
          return cmp(a2.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for (var i3 = 1; i3 < ranges.length; i3++) {
          var cur = ranges[i3], prev = ranges[i3 - 1];
          var diff = cmp(prev.to(), cur.from());
          if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
            var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
            if (i3 <= primIndex) {
              --primIndex;
            }
            ranges.splice(--i3, 2, new Range(inv ? to : from, inv ? from : to));
          }
        }
        return new Selection2(ranges, primIndex);
      }
      function simpleSelection(anchor, head) {
        return new Selection2([new Range(anchor, head || anchor)], 0);
      }
      function changeEnd(change) {
        if (!change.text) {
          return change.to;
        }
        return Pos(
          change.from.line + change.text.length - 1,
          lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0)
        );
      }
      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) {
          return pos;
        }
        if (cmp(pos, change.to) <= 0) {
          return changeEnd(change);
        }
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        if (pos.line == change.to.line) {
          ch += changeEnd(change).ch - change.to.ch;
        }
        return Pos(line, ch);
      }
      function computeSelAfterChange(doc2, change) {
        var out = [];
        for (var i3 = 0; i3 < doc2.sel.ranges.length; i3++) {
          var range2 = doc2.sel.ranges[i3];
          out.push(new Range(
            adjustForChange(range2.anchor, change),
            adjustForChange(range2.head, change)
          ));
        }
        return normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
      }
      function offsetPos(pos, old, nw) {
        if (pos.line == old.line) {
          return Pos(nw.line, pos.ch - old.ch + nw.ch);
        } else {
          return Pos(nw.line + (pos.line - old.line), pos.ch);
        }
      }
      function computeReplacedSel(doc2, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;
        for (var i3 = 0; i3 < changes.length; i3++) {
          var change = changes[i3];
          var from = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;
          if (hint == "around") {
            var range2 = doc2.sel.ranges[i3], inv = cmp(range2.head, range2.anchor) < 0;
            out[i3] = new Range(inv ? to : from, inv ? from : to);
          } else {
            out[i3] = new Range(from, from);
          }
        }
        return new Selection2(out, doc2.sel.primIndex);
      }
      function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }
      function resetModeState(cm) {
        cm.doc.iter(function(line) {
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
        });
        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp) {
          regChange(cm);
        }
      }
      function isWholeLineUpdate(doc2, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);
      }
      function updateDoc(doc2, change, markedSpans, estimateHeight2) {
        function spansFor(n2) {
          return markedSpans ? markedSpans[n2] : null;
        }
        function update(line, text2, spans) {
          updateLine(line, text2, spans, estimateHeight2);
          signalLater(line, "change", line, change);
        }
        function linesFor(start2, end) {
          var result = [];
          for (var i3 = start2; i3 < end; ++i3) {
            result.push(new Line(text[i3], spansFor(i3), estimateHeight2));
          }
          return result;
        }
        var from = change.from, to = change.to, text = change.text;
        var firstLine = getLine2(doc2, from.line), lastLine = getLine2(doc2, to.line);
        var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
        if (change.full) {
          doc2.insert(0, linesFor(0, text.length));
          doc2.remove(text.length, doc2.size - text.length);
        } else if (isWholeLineUpdate(doc2, change)) {
          var added = linesFor(0, text.length - 1);
          update(lastLine, lastLine.text, lastSpans);
          if (nlines) {
            doc2.remove(from.line, nlines);
          }
          if (added.length) {
            doc2.insert(from.line, added);
          }
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added$1 = linesFor(1, text.length - 1);
            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc2.insert(from.line + 1, added$1);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc2.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added$2 = linesFor(1, text.length - 1);
          if (nlines > 1) {
            doc2.remove(from.line + 1, nlines - 1);
          }
          doc2.insert(from.line + 1, added$2);
        }
        signalLater(doc2, "change", doc2, change);
      }
      function linkedDocs(doc2, f2, sharedHistOnly) {
        function propagate(doc3, skip, sharedHist) {
          if (doc3.linked) {
            for (var i3 = 0; i3 < doc3.linked.length; ++i3) {
              var rel = doc3.linked[i3];
              if (rel.doc == skip) {
                continue;
              }
              var shared = sharedHist && rel.sharedHist;
              if (sharedHistOnly && !shared) {
                continue;
              }
              f2(rel.doc, shared);
              propagate(rel.doc, doc3, shared);
            }
          }
        }
        propagate(doc2, null, true);
      }
      function attachDoc(cm, doc2) {
        if (doc2.cm) {
          throw new Error("This document is already in use.");
        }
        cm.doc = doc2;
        doc2.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        setDirectionClass(cm);
        cm.options.direction = doc2.direction;
        if (!cm.options.lineWrapping) {
          findMaxLine(cm);
        }
        cm.options.mode = doc2.modeOption;
        regChange(cm);
      }
      function setDirectionClass(cm) {
        (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
      }
      function directionChanged(cm) {
        runInOp(cm, function() {
          setDirectionClass(cm);
          regChange(cm);
        });
      }
      function History(prev) {
        this.done = [];
        this.undone = [];
        this.undoDepth = prev ? prev.undoDepth : Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
      }
      function historyChangeFromChange(doc2, change) {
        var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };
        attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc2, function(doc3) {
          return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      }
      function clearSelectionEvents(array2) {
        while (array2.length) {
          var last = lst(array2);
          if (last.ranges) {
            array2.pop();
          } else {
            break;
          }
        }
      }
      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done);
        }
      }
      function addChangeToHistory(doc2, change, selAfter, opId) {
        var hist = doc2.history;
        hist.undone.length = 0;
        var time = +/* @__PURE__ */ new Date(), cur;
        var last;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          last = lst(cur.changes);
          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            last.to = changeEnd(change);
          } else {
            cur.changes.push(historyChangeFromChange(doc2, change));
          }
        } else {
          var before = lst(hist.done);
          if (!before || !before.ranges) {
            pushSelectionToHistory(doc2.sel, hist.done);
          }
          cur = {
            changes: [historyChangeFromChange(doc2, change)],
            generation: hist.generation
          };
          hist.done.push(cur);
          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();
            if (!hist.done[0].ranges) {
              hist.done.shift();
            }
          }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last) {
          signal(doc2, "historyAdded");
        }
      }
      function selectionEventCanBeMerged(doc2, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && /* @__PURE__ */ new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);
      }
      function addSelectionToHistory(doc2, sel, opId, options) {
        var hist = doc2.history, origin = options && options.origin;
        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {
          hist.done[hist.done.length - 1] = sel;
        } else {
          pushSelectionToHistory(sel, hist.done);
        }
        hist.lastSelTime = +/* @__PURE__ */ new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false) {
          clearSelectionEvents(hist.undone);
        }
      }
      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel))) {
          dest.push(sel);
        }
      }
      function attachLocalSpans(doc2, change, from, to) {
        var existing = change["spans_" + doc2.id], n2 = 0;
        doc2.iter(Math.max(doc2.first, from), Math.min(doc2.first + doc2.size, to), function(line) {
          if (line.markedSpans) {
            (existing || (existing = change["spans_" + doc2.id] = {}))[n2] = line.markedSpans;
          }
          ++n2;
        });
      }
      function removeClearedSpans(spans) {
        if (!spans) {
          return null;
        }
        var out;
        for (var i3 = 0; i3 < spans.length; ++i3) {
          if (spans[i3].marker.explicitlyCleared) {
            if (!out) {
              out = spans.slice(0, i3);
            }
          } else if (out) {
            out.push(spans[i3]);
          }
        }
        return !out ? spans : out.length ? out : null;
      }
      function getOldSpans(doc2, change) {
        var found = change["spans_" + doc2.id];
        if (!found) {
          return null;
        }
        var nw = [];
        for (var i3 = 0; i3 < change.text.length; ++i3) {
          nw.push(removeClearedSpans(found[i3]));
        }
        return nw;
      }
      function mergeOldSpans(doc2, change) {
        var old = getOldSpans(doc2, change);
        var stretched = stretchSpansOverChange(doc2, change);
        if (!old) {
          return stretched;
        }
        if (!stretched) {
          return old;
        }
        for (var i3 = 0; i3 < old.length; ++i3) {
          var oldCur = old[i3], stretchCur = stretched[i3];
          if (oldCur && stretchCur) {
            spans: for (var j2 = 0; j2 < stretchCur.length; ++j2) {
              var span = stretchCur[j2];
              for (var k2 = 0; k2 < oldCur.length; ++k2) {
                if (oldCur[k2].marker == span.marker) {
                  continue spans;
                }
              }
              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i3] = stretchCur;
          }
        }
        return old;
      }
      function copyHistoryArray(events, newGroup, instantiateSel) {
        var copy2 = [];
        for (var i3 = 0; i3 < events.length; ++i3) {
          var event = events[i3];
          if (event.ranges) {
            copy2.push(instantiateSel ? Selection2.prototype.deepCopy.call(event) : event);
            continue;
          }
          var changes = event.changes, newChanges = [];
          copy2.push({ changes: newChanges });
          for (var j2 = 0; j2 < changes.length; ++j2) {
            var change = changes[j2], m2 = void 0;
            newChanges.push({ from: change.from, to: change.to, text: change.text });
            if (newGroup) {
              for (var prop2 in change) {
                if (m2 = prop2.match(/^spans_(\d+)$/)) {
                  if (indexOf(newGroup, Number(m2[1])) > -1) {
                    lst(newChanges)[prop2] = change[prop2];
                    delete change[prop2];
                  }
                }
              }
            }
          }
        }
        return copy2;
      }
      function extendRange(range2, head, other, extend2) {
        if (extend2) {
          var anchor = range2.anchor;
          if (other) {
            var posBefore = cmp(head, anchor) < 0;
            if (posBefore != cmp(other, anchor) < 0) {
              anchor = head;
              head = other;
            } else if (posBefore != cmp(head, other) < 0) {
              head = other;
            }
          }
          return new Range(anchor, head);
        } else {
          return new Range(other || head, head);
        }
      }
      function extendSelection(doc2, head, other, options, extend2) {
        if (extend2 == null) {
          extend2 = doc2.cm && (doc2.cm.display.shift || doc2.extend);
        }
        setSelection(doc2, new Selection2([extendRange(doc2.sel.primary(), head, other, extend2)], 0), options);
      }
      function extendSelections(doc2, heads, options) {
        var out = [];
        var extend2 = doc2.cm && (doc2.cm.display.shift || doc2.extend);
        for (var i3 = 0; i3 < doc2.sel.ranges.length; i3++) {
          out[i3] = extendRange(doc2.sel.ranges[i3], heads[i3], null, extend2);
        }
        var newSel = normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
        setSelection(doc2, newSel, options);
      }
      function replaceOneSelection(doc2, i3, range2, options) {
        var ranges = doc2.sel.ranges.slice(0);
        ranges[i3] = range2;
        setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options);
      }
      function setSimpleSelection(doc2, anchor, head, options) {
        setSelection(doc2, simpleSelection(anchor, head), options);
      }
      function filterSelectionChange(doc2, sel, options) {
        var obj = {
          ranges: sel.ranges,
          update: function(ranges) {
            this.ranges = [];
            for (var i3 = 0; i3 < ranges.length; i3++) {
              this.ranges[i3] = new Range(
                clipPos(doc2, ranges[i3].anchor),
                clipPos(doc2, ranges[i3].head)
              );
            }
          },
          origin: options && options.origin
        };
        signal(doc2, "beforeSelectionChange", doc2, obj);
        if (doc2.cm) {
          signal(doc2.cm, "beforeSelectionChange", doc2.cm, obj);
        }
        if (obj.ranges != sel.ranges) {
          return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);
        } else {
          return sel;
        }
      }
      function setSelectionReplaceHistory(doc2, sel, options) {
        var done = doc2.history.done, last = lst(done);
        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc2, sel, options);
        } else {
          setSelection(doc2, sel, options);
        }
      }
      function setSelection(doc2, sel, options) {
        setSelectionNoUndo(doc2, sel, options);
        addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options);
      }
      function setSelectionNoUndo(doc2, sel, options) {
        if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {
          sel = filterSelectionChange(doc2, sel, options);
        }
        var bias = options && options.bias || (cmp(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));
        if (!(options && options.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {
          ensureCursorVisible(doc2.cm);
        }
      }
      function setSelectionInner(doc2, sel) {
        if (sel.equals(doc2.sel)) {
          return;
        }
        doc2.sel = sel;
        if (doc2.cm) {
          doc2.cm.curOp.updateInput = 1;
          doc2.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc2.cm);
        }
        signalLater(doc2, "cursorActivity", doc2);
      }
      function reCheckSelection(doc2) {
        setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));
      }
      function skipAtomicInSelection(doc2, sel, bias, mayClear) {
        var out;
        for (var i3 = 0; i3 < sel.ranges.length; i3++) {
          var range2 = sel.ranges[i3];
          var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i3];
          var newAnchor = skipAtomic(doc2, range2.anchor, old && old.anchor, bias, mayClear);
          var newHead = range2.head == range2.anchor ? newAnchor : skipAtomic(doc2, range2.head, old && old.head, bias, mayClear);
          if (out || newAnchor != range2.anchor || newHead != range2.head) {
            if (!out) {
              out = sel.ranges.slice(0, i3);
            }
            out[i3] = new Range(newAnchor, newHead);
          }
        }
        return out ? normalizeSelection(doc2.cm, out, sel.primIndex) : sel;
      }
      function skipAtomicInner(doc2, pos, oldPos, dir, mayClear) {
        var line = getLine2(doc2, pos.line);
        if (line.markedSpans) {
          for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
            var sp = line.markedSpans[i3], m2 = sp.marker;
            var preventCursorLeft = "selectLeft" in m2 ? !m2.selectLeft : m2.inclusiveLeft;
            var preventCursorRight = "selectRight" in m2 ? !m2.selectRight : m2.inclusiveRight;
            if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
              if (mayClear) {
                signal(m2, "beforeCursorEnter");
                if (m2.explicitlyCleared) {
                  if (!line.markedSpans) {
                    break;
                  } else {
                    --i3;
                    continue;
                  }
                }
              }
              if (!m2.atomic) {
                continue;
              }
              if (oldPos) {
                var near = m2.find(dir < 0 ? 1 : -1), diff = void 0;
                if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                  near = movePos(doc2, near, -dir, near && near.line == pos.line ? line : null);
                }
                if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                  return skipAtomicInner(doc2, near, pos, dir, mayClear);
                }
              }
              var far = m2.find(dir < 0 ? -1 : 1);
              if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                far = movePos(doc2, far, dir, far.line == pos.line ? line : null);
              }
              return far ? skipAtomicInner(doc2, far, pos, dir, mayClear) : null;
            }
          }
        }
        return pos;
      }
      function skipAtomic(doc2, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc2, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir, true) || skipAtomicInner(doc2, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir, true);
        if (!found) {
          doc2.cantEdit = true;
          return Pos(doc2.first, 0);
        }
        return found;
      }
      function movePos(doc2, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
          if (pos.line > doc2.first) {
            return clipPos(doc2, Pos(pos.line - 1));
          } else {
            return null;
          }
        } else if (dir > 0 && pos.ch == (line || getLine2(doc2, pos.line)).text.length) {
          if (pos.line < doc2.first + doc2.size - 1) {
            return Pos(pos.line + 1, 0);
          } else {
            return null;
          }
        } else {
          return new Pos(pos.line, pos.ch + dir);
        }
      }
      function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
      }
      function filterChange(doc2, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function() {
            return obj.canceled = true;
          }
        };
        if (update) {
          obj.update = function(from, to, text, origin) {
            if (from) {
              obj.from = clipPos(doc2, from);
            }
            if (to) {
              obj.to = clipPos(doc2, to);
            }
            if (text) {
              obj.text = text;
            }
            if (origin !== void 0) {
              obj.origin = origin;
            }
          };
        }
        signal(doc2, "beforeChange", doc2, obj);
        if (doc2.cm) {
          signal(doc2.cm, "beforeChange", doc2.cm, obj);
        }
        if (obj.canceled) {
          if (doc2.cm) {
            doc2.cm.curOp.updateInput = 2;
          }
          return null;
        }
        return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
      }
      function makeChange(doc2, change, ignoreReadOnly) {
        if (doc2.cm) {
          if (!doc2.cm.curOp) {
            return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);
          }
          if (doc2.cm.state.suppressEdits) {
            return;
          }
        }
        if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {
          change = filterChange(doc2, change, true);
          if (!change) {
            return;
          }
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);
        if (split) {
          for (var i3 = split.length - 1; i3 >= 0; --i3) {
            makeChangeInner(doc2, { from: split[i3].from, to: split[i3].to, text: i3 ? [""] : change.text, origin: change.origin });
          }
        } else {
          makeChangeInner(doc2, change);
        }
      }
      function makeChangeInner(doc2, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
          return;
        }
        var selAfter = computeSelAfterChange(doc2, change);
        addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));
        var rebased = [];
        linkedDocs(doc2, function(doc3, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
            rebaseHist(doc3.history, change);
            rebased.push(doc3.history);
          }
          makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));
        });
      }
      function makeChangeFromHistory(doc2, type2, allowSelectionOnly) {
        var suppress = doc2.cm && doc2.cm.state.suppressEdits;
        if (suppress && !allowSelectionOnly) {
          return;
        }
        var hist = doc2.history, event, selAfter = doc2.sel;
        var source = type2 == "undo" ? hist.done : hist.undone, dest = type2 == "undo" ? hist.undone : hist.done;
        var i3 = 0;
        for (; i3 < source.length; i3++) {
          event = source[i3];
          if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {
            break;
          }
        }
        if (i3 == source.length) {
          return;
        }
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (; ; ) {
          event = source.pop();
          if (event.ranges) {
            pushSelectionToHistory(event, dest);
            if (allowSelectionOnly && !event.equals(doc2.sel)) {
              setSelection(doc2, event, { clearRedo: false });
              return;
            }
            selAfter = event;
          } else if (suppress) {
            source.push(event);
            return;
          } else {
            break;
          }
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({ changes: antiChanges, generation: hist.generation });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter2 = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");
        var loop = function(i4) {
          var change = event.changes[i4];
          change.origin = type2;
          if (filter2 && !filterChange(doc2, change, false)) {
            source.length = 0;
            return {};
          }
          antiChanges.push(historyChangeFromChange(doc2, change));
          var after = i4 ? computeSelAfterChange(doc2, change) : lst(source);
          makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));
          if (!i4 && doc2.cm) {
            doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
          }
          var rebased = [];
          linkedDocs(doc2, function(doc3, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
              rebaseHist(doc3.history, change);
              rebased.push(doc3.history);
            }
            makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));
          });
        };
        for (var i$13 = event.changes.length - 1; i$13 >= 0; --i$13) {
          var returned = loop(i$13);
          if (returned) return returned.v;
        }
      }
      function shiftDoc(doc2, distance2) {
        if (distance2 == 0) {
          return;
        }
        doc2.first += distance2;
        doc2.sel = new Selection2(map2(doc2.sel.ranges, function(range2) {
          return new Range(
            Pos(range2.anchor.line + distance2, range2.anchor.ch),
            Pos(range2.head.line + distance2, range2.head.ch)
          );
        }), doc2.sel.primIndex);
        if (doc2.cm) {
          regChange(doc2.cm, doc2.first, doc2.first - distance2, distance2);
          for (var d2 = doc2.cm.display, l2 = d2.viewFrom; l2 < d2.viewTo; l2++) {
            regLineChange(doc2.cm, l2, "gutter");
          }
        }
      }
      function makeChangeSingleDoc(doc2, change, selAfter, spans) {
        if (doc2.cm && !doc2.cm.curOp) {
          return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);
        }
        if (change.to.line < doc2.first) {
          shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }
        if (change.from.line > doc2.lastLine()) {
          return;
        }
        if (change.from.line < doc2.first) {
          var shift = change.text.length - 1 - (doc2.first - change.from.line);
          shiftDoc(doc2, shift);
          change = {
            from: Pos(doc2.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)],
            origin: change.origin
          };
        }
        var last = doc2.lastLine();
        if (change.to.line > last) {
          change = {
            from: change.from,
            to: Pos(last, getLine2(doc2, last).text.length),
            text: [change.text[0]],
            origin: change.origin
          };
        }
        change.removed = getBetween(doc2, change.from, change.to);
        if (!selAfter) {
          selAfter = computeSelAfterChange(doc2, change);
        }
        if (doc2.cm) {
          makeChangeSingleDocInEditor(doc2.cm, change, spans);
        } else {
          updateDoc(doc2, change, spans);
        }
        setSelectionNoUndo(doc2, selAfter, sel_dontScroll);
        if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {
          doc2.cantEdit = false;
        }
      }
      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc2 = cm.doc, display = cm.display, from = change.from, to = change.to;
        var recomputeMaxLength = false, checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine2(doc2, from.line)));
          doc2.iter(checkWidthStart, to.line + 1, function(line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }
        if (doc2.sel.contains(change.from, change.to) > -1) {
          signalCursorActivity(cm);
        }
        updateDoc(doc2, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
          doc2.iter(checkWidthStart, from.line + change.text.length, function(line) {
            var len = lineLength(line);
            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength) {
            cm.curOp.updateMaxLine = true;
          }
        }
        retreatFrontier(doc2, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        if (change.full) {
          regChange(cm);
        } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
          regLineChange(cm, from.line, "text");
        } else {
          regChange(cm, from.line, to.line + 1, lendiff);
        }
        var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
          var obj = {
            from,
            to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };
          if (changeHandler) {
            signalLater(cm, "change", cm, obj);
          }
          if (changesHandler) {
            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
          }
        }
        cm.display.selForContextMenu = null;
      }
      function replaceRange(doc2, code, from, to, origin) {
        var assign;
        if (!to) {
          to = from;
        }
        if (cmp(to, from) < 0) {
          assign = [to, from], from = assign[0], to = assign[1];
        }
        if (typeof code == "string") {
          code = doc2.splitLines(code);
        }
        makeChange(doc2, { from, to, text: code, origin });
      }
      function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      }
      function rebaseHistArray(array2, from, to, diff) {
        for (var i3 = 0; i3 < array2.length; ++i3) {
          var sub = array2[i3], ok = true;
          if (sub.ranges) {
            if (!sub.copied) {
              sub = array2[i3] = sub.deepCopy();
              sub.copied = true;
            }
            for (var j2 = 0; j2 < sub.ranges.length; j2++) {
              rebaseHistSelSingle(sub.ranges[j2].anchor, from, to, diff);
              rebaseHistSelSingle(sub.ranges[j2].head, from, to, diff);
            }
            continue;
          }
          for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
            var cur = sub.changes[j$1];
            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff, cur.from.ch);
              cur.to = Pos(cur.to.line + diff, cur.to.ch);
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }
          if (!ok) {
            array2.splice(0, i3 + 1);
            i3 = 0;
          }
        }
      }
      function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      }
      function changeLine(doc2, handle, changeType, op) {
        var no = handle, line = handle;
        if (typeof handle == "number") {
          line = getLine2(doc2, clipLine(doc2, handle));
        } else {
          no = lineNo(handle);
        }
        if (no == null) {
          return null;
        }
        if (op(line, no) && doc2.cm) {
          regLineChange(doc2.cm, no, changeType);
        }
        return line;
      }
      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        var height = 0;
        for (var i3 = 0; i3 < lines.length; ++i3) {
          lines[i3].parent = this;
          height += lines[i3].height;
        }
        this.height = height;
      }
      LeafChunk.prototype = {
        chunkSize: function() {
          return this.lines.length;
        },
        // Remove the n lines at offset 'at'.
        removeInner: function(at, n2) {
          for (var i3 = at, e2 = at + n2; i3 < e2; ++i3) {
            var line = this.lines[i3];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n2);
        },
        // Helper used to collapse a small branch into a single leaf.
        collapse: function(lines) {
          lines.push.apply(lines, this.lines);
        },
        // Insert the given array of lines at offset 'at', count them as
        // having the given height.
        insertInner: function(at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i3 = 0; i3 < lines.length; ++i3) {
            lines[i3].parent = this;
          }
        },
        // Used to iterate over a part of the tree.
        iterN: function(at, n2, op) {
          for (var e2 = at + n2; at < e2; ++at) {
            if (op(this.lines[at])) {
              return true;
            }
          }
        }
      };
      function BranchChunk(children2) {
        this.children = children2;
        var size = 0, height = 0;
        for (var i3 = 0; i3 < children2.length; ++i3) {
          var ch = children2[i3];
          size += ch.chunkSize();
          height += ch.height;
          ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }
      BranchChunk.prototype = {
        chunkSize: function() {
          return this.size;
        },
        removeInner: function(at, n2) {
          this.size -= n2;
          for (var i3 = 0; i3 < this.children.length; ++i3) {
            var child = this.children[i3], sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n2, sz - at), oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;
              if (sz == rm) {
                this.children.splice(i3--, 1);
                child.parent = null;
              }
              if ((n2 -= rm) == 0) {
                break;
              }
              at = 0;
            } else {
              at -= sz;
            }
          }
          if (this.size - n2 < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function(lines) {
          for (var i3 = 0; i3 < this.children.length; ++i3) {
            this.children[i3].collapse(lines);
          }
        },
        insertInner: function(at, lines, height) {
          this.size += lines.length;
          this.height += height;
          for (var i3 = 0; i3 < this.children.length; ++i3) {
            var child = this.children[i3], sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                var remaining = child.lines.length % 25 + 25;
                for (var pos = remaining; pos < child.lines.length; ) {
                  var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                  child.height -= leaf.height;
                  this.children.splice(++i3, 0, leaf);
                  leaf.parent = this;
                }
                child.lines = child.lines.slice(0, remaining);
                this.maybeSpill();
              }
              break;
            }
            at -= sz;
          }
        },
        // When a node has grown, check whether it should be split.
        maybeSpill: function() {
          if (this.children.length <= 10) {
            return;
          }
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) {
              var copy2 = new BranchChunk(me.children);
              copy2.parent = me;
              me.children = [copy2, sibling];
              me = copy2;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10);
          me.parent.maybeSpill();
        },
        iterN: function(at, n2, op) {
          for (var i3 = 0; i3 < this.children.length; ++i3) {
            var child = this.children[i3], sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n2, sz - at);
              if (child.iterN(at, used, op)) {
                return true;
              }
              if ((n2 -= used) == 0) {
                break;
              }
              at = 0;
            } else {
              at -= sz;
            }
          }
        }
      };
      var LineWidget = function(doc2, node, options) {
        if (options) {
          for (var opt in options) {
            if (options.hasOwnProperty(opt)) {
              this[opt] = options[opt];
            }
          }
        }
        this.doc = doc2;
        this.node = node;
      };
      LineWidget.prototype.clear = function() {
        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (no == null || !ws) {
          return;
        }
        for (var i3 = 0; i3 < ws.length; ++i3) {
          if (ws[i3] == this) {
            ws.splice(i3--, 1);
          }
        }
        if (!ws.length) {
          line.widgets = null;
        }
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm) {
          runInOp(cm, function() {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
          signalLater(cm, "lineWidgetCleared", cm, this, no);
        }
      };
      LineWidget.prototype.changed = function() {
        var this$1$1 = this;
        var oldH = this.height, cm = this.doc.cm, line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff) {
          return;
        }
        if (!lineIsHidden(this.doc, line)) {
          updateLineHeight(line, line.height + diff);
        }
        if (cm) {
          runInOp(cm, function() {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
            signalLater(cm, "lineWidgetChanged", cm, this$1$1, lineNo(line));
          });
        }
      };
      eventMixin(LineWidget);
      function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
          addToScrollTop(cm, diff);
        }
      }
      function addLineWidget(doc2, handle, node, options) {
        var widget = new LineWidget(doc2, node, options);
        var cm = doc2.cm;
        if (cm && widget.noHScroll) {
          cm.display.alignWidgets = true;
        }
        changeLine(doc2, handle, "widget", function(line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null) {
            widgets.push(widget);
          } else {
            widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
          }
          widget.line = line;
          if (cm && !lineIsHidden(doc2, line)) {
            var aboveVisible = heightAtLine(line) < doc2.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible) {
              addToScrollTop(cm, widget.height);
            }
            cm.curOp.forceUpdate = true;
          }
          return true;
        });
        if (cm) {
          signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
        }
        return widget;
      }
      var nextMarkerId = 0;
      var TextMarker = function(doc2, type2) {
        this.lines = [];
        this.type = type2;
        this.doc = doc2;
        this.id = ++nextMarkerId;
      };
      TextMarker.prototype.clear = function() {
        if (this.explicitlyCleared) {
          return;
        }
        var cm = this.doc.cm, withOp = cm && !cm.curOp;
        if (withOp) {
          startOperation(cm);
        }
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found) {
            signalLater(this, "clear", found.from, found.to);
          }
        }
        var min2 = null, max2 = null;
        for (var i3 = 0; i3 < this.lines.length; ++i3) {
          var line = this.lines[i3];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (cm && !this.collapsed) {
            regLineChange(cm, lineNo(line), "text");
          } else if (cm) {
            if (span.to != null) {
              max2 = lineNo(line);
            }
            if (span.from != null) {
              min2 = lineNo(line);
            }
          }
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
            updateLineHeight(line, textHeight(cm.display));
          }
        }
        if (cm && this.collapsed && !cm.options.lineWrapping) {
          for (var i$13 = 0; i$13 < this.lines.length; ++i$13) {
            var visual = visualLine(this.lines[i$13]), len = lineLength(visual);
            if (len > cm.display.maxLineLength) {
              cm.display.maxLine = visual;
              cm.display.maxLineLength = len;
              cm.display.maxLineChanged = true;
            }
          }
        }
        if (min2 != null && cm && this.collapsed) {
          regChange(cm, min2, max2 + 1);
        }
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm) {
            reCheckSelection(cm.doc);
          }
        }
        if (cm) {
          signalLater(cm, "markerCleared", cm, this, min2, max2);
        }
        if (withOp) {
          endOperation(cm);
        }
        if (this.parent) {
          this.parent.clear();
        }
      };
      TextMarker.prototype.find = function(side, lineObj) {
        if (side == null && this.type == "bookmark") {
          side = 1;
        }
        var from, to;
        for (var i3 = 0; i3 < this.lines.length; ++i3) {
          var line = this.lines[i3];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.from != null) {
            from = Pos(lineObj ? line : lineNo(line), span.from);
            if (side == -1) {
              return from;
            }
          }
          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);
            if (side == 1) {
              return to;
            }
          }
        }
        return from && { from, to };
      };
      TextMarker.prototype.changed = function() {
        var this$1$1 = this;
        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
        if (!pos || !cm) {
          return;
        }
        runInOp(cm, function() {
          var line = pos.line, lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);
          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }
          cm.curOp.updateMaxLine = true;
          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;
            if (dHeight) {
              updateLineHeight(line, line.height + dHeight);
            }
          }
          signalLater(cm, "markerChanged", cm, this$1$1);
        });
      };
      TextMarker.prototype.attachLine = function(line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
          }
        }
        this.lines.push(line);
      };
      TextMarker.prototype.detachLine = function(line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };
      eventMixin(TextMarker);
      function markText(doc2, from, to, options, type2) {
        if (options && options.shared) {
          return markTextShared(doc2, from, to, options, type2);
        }
        if (doc2.cm && !doc2.cm.curOp) {
          return operation(doc2.cm, markText)(doc2, from, to, options, type2);
        }
        var marker = new TextMarker(doc2, type2), diff = cmp(from, to);
        if (options) {
          copyObj(options, marker, false);
        }
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
          return marker;
        }
        if (marker.replacedWith) {
          marker.collapsed = true;
          marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents) {
            marker.widgetNode.setAttribute("cm-ignore-events", "true");
          }
          if (options.insertLeft) {
            marker.widgetNode.insertLeft = true;
          }
        }
        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc2, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc2, to.line, from, to, marker)) {
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          }
          seeCollapsedSpans();
        }
        if (marker.addToHistory) {
          addChangeToHistory(doc2, { from, to, origin: "markText" }, doc2.sel, NaN);
        }
        var curLine = from.line, cm = doc2.cm, updateMaxLine;
        doc2.iter(curLine, to.line + 1, function(line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
            updateMaxLine = true;
          }
          if (marker.collapsed && curLine != from.line) {
            updateLineHeight(line, 0);
          }
          addMarkedSpan(line, new MarkedSpan(
            marker,
            curLine == from.line ? from.ch : null,
            curLine == to.line ? to.ch : null
          ), doc2.cm && doc2.cm.curOp);
          ++curLine;
        });
        if (marker.collapsed) {
          doc2.iter(from.line, to.line + 1, function(line) {
            if (lineIsHidden(doc2, line)) {
              updateLineHeight(line, 0);
            }
          });
        }
        if (marker.clearOnEnter) {
          on(marker, "beforeCursorEnter", function() {
            return marker.clear();
          });
        }
        if (marker.readOnly) {
          seeReadOnlySpans();
          if (doc2.history.done.length || doc2.history.undone.length) {
            doc2.clearHistory();
          }
        }
        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }
        if (cm) {
          if (updateMaxLine) {
            cm.curOp.updateMaxLine = true;
          }
          if (marker.collapsed) {
            regChange(cm, from.line, to.line + 1);
          } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
            for (var i3 = from.line; i3 <= to.line; i3++) {
              regLineChange(cm, i3, "text");
            }
          }
          if (marker.atomic) {
            reCheckSelection(cm.doc);
          }
          signalLater(cm, "markerAdded", cm, marker);
        }
        return marker;
      }
      var SharedTextMarker = function(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i3 = 0; i3 < markers.length; ++i3) {
          markers[i3].parent = this;
        }
      };
      SharedTextMarker.prototype.clear = function() {
        if (this.explicitlyCleared) {
          return;
        }
        this.explicitlyCleared = true;
        for (var i3 = 0; i3 < this.markers.length; ++i3) {
          this.markers[i3].clear();
        }
        signalLater(this, "clear");
      };
      SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj);
      };
      eventMixin(SharedTextMarker);
      function markTextShared(doc2, from, to, options, type2) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc2, from, to, options, type2)], primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc2, function(doc3) {
          if (widget) {
            options.widgetNode = widget.cloneNode(true);
          }
          markers.push(markText(doc3, clipPos(doc3, from), clipPos(doc3, to), options, type2));
          for (var i3 = 0; i3 < doc3.linked.length; ++i3) {
            if (doc3.linked[i3].isParent) {
              return;
            }
          }
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }
      function findSharedMarkers(doc2) {
        return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m2) {
          return m2.parent;
        });
      }
      function copySharedMarkers(doc2, markers) {
        for (var i3 = 0; i3 < markers.length; i3++) {
          var marker = markers[i3], pos = marker.find();
          var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);
          if (cmp(mFrom, mTo)) {
            var subMark = markText(doc2, mFrom, mTo, marker.primary, marker.primary.type);
            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }
      function detachSharedMarkers(markers) {
        var loop = function(i4) {
          var marker = markers[i4], linked = [marker.primary.doc];
          linkedDocs(marker.primary.doc, function(d2) {
            return linked.push(d2);
          });
          for (var j2 = 0; j2 < marker.markers.length; j2++) {
            var subMarker = marker.markers[j2];
            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j2--, 1);
            }
          }
        };
        for (var i3 = 0; i3 < markers.length; i3++) loop(i3);
      }
      var nextDocId = 0;
      var Doc = function(text, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc)) {
          return new Doc(text, mode, firstLine, lineSep, direction);
        }
        if (firstLine == null) {
          firstLine = 0;
        }
        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.modeFrontier = this.highlightFrontier = firstLine;
        var start2 = Pos(firstLine, 0);
        this.sel = simpleSelection(start2);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.direction = direction == "rtl" ? "rtl" : "ltr";
        this.extend = false;
        if (typeof text == "string") {
          text = this.splitLines(text);
        }
        updateDoc(this, { from: start2, to: start2, text });
        setSelection(this, simpleSelection(start2), sel_dontScroll);
      };
      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        // Iterate over the document. Supports two forms -- with only one
        // argument, it calls that for each line in the document. With
        // three, it iterates over the range given by the first two (with
        // the second being non-inclusive).
        iter: function(from, to, op) {
          if (op) {
            this.iterN(from - this.first, to - from, op);
          } else {
            this.iterN(this.first, this.first + this.size, from);
          }
        },
        // Non-public interface for adding and removing lines.
        insert: function(at, lines) {
          var height = 0;
          for (var i3 = 0; i3 < lines.length; ++i3) {
            height += lines[i3].height;
          }
          this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n2) {
          this.removeInner(at - this.first, n2);
        },
        // From here, the methods are part of the public interface. Most
        // are also available from CodeMirror (editor) instances.
        getValue: function(lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false) {
            return lines;
          }
          return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function(code) {
          var top = Pos(this.first, 0), last = this.first + this.size - 1;
          makeChange(this, {
            from: top,
            to: Pos(last, getLine2(this, last).text.length),
            text: this.splitLines(code),
            origin: "setValue",
            full: true
          }, true);
          if (this.cm) {
            scrollToCoords(this.cm, 0, 0);
          }
          setSelection(this, simpleSelection(top), sel_dontScroll);
        }),
        replaceRange: function(code, from, to, origin) {
          from = clipPos(this, from);
          to = to ? clipPos(this, to) : from;
          replaceRange(this, code, from, to, origin);
        },
        getRange: function(from, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
          if (lineSep === false) {
            return lines;
          }
          if (lineSep === "") {
            return lines.join("");
          }
          return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function(line) {
          var l2 = this.getLineHandle(line);
          return l2 && l2.text;
        },
        getLineHandle: function(line) {
          if (isLine(this, line)) {
            return getLine2(this, line);
          }
        },
        getLineNumber: function(line) {
          return lineNo(line);
        },
        getLineHandleVisualStart: function(line) {
          if (typeof line == "number") {
            line = getLine2(this, line);
          }
          return visualLine(line);
        },
        lineCount: function() {
          return this.size;
        },
        firstLine: function() {
          return this.first;
        },
        lastLine: function() {
          return this.first + this.size - 1;
        },
        clipPos: function(pos) {
          return clipPos(this, pos);
        },
        getCursor: function(start2) {
          var range2 = this.sel.primary(), pos;
          if (start2 == null || start2 == "head") {
            pos = range2.head;
          } else if (start2 == "anchor") {
            pos = range2.anchor;
          } else if (start2 == "end" || start2 == "to" || start2 === false) {
            pos = range2.to();
          } else {
            pos = range2.from();
          }
          return pos;
        },
        listSelections: function() {
          return this.sel.ranges;
        },
        somethingSelected: function() {
          return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function(line, ch, options) {
          setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
          setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
          extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function(f2, options) {
          var heads = map2(this.sel.ranges, f2);
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
          if (!ranges.length) {
            return;
          }
          var out = [];
          for (var i3 = 0; i3 < ranges.length; i3++) {
            out[i3] = new Range(
              clipPos(this, ranges[i3].anchor),
              clipPos(this, ranges[i3].head || ranges[i3].anchor)
            );
          }
          if (primary == null) {
            primary = Math.min(ranges.length - 1, this.sel.primIndex);
          }
          setSelection(this, normalizeSelection(this.cm, out, primary), options);
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
        }),
        getSelection: function(lineSep) {
          var ranges = this.sel.ranges, lines;
          for (var i3 = 0; i3 < ranges.length; i3++) {
            var sel = getBetween(this, ranges[i3].from(), ranges[i3].to());
            lines = lines ? lines.concat(sel) : sel;
          }
          if (lineSep === false) {
            return lines;
          } else {
            return lines.join(lineSep || this.lineSeparator());
          }
        },
        getSelections: function(lineSep) {
          var parts = [], ranges = this.sel.ranges;
          for (var i3 = 0; i3 < ranges.length; i3++) {
            var sel = getBetween(this, ranges[i3].from(), ranges[i3].to());
            if (lineSep !== false) {
              sel = sel.join(lineSep || this.lineSeparator());
            }
            parts[i3] = sel;
          }
          return parts;
        },
        replaceSelection: function(code, collapse, origin) {
          var dup = [];
          for (var i3 = 0; i3 < this.sel.ranges.length; i3++) {
            dup[i3] = code;
          }
          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
          var changes = [], sel = this.sel;
          for (var i3 = 0; i3 < sel.ranges.length; i3++) {
            var range2 = sel.ranges[i3];
            changes[i3] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i3]), origin };
          }
          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
          for (var i$13 = changes.length - 1; i$13 >= 0; i$13--) {
            makeChange(this, changes[i$13]);
          }
          if (newSel) {
            setSelectionReplaceHistory(this, newSel);
          } else if (this.cm) {
            ensureCursorVisible(this.cm);
          }
        }),
        undo: docMethodOp(function() {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function() {
          makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function(val) {
          this.extend = val;
        },
        getExtending: function() {
          return this.extend;
        },
        historySize: function() {
          var hist = this.history, done = 0, undone = 0;
          for (var i3 = 0; i3 < hist.done.length; i3++) {
            if (!hist.done[i3].ranges) {
              ++done;
            }
          }
          for (var i$13 = 0; i$13 < hist.undone.length; i$13++) {
            if (!hist.undone[i$13].ranges) {
              ++undone;
            }
          }
          return { undo: done, redo: undone };
        },
        clearHistory: function() {
          var this$1$1 = this;
          this.history = new History(this.history);
          linkedDocs(this, function(doc2) {
            return doc2.history = this$1$1.history;
          }, true);
        },
        markClean: function() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(forceSplit) {
          if (forceSplit) {
            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
          }
          return this.history.generation;
        },
        isClean: function(gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function() {
          return {
            done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)
          };
        },
        setHistory: function(histData) {
          var hist = this.history = new History(this.history);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        setGutterMarker: docMethodOp(function(line, gutterID, value) {
          return changeLine(this, line, "gutter", function(line2) {
            var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers)) {
              line2.gutterMarkers = null;
            }
            return true;
          });
        }),
        clearGutter: docMethodOp(function(gutterID) {
          var this$1$1 = this;
          this.iter(function(line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              changeLine(this$1$1, line, "gutter", function() {
                line.gutterMarkers[gutterID] = null;
                if (isEmpty(line.gutterMarkers)) {
                  line.gutterMarkers = null;
                }
                return true;
              });
            }
          });
        }),
        lineInfo: function(line) {
          var n2;
          if (typeof line == "number") {
            if (!isLine(this, line)) {
              return null;
            }
            n2 = line;
            line = getLine2(this, line);
            if (!line) {
              return null;
            }
          } else {
            n2 = lineNo(line);
            if (n2 == null) {
              return null;
            }
          }
          return {
            line: n2,
            handle: line,
            text: line.text,
            gutterMarkers: line.gutterMarkers,
            textClass: line.textClass,
            bgClass: line.bgClass,
            wrapClass: line.wrapClass,
            widgets: line.widgets
          };
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            if (!line[prop2]) {
              line[prop2] = cls;
            } else if (classTest(cls).test(line[prop2])) {
              return false;
            } else {
              line[prop2] += " " + cls;
            }
            return true;
          });
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop2];
            if (!cur) {
              return false;
            } else if (cls == null) {
              line[prop2] = null;
            } else {
              var found = cur.match(classTest(cls));
              if (!found) {
                return false;
              }
              var end = found.index + found[0].length;
              line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true;
          });
        }),
        addLineWidget: docMethodOp(function(handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function(widget) {
          widget.clear();
        },
        markText: function(from, to, options) {
          return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function(pos, options) {
          var realOpts = {
            replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft,
            clearWhenEmpty: false,
            shared: options && options.shared,
            handleMouseEvents: options && options.handleMouseEvents
          };
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function(pos) {
          pos = clipPos(this, pos);
          var markers = [], spans = getLine2(this, pos.line).markedSpans;
          if (spans) {
            for (var i3 = 0; i3 < spans.length; ++i3) {
              var span = spans[i3];
              if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                markers.push(span.marker.parent || span.marker);
              }
            }
          }
          return markers;
        },
        findMarks: function(from, to, filter2) {
          from = clipPos(this, from);
          to = clipPos(this, to);
          var found = [], lineNo2 = from.line;
          this.iter(from.line, to.line + 1, function(line) {
            var spans = line.markedSpans;
            if (spans) {
              for (var i3 = 0; i3 < spans.length; i3++) {
                var span = spans[i3];
                if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter2 || filter2(span.marker))) {
                  found.push(span.marker.parent || span.marker);
                }
              }
            }
            ++lineNo2;
          });
          return found;
        },
        getAllMarks: function() {
          var markers = [];
          this.iter(function(line) {
            var sps = line.markedSpans;
            if (sps) {
              for (var i3 = 0; i3 < sps.length; ++i3) {
                if (sps[i3].from != null) {
                  markers.push(sps[i3].marker);
                }
              }
            }
          });
          return markers;
        },
        posFromIndex: function(off2) {
          var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
          this.iter(function(line) {
            var sz = line.text.length + sepSize;
            if (sz > off2) {
              ch = off2;
              return true;
            }
            off2 -= sz;
            ++lineNo2;
          });
          return clipPos(this, Pos(lineNo2, ch));
        },
        indexFromPos: function(coords) {
          coords = clipPos(this, coords);
          var index2 = coords.ch;
          if (coords.line < this.first || coords.ch < 0) {
            return 0;
          }
          var sepSize = this.lineSeparator().length;
          this.iter(this.first, coords.line, function(line) {
            index2 += line.text.length + sepSize;
          });
          return index2;
        },
        copy: function(copyHistory) {
          var doc2 = new Doc(
            getLines(this, this.first, this.first + this.size),
            this.modeOption,
            this.first,
            this.lineSep,
            this.direction
          );
          doc2.scrollTop = this.scrollTop;
          doc2.scrollLeft = this.scrollLeft;
          doc2.sel = this.sel;
          doc2.extend = false;
          if (copyHistory) {
            doc2.history.undoDepth = this.history.undoDepth;
            doc2.setHistory(this.getHistory());
          }
          return doc2;
        },
        linkedDoc: function(options) {
          if (!options) {
            options = {};
          }
          var from = this.first, to = this.first + this.size;
          if (options.from != null && options.from > from) {
            from = options.from;
          }
          if (options.to != null && options.to < to) {
            to = options.to;
          }
          var copy2 = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
          if (options.sharedHist) {
            copy2.history = this.history;
          }
          (this.linked || (this.linked = [])).push({ doc: copy2, sharedHist: options.sharedHist });
          copy2.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
          copySharedMarkers(copy2, findSharedMarkers(this));
          return copy2;
        },
        unlinkDoc: function(other) {
          if (other instanceof CodeMirror2) {
            other = other.doc;
          }
          if (this.linked) {
            for (var i3 = 0; i3 < this.linked.length; ++i3) {
              var link = this.linked[i3];
              if (link.doc != other) {
                continue;
              }
              this.linked.splice(i3, 1);
              other.unlinkDoc(this);
              detachSharedMarkers(findSharedMarkers(this));
              break;
            }
          }
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function(doc2) {
              return splitIds.push(doc2.id);
            }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function(f2) {
          linkedDocs(this, f2);
        },
        getMode: function() {
          return this.mode;
        },
        getEditor: function() {
          return this.cm;
        },
        splitLines: function(str2) {
          if (this.lineSep) {
            return str2.split(this.lineSep);
          }
          return splitLinesAuto(str2);
        },
        lineSeparator: function() {
          return this.lineSep || "\n";
        },
        setDirection: docMethodOp(function(dir) {
          if (dir != "rtl") {
            dir = "ltr";
          }
          if (dir == this.direction) {
            return;
          }
          this.direction = dir;
          this.iter(function(line) {
            return line.order = null;
          });
          if (this.cm) {
            directionChanged(this.cm);
          }
        })
      });
      Doc.prototype.eachLine = Doc.prototype.iter;
      var lastDrop = 0;
      function onDrop(e2) {
        var cm = this;
        clearDragCursor(cm);
        if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
          return;
        }
        e_preventDefault(e2);
        if (ie) {
          lastDrop = +/* @__PURE__ */ new Date();
        }
        var pos = posFromMouse(cm, e2, true), files = e2.dataTransfer.files;
        if (!pos || cm.isReadOnly()) {
          return;
        }
        if (files && files.length && window.FileReader && window.File) {
          var n2 = files.length, text = Array(n2), read = 0;
          var markAsReadAndPasteIfAllFilesAreRead = function() {
            if (++read == n2) {
              operation(cm, function() {
                pos = clipPos(cm.doc, pos);
                var change = {
                  from: pos,
                  to: pos,
                  text: cm.doc.splitLines(
                    text.filter(function(t2) {
                      return t2 != null;
                    }).join(cm.doc.lineSeparator())
                  ),
                  origin: "paste"
                };
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
              })();
            }
          };
          var readTextFromFile = function(file, i4) {
            if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }
            var reader = new FileReader();
            reader.onerror = function() {
              return markAsReadAndPasteIfAllFilesAreRead();
            };
            reader.onload = function() {
              var content = reader.result;
              if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }
              text[i4] = content;
              markAsReadAndPasteIfAllFilesAreRead();
            };
            reader.readAsText(file);
          };
          for (var i3 = 0; i3 < files.length; i3++) {
            readTextFromFile(files[i3], i3);
          }
        } else {
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e2);
            setTimeout(function() {
              return cm.display.input.focus();
            }, 20);
            return;
          }
          try {
            var text$1 = e2.dataTransfer.getData("Text");
            if (text$1) {
              var selected;
              if (cm.state.draggingText && !cm.state.draggingText.copy) {
                selected = cm.listSelections();
              }
              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
              if (selected) {
                for (var i$13 = 0; i$13 < selected.length; ++i$13) {
                  replaceRange(cm.doc, "", selected[i$13].anchor, selected[i$13].head, "drag");
                }
              }
              cm.replaceSelection(text$1, "around", "paste");
              cm.display.input.focus();
            }
          } catch (e$1) {
          }
        }
      }
      function onDragStart(cm, e2) {
        if (ie && (!cm.state.draggingText || +/* @__PURE__ */ new Date() - lastDrop < 100)) {
          e_stop(e2);
          return;
        }
        if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
          return;
        }
        e2.dataTransfer.setData("Text", cm.getSelection());
        e2.dataTransfer.effectAllowed = "copyMove";
        if (e2.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            img._top = img.offsetTop;
          }
          e2.dataTransfer.setDragImage(img, 0, 0);
          if (presto) {
            img.parentNode.removeChild(img);
          }
        }
      }
      function onDragOver(cm, e2) {
        var pos = posFromMouse(cm, e2);
        if (!pos) {
          return;
        }
        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }
      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      }
      function forEachCodeMirror(f2) {
        if (!document.getElementsByClassName) {
          return;
        }
        var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
        for (var i3 = 0; i3 < byClass.length; i3++) {
          var cm = byClass[i3].CodeMirror;
          if (cm) {
            editors.push(cm);
          }
        }
        if (editors.length) {
          editors[0].operation(function() {
            for (var i4 = 0; i4 < editors.length; i4++) {
              f2(editors[i4]);
            }
          });
        }
      }
      var globalsRegistered = false;
      function ensureGlobalHandlers() {
        if (globalsRegistered) {
          return;
        }
        registerGlobalHandlers();
        globalsRegistered = true;
      }
      function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function() {
          if (resizeTimer == null) {
            resizeTimer = setTimeout(function() {
              resizeTimer = null;
              forEachCodeMirror(onResize);
            }, 100);
          }
        });
        on(window, "blur", function() {
          return forEachCodeMirror(onBlur);
        });
      }
      function onResize(cm) {
        var d2 = cm.display;
        d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
        d2.scrollbarsClipped = false;
        cm.setSize();
      }
      var keyNames = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Mod",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      };
      for (var i2 = 0; i2 < 10; i2++) {
        keyNames[i2 + 48] = keyNames[i2 + 96] = String(i2);
      }
      for (var i$12 = 65; i$12 <= 90; i$12++) {
        keyNames[i$12] = String.fromCharCode(i$12);
      }
      for (var i$2 = 1; i$2 <= 12; i$2++) {
        keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
      }
      var keyMap = {};
      keyMap.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      };
      keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        "fallthrough": "basic"
      };
      keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        "fallthrough": ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
      function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;
        for (var i3 = 0; i3 < parts.length - 1; i3++) {
          var mod = parts[i3];
          if (/^(cmd|meta|m)$/i.test(mod)) {
            cmd = true;
          } else if (/^a(lt)?$/i.test(mod)) {
            alt = true;
          } else if (/^(c|ctrl|control)$/i.test(mod)) {
            ctrl = true;
          } else if (/^s(hift)?$/i.test(mod)) {
            shift = true;
          } else {
            throw new Error("Unrecognized modifier name: " + mod);
          }
        }
        if (alt) {
          name = "Alt-" + name;
        }
        if (ctrl) {
          name = "Ctrl-" + name;
        }
        if (cmd) {
          name = "Cmd-" + name;
        }
        if (shift) {
          name = "Shift-" + name;
        }
        return name;
      }
      function normalizeKeyMap(keymap) {
        var copy2 = {};
        for (var keyname in keymap) {
          if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];
            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
              continue;
            }
            if (value == "...") {
              delete keymap[keyname];
              continue;
            }
            var keys = map2(keyname.split(" "), normalizeKeyName);
            for (var i3 = 0; i3 < keys.length; i3++) {
              var val = void 0, name = void 0;
              if (i3 == keys.length - 1) {
                name = keys.join(" ");
                val = value;
              } else {
                name = keys.slice(0, i3 + 1).join(" ");
                val = "...";
              }
              var prev = copy2[name];
              if (!prev) {
                copy2[name] = val;
              } else if (prev != val) {
                throw new Error("Inconsistent bindings for " + name);
              }
            }
            delete keymap[keyname];
          }
        }
        for (var prop2 in copy2) {
          keymap[prop2] = copy2[prop2];
        }
        return keymap;
      }
      function lookupKey(key, map3, handle, context) {
        map3 = getKeyMap(map3);
        var found = map3.call ? map3.call(key, context) : map3[key];
        if (found === false) {
          return "nothing";
        }
        if (found === "...") {
          return "multi";
        }
        if (found != null && handle(found)) {
          return "handled";
        }
        if (map3.fallthrough) {
          if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {
            return lookupKey(key, map3.fallthrough, handle, context);
          }
          for (var i3 = 0; i3 < map3.fallthrough.length; i3++) {
            var result = lookupKey(key, map3.fallthrough[i3], handle, context);
            if (result) {
              return result;
            }
          }
        }
      }
      function isModifierKey(value) {
        var name = typeof value == "string" ? value : keyNames[value.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
      }
      function addModifierNames(name, event, noShift) {
        var base = name;
        if (event.altKey && base != "Alt") {
          name = "Alt-" + name;
        }
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
          name = "Ctrl-" + name;
        }
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
          name = "Cmd-" + name;
        }
        if (!noShift && event.shiftKey && base != "Shift") {
          name = "Shift-" + name;
        }
        return name;
      }
      function keyName(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"]) {
          return false;
        }
        var name = keyNames[event.keyCode];
        if (name == null || event.altGraphKey) {
          return false;
        }
        if (event.keyCode == 3 && event.code) {
          name = event.code;
        }
        return addModifierNames(name, event, noShift);
      }
      function getKeyMap(val) {
        return typeof val == "string" ? keyMap[val] : val;
      }
      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges, kill = [];
        for (var i3 = 0; i3 < ranges.length; i3++) {
          var toKill = compute(ranges[i3]);
          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();
            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break;
            }
          }
          kill.push(toKill);
        }
        runInOp(cm, function() {
          for (var i4 = kill.length - 1; i4 >= 0; i4--) {
            replaceRange(cm.doc, "", kill[i4].from, kill[i4].to, "+delete");
          }
          ensureCursorVisible(cm);
        });
      }
      function moveCharLogically(line, ch, dir) {
        var target = skipExtendingChars(line.text, ch + dir, dir);
        return target < 0 || target > line.text.length ? null : target;
      }
      function moveLogically(line, start2, dir) {
        var ch = moveCharLogically(line, start2.ch, dir);
        return ch == null ? null : new Pos(start2.line, ch, dir < 0 ? "after" : "before");
      }
      function endOfLine(visually, cm, lineObj, lineNo2, dir) {
        if (visually) {
          if (cm.doc.direction == "rtl") {
            dir = -dir;
          }
          var order = getOrder(lineObj, cm.doc.direction);
          if (order) {
            var part = dir < 0 ? lst(order) : order[0];
            var moveInStorageOrder = dir < 0 == (part.level == 1);
            var sticky = moveInStorageOrder ? "after" : "before";
            var ch;
            if (part.level > 0 || cm.doc.direction == "rtl") {
              var prep = prepareMeasureForLine(cm, lineObj);
              ch = dir < 0 ? lineObj.text.length - 1 : 0;
              var targetTop = measureCharPrepared(cm, prep, ch).top;
              ch = findFirst(function(ch2) {
                return measureCharPrepared(cm, prep, ch2).top == targetTop;
              }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
              if (sticky == "before") {
                ch = moveCharLogically(lineObj, ch, 1);
              }
            } else {
              ch = dir < 0 ? part.to : part.from;
            }
            return new Pos(lineNo2, ch, sticky);
          }
        }
        return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
      }
      function moveVisually(cm, line, start2, dir) {
        var bidi = getOrder(line, cm.doc.direction);
        if (!bidi) {
          return moveLogically(line, start2, dir);
        }
        if (start2.ch >= line.text.length) {
          start2.ch = line.text.length;
          start2.sticky = "before";
        } else if (start2.ch <= 0) {
          start2.ch = 0;
          start2.sticky = "after";
        }
        var partPos = getBidiPartAt(bidi, start2.ch, start2.sticky), part = bidi[partPos];
        if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start2.ch : part.from < start2.ch)) {
          return moveLogically(line, start2, dir);
        }
        var mv = function(pos, dir2) {
          return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
        };
        var prep;
        var getWrappedLineExtent = function(ch2) {
          if (!cm.options.lineWrapping) {
            return { begin: 0, end: line.text.length };
          }
          prep = prep || prepareMeasureForLine(cm, line);
          return wrappedLineExtentChar(cm, line, prep, ch2);
        };
        var wrappedLineExtent2 = getWrappedLineExtent(start2.sticky == "before" ? mv(start2, -1) : start2.ch);
        if (cm.doc.direction == "rtl" || part.level == 1) {
          var moveInStorageOrder = part.level == 1 == dir < 0;
          var ch = mv(start2, moveInStorageOrder ? 1 : -1);
          if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
            var sticky = moveInStorageOrder ? "before" : "after";
            return new Pos(start2.line, ch, sticky);
          }
        }
        var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
          var getRes = function(ch3, moveInStorageOrder3) {
            return moveInStorageOrder3 ? new Pos(start2.line, mv(ch3, 1), "before") : new Pos(start2.line, ch3, "after");
          };
          for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
            var part2 = bidi[partPos2];
            var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
            var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
            if (part2.from <= ch2 && ch2 < part2.to) {
              return getRes(ch2, moveInStorageOrder2);
            }
            ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
            if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
              return getRes(ch2, moveInStorageOrder2);
            }
          }
        };
        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
        if (res) {
          return res;
        }
        var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
          res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
          if (res) {
            return res;
          }
        }
        return null;
      }
      var commands = {
        selectAll,
        singleSelection: function(cm) {
          return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            if (range2.empty()) {
              var len = getLine2(cm.doc, range2.head.line).text.length;
              if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
                return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
              } else {
                return { from: range2.head, to: Pos(range2.head.line, len) };
              }
            } else {
              return { from: range2.from(), to: range2.to() };
            }
          });
        },
        deleteLine: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            return {
              from: Pos(range2.from().line, 0),
              to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            return {
              from: Pos(range2.from().line, 0),
              to: range2.from()
            };
          });
        },
        delWrappedLineLeft: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            var top = cm.charCoords(range2.head, "div").top + 5;
            var leftPos = cm.coordsChar({ left: 0, top }, "div");
            return { from: leftPos, to: range2.from() };
          });
        },
        delWrappedLineRight: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            var top = cm.charCoords(range2.head, "div").top + 5;
            var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
            return { from: range2.from(), to: rightPos };
          });
        },
        undo: function(cm) {
          return cm.undo();
        },
        redo: function(cm) {
          return cm.redo();
        },
        undoSelection: function(cm) {
          return cm.undoSelection();
        },
        redoSelection: function(cm) {
          return cm.redoSelection();
        },
        goDocStart: function(cm) {
          return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function(cm) {
          return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function(cm) {
          return cm.extendSelectionsBy(
            function(range2) {
              return lineStart(cm, range2.head.line);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineStartSmart: function(cm) {
          return cm.extendSelectionsBy(
            function(range2) {
              return lineStartSmart(cm, range2.head);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineEnd: function(cm) {
          return cm.extendSelectionsBy(
            function(range2) {
              return lineEnd(cm, range2.head.line);
            },
            { origin: "+move", bias: -1 }
          );
        },
        goLineRight: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
          }, sel_move);
        },
        goLineLeft: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            return cm.coordsChar({ left: 0, top }, "div");
          }, sel_move);
        },
        goLineLeftSmart: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            var pos = cm.coordsChar({ left: 0, top }, "div");
            if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
              return lineStartSmart(cm, range2.head);
            }
            return pos;
          }, sel_move);
        },
        goLineUp: function(cm) {
          return cm.moveV(-1, "line");
        },
        goLineDown: function(cm) {
          return cm.moveV(1, "line");
        },
        goPageUp: function(cm) {
          return cm.moveV(-1, "page");
        },
        goPageDown: function(cm) {
          return cm.moveV(1, "page");
        },
        goCharLeft: function(cm) {
          return cm.moveH(-1, "char");
        },
        goCharRight: function(cm) {
          return cm.moveH(1, "char");
        },
        goColumnLeft: function(cm) {
          return cm.moveH(-1, "column");
        },
        goColumnRight: function(cm) {
          return cm.moveH(1, "column");
        },
        goWordLeft: function(cm) {
          return cm.moveH(-1, "word");
        },
        goGroupRight: function(cm) {
          return cm.moveH(1, "group");
        },
        goGroupLeft: function(cm) {
          return cm.moveH(-1, "group");
        },
        goWordRight: function(cm) {
          return cm.moveH(1, "word");
        },
        delCharBefore: function(cm) {
          return cm.deleteH(-1, "codepoint");
        },
        delCharAfter: function(cm) {
          return cm.deleteH(1, "char");
        },
        delWordBefore: function(cm) {
          return cm.deleteH(-1, "word");
        },
        delWordAfter: function(cm) {
          return cm.deleteH(1, "word");
        },
        delGroupBefore: function(cm) {
          return cm.deleteH(-1, "group");
        },
        delGroupAfter: function(cm) {
          return cm.deleteH(1, "group");
        },
        indentAuto: function(cm) {
          return cm.indentSelection("smart");
        },
        indentMore: function(cm) {
          return cm.indentSelection("add");
        },
        indentLess: function(cm) {
          return cm.indentSelection("subtract");
        },
        insertTab: function(cm) {
          return cm.replaceSelection("	");
        },
        insertSoftTab: function(cm) {
          var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
          for (var i3 = 0; i3 < ranges.length; i3++) {
            var pos = ranges[i3].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(spaceStr(tabSize - col % tabSize));
          }
          cm.replaceSelections(spaces);
        },
        defaultTab: function(cm) {
          if (cm.somethingSelected()) {
            cm.indentSelection("add");
          } else {
            cm.execCommand("insertTab");
          }
        },
        // Swap the two chars left and right of each selection's head.
        // Move cursor behind the two swapped characters afterwards.
        //
        // Doesn't consider line feeds a character.
        // Doesn't scan more than one line above to find a character.
        // Doesn't do anything on an empty line.
        // Doesn't do anything with non-empty selections.
        transposeChars: function(cm) {
          return runInOp(cm, function() {
            var ranges = cm.listSelections(), newSel = [];
            for (var i3 = 0; i3 < ranges.length; i3++) {
              if (!ranges[i3].empty()) {
                continue;
              }
              var cur = ranges[i3].head, line = getLine2(cm.doc, cur.line).text;
              if (line) {
                if (cur.ch == line.length) {
                  cur = new Pos(cur.line, cur.ch - 1);
                }
                if (cur.ch > 0) {
                  cur = new Pos(cur.line, cur.ch + 1);
                  cm.replaceRange(
                    line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                    Pos(cur.line, cur.ch - 2),
                    cur,
                    "+transpose"
                  );
                } else if (cur.line > cm.doc.first) {
                  var prev = getLine2(cm.doc, cur.line - 1).text;
                  if (prev) {
                    cur = new Pos(cur.line, 1);
                    cm.replaceRange(
                      line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1),
                      Pos(cur.line - 1, prev.length - 1),
                      cur,
                      "+transpose"
                    );
                  }
                }
              }
              newSel.push(new Range(cur, cur));
            }
            cm.setSelections(newSel);
          });
        },
        newlineAndIndent: function(cm) {
          return runInOp(cm, function() {
            var sels = cm.listSelections();
            for (var i3 = sels.length - 1; i3 >= 0; i3--) {
              cm.replaceRange(cm.doc.lineSeparator(), sels[i3].anchor, sels[i3].head, "+input");
            }
            sels = cm.listSelections();
            for (var i$13 = 0; i$13 < sels.length; i$13++) {
              cm.indentLine(sels[i$13].from().line, null, true);
            }
            ensureCursorVisible(cm);
          });
        },
        openLine: function(cm) {
          return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function(cm) {
          return cm.toggleOverwrite();
        }
      };
      function lineStart(cm, lineN) {
        var line = getLine2(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line) {
          lineN = lineNo(visual);
        }
        return endOfLine(true, cm, visual, lineN, 1);
      }
      function lineEnd(cm, lineN) {
        var line = getLine2(cm.doc, lineN);
        var visual = visualLineEnd(line);
        if (visual != line) {
          lineN = lineNo(visual);
        }
        return endOfLine(true, cm, line, lineN, -1);
      }
      function lineStartSmart(cm, pos) {
        var start2 = lineStart(cm, pos.line);
        var line = getLine2(cm.doc, start2.line);
        var order = getOrder(line, cm.doc.direction);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(start2.ch, line.text.search(/\S/));
          var inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start2.line, inWS ? 0 : firstNonWS, start2.sticky);
        }
        return start2;
      }
      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound) {
            return false;
          }
        }
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift, done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          if (dropShift) {
            cm.display.shift = false;
          }
          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done;
      }
      function lookupKeyForEditor(cm, name, handle) {
        for (var i3 = 0; i3 < cm.state.keyMaps.length; i3++) {
          var result = lookupKey(name, cm.state.keyMaps[i3], handle, cm);
          if (result) {
            return result;
          }
        }
        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
      }
      var stopSeq = new Delayed();
      function dispatchKey(cm, name, e2, handle) {
        var seq2 = cm.state.keySeq;
        if (seq2) {
          if (isModifierKey(name)) {
            return "handled";
          }
          if (/\'$/.test(name)) {
            cm.state.keySeq = null;
          } else {
            stopSeq.set(50, function() {
              if (cm.state.keySeq == seq2) {
                cm.state.keySeq = null;
                cm.display.input.reset();
              }
            });
          }
          if (dispatchKeyInner(cm, seq2 + " " + name, e2, handle)) {
            return true;
          }
        }
        return dispatchKeyInner(cm, name, e2, handle);
      }
      function dispatchKeyInner(cm, name, e2, handle) {
        var result = lookupKeyForEditor(cm, name, handle);
        if (result == "multi") {
          cm.state.keySeq = name;
        }
        if (result == "handled") {
          signalLater(cm, "keyHandled", cm, name, e2);
        }
        if (result == "handled" || result == "multi") {
          e_preventDefault(e2);
          restartBlink(cm);
        }
        return !!result;
      }
      function handleKeyBinding(cm, e2) {
        var name = keyName(e2, true);
        if (!name) {
          return false;
        }
        if (e2.shiftKey && !cm.state.keySeq) {
          return dispatchKey(cm, "Shift-" + name, e2, function(b) {
            return doHandleBinding(cm, b, true);
          }) || dispatchKey(cm, name, e2, function(b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
              return doHandleBinding(cm, b);
            }
          });
        } else {
          return dispatchKey(cm, name, e2, function(b) {
            return doHandleBinding(cm, b);
          });
        }
      }
      function handleCharBinding(cm, e2, ch) {
        return dispatchKey(cm, "'" + ch + "'", e2, function(b) {
          return doHandleBinding(cm, b, true);
        });
      }
      var lastStoppedKey = null;
      function onKeyDown(e2) {
        var cm = this;
        if (e2.target && e2.target != cm.display.input.getField()) {
          return;
        }
        cm.curOp.focus = activeElt(root2(cm));
        if (signalDOMEvent(cm, e2)) {
          return;
        }
        if (ie && ie_version < 11 && e2.keyCode == 27) {
          e2.returnValue = false;
        }
        var code = e2.keyCode;
        cm.display.shift = code == 16 || e2.shiftKey;
        var handled = handleKeyBinding(cm, e2);
        if (presto) {
          lastStoppedKey = handled ? code : null;
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e2.metaKey : e2.ctrlKey)) {
            cm.replaceSelection("", null, "cut");
          }
        }
        if (gecko && !mac && !handled && code == 46 && e2.shiftKey && !e2.ctrlKey && document.execCommand) {
          document.execCommand("cut");
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
          showCrossHair(cm);
        }
      }
      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");
        function up(e2) {
          if (e2.keyCode == 18 || !e2.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }
        on(document, "keyup", up);
        on(document, "mouseover", up);
      }
      function onKeyUp(e2) {
        if (e2.keyCode == 16) {
          this.doc.sel.shift = false;
        }
        signalDOMEvent(this, e2);
      }
      function onKeyPress(e2) {
        var cm = this;
        if (e2.target && e2.target != cm.display.input.getField()) {
          return;
        }
        if (eventInWidget(cm.display, e2) || signalDOMEvent(cm, e2) || e2.ctrlKey && !e2.altKey || mac && e2.metaKey) {
          return;
        }
        var keyCode = e2.keyCode, charCode = e2.charCode;
        if (presto && keyCode == lastStoppedKey) {
          lastStoppedKey = null;
          e_preventDefault(e2);
          return;
        }
        if (presto && (!e2.which || e2.which < 10) && handleKeyBinding(cm, e2)) {
          return;
        }
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (ch == "\b") {
          return;
        }
        if (handleCharBinding(cm, e2, ch)) {
          return;
        }
        cm.display.input.onKeyPress(e2);
      }
      var DOUBLECLICK_DELAY = 400;
      var PastClick = function(time, pos, button) {
        this.time = time;
        this.pos = pos;
        this.button = button;
      };
      PastClick.prototype.compare = function(time, pos, button) {
        return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
      };
      var lastClick, lastDoubleClick;
      function clickRepeat(pos, button) {
        var now2 = +/* @__PURE__ */ new Date();
        if (lastDoubleClick && lastDoubleClick.compare(now2, pos, button)) {
          lastClick = lastDoubleClick = null;
          return "triple";
        } else if (lastClick && lastClick.compare(now2, pos, button)) {
          lastDoubleClick = new PastClick(now2, pos, button);
          lastClick = null;
          return "double";
        } else {
          lastClick = new PastClick(now2, pos, button);
          lastDoubleClick = null;
          return "single";
        }
      }
      function onMouseDown(e2) {
        var cm = this, display = cm.display;
        if (signalDOMEvent(cm, e2) || display.activeTouch && display.input.supportsTouch()) {
          return;
        }
        display.input.ensurePolled();
        display.shift = e2.shiftKey;
        if (eventInWidget(display, e2)) {
          if (!webkit) {
            display.scroller.draggable = false;
            setTimeout(function() {
              return display.scroller.draggable = true;
            }, 100);
          }
          return;
        }
        if (clickInGutter(cm, e2)) {
          return;
        }
        var pos = posFromMouse(cm, e2), button = e_button(e2), repeat2 = pos ? clickRepeat(pos, button) : "single";
        win(cm).focus();
        if (button == 1 && cm.state.selectingText) {
          cm.state.selectingText(e2);
        }
        if (pos && handleMappedButton(cm, button, pos, repeat2, e2)) {
          return;
        }
        if (button == 1) {
          if (pos) {
            leftButtonDown(cm, pos, repeat2, e2);
          } else if (e_target(e2) == display.scroller) {
            e_preventDefault(e2);
          }
        } else if (button == 2) {
          if (pos) {
            extendSelection(cm.doc, pos);
          }
          setTimeout(function() {
            return display.input.focus();
          }, 20);
        } else if (button == 3) {
          if (captureRightClick) {
            cm.display.input.onContextMenu(e2);
          } else {
            delayBlurEvent(cm);
          }
        }
      }
      function handleMappedButton(cm, button, pos, repeat2, event) {
        var name = "Click";
        if (repeat2 == "double") {
          name = "Double" + name;
        } else if (repeat2 == "triple") {
          name = "Triple" + name;
        }
        name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
        return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
          if (typeof bound == "string") {
            bound = commands[bound];
          }
          if (!bound) {
            return false;
          }
          var done = false;
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }
            done = bound(cm, pos) != Pass;
          } finally {
            cm.state.suppressEdits = false;
          }
          return done;
        });
      }
      function configureMouse(cm, repeat2, event) {
        var option = cm.getOption("configureMouse");
        var value = option ? option(cm, repeat2, event) : {};
        if (value.unit == null) {
          var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
          value.unit = rect ? "rectangle" : repeat2 == "single" ? "char" : repeat2 == "double" ? "word" : "line";
        }
        if (value.extend == null || cm.doc.extend) {
          value.extend = cm.doc.extend || event.shiftKey;
        }
        if (value.addNew == null) {
          value.addNew = mac ? event.metaKey : event.ctrlKey;
        }
        if (value.moveOnDrag == null) {
          value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
        }
        return value;
      }
      function leftButtonDown(cm, pos, repeat2, event) {
        if (ie) {
          setTimeout(bind(ensureFocus, cm), 0);
        } else {
          cm.curOp.focus = activeElt(root2(cm));
        }
        var behavior = configureMouse(cm, repeat2, event);
        var sel = cm.doc.sel, contained;
        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat2 == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
          leftButtonStartDrag(cm, event, pos, behavior);
        } else {
          leftButtonSelect(cm, event, pos, behavior);
        }
      }
      function leftButtonStartDrag(cm, event, pos, behavior) {
        var display = cm.display, moved = false;
        var dragEnd = operation(cm, function(e2) {
          if (webkit) {
            display.scroller.draggable = false;
          }
          cm.state.draggingText = false;
          if (cm.state.delayingBlurEvent) {
            if (cm.hasFocus()) {
              cm.state.delayingBlurEvent = false;
            } else {
              delayBlurEvent(cm);
            }
          }
          off(display.wrapper.ownerDocument, "mouseup", dragEnd);
          off(display.wrapper.ownerDocument, "mousemove", mouseMove);
          off(display.scroller, "dragstart", dragStart);
          off(display.scroller, "drop", dragEnd);
          if (!moved) {
            e_preventDefault(e2);
            if (!behavior.addNew) {
              extendSelection(cm.doc, pos, null, null, behavior.extend);
            }
            if (webkit && !safari || ie && ie_version == 9) {
              setTimeout(function() {
                display.wrapper.ownerDocument.body.focus({ preventScroll: true });
                display.input.focus();
              }, 20);
            } else {
              display.input.focus();
            }
          }
        });
        var mouseMove = function(e2) {
          moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
        };
        var dragStart = function() {
          return moved = true;
        };
        if (webkit) {
          display.scroller.draggable = true;
        }
        cm.state.draggingText = dragEnd;
        dragEnd.copy = !behavior.moveOnDrag;
        on(display.wrapper.ownerDocument, "mouseup", dragEnd);
        on(display.wrapper.ownerDocument, "mousemove", mouseMove);
        on(display.scroller, "dragstart", dragStart);
        on(display.scroller, "drop", dragEnd);
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
          return display.input.focus();
        }, 20);
        if (display.scroller.dragDrop) {
          display.scroller.dragDrop();
        }
      }
      function rangeForUnit(cm, pos, unit) {
        if (unit == "char") {
          return new Range(pos, pos);
        }
        if (unit == "word") {
          return cm.findWordAt(pos);
        }
        if (unit == "line") {
          return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        }
        var result = unit(cm, pos);
        return new Range(result.from, result.to);
      }
      function leftButtonSelect(cm, event, start2, behavior) {
        if (ie) {
          delayBlurEvent(cm);
        }
        var display = cm.display, doc2 = cm.doc;
        e_preventDefault(event);
        var ourRange, ourIndex, startSel = doc2.sel, ranges = startSel.ranges;
        if (behavior.addNew && !behavior.extend) {
          ourIndex = doc2.sel.contains(start2);
          if (ourIndex > -1) {
            ourRange = ranges[ourIndex];
          } else {
            ourRange = new Range(start2, start2);
          }
        } else {
          ourRange = doc2.sel.primary();
          ourIndex = doc2.sel.primIndex;
        }
        if (behavior.unit == "rectangle") {
          if (!behavior.addNew) {
            ourRange = new Range(start2, start2);
          }
          start2 = posFromMouse(cm, event, true, true);
          ourIndex = -1;
        } else {
          var range2 = rangeForUnit(cm, start2, behavior.unit);
          if (behavior.extend) {
            ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
          } else {
            ourRange = range2;
          }
        }
        if (!behavior.addNew) {
          ourIndex = 0;
          setSelection(doc2, new Selection2([ourRange], 0), sel_mouse);
          startSel = doc2.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(
            doc2,
            normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
            { scroll: false, origin: "*mouse" }
          );
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
          setSelection(
            doc2,
            normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
            { scroll: false, origin: "*mouse" }
          );
          startSel = doc2.sel;
        } else {
          replaceOneSelection(doc2, ourIndex, ourRange, sel_mouse);
        }
        var lastPos = start2;
        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0) {
            return;
          }
          lastPos = pos;
          if (behavior.unit == "rectangle") {
            var ranges2 = [], tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine2(doc2, start2.line).text, start2.ch, tabSize);
            var posCol = countColumn(getLine2(doc2, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
            for (var line = Math.min(start2.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line <= end; line++) {
              var text = getLine2(doc2, line).text, leftPos = findColumn(text, left, tabSize);
              if (left == right) {
                ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
              } else if (text.length > leftPos) {
                ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
              }
            }
            if (!ranges2.length) {
              ranges2.push(new Range(start2, start2));
            }
            setSelection(
              doc2,
              normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex),
              { origin: "*mouse", scroll: false }
            );
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var range3 = rangeForUnit(cm, pos, behavior.unit);
            var anchor = oldRange.anchor, head;
            if (cmp(range3.anchor, anchor) > 0) {
              head = range3.head;
              anchor = minPos(oldRange.from(), range3.anchor);
            } else {
              head = range3.anchor;
              anchor = maxPos(oldRange.to(), range3.head);
            }
            var ranges$1 = startSel.ranges.slice(0);
            ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc2, anchor), head));
            setSelection(doc2, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
          }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend2(e2) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e2, true, behavior.unit == "rectangle");
          if (!cur) {
            return;
          }
          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt(root2(cm));
            extendTo(cur);
            var visible = visibleLines(display, doc2);
            if (cur.line >= visible.to || cur.line < visible.from) {
              setTimeout(operation(cm, function() {
                if (counter == curCount) {
                  extend2(e2);
                }
              }), 150);
            }
          } else {
            var outside = e2.clientY < editorSize.top ? -20 : e2.clientY > editorSize.bottom ? 20 : 0;
            if (outside) {
              setTimeout(operation(cm, function() {
                if (counter != curCount) {
                  return;
                }
                display.scroller.scrollTop += outside;
                extend2(e2);
              }), 50);
            }
          }
        }
        function done(e2) {
          cm.state.selectingText = false;
          counter = Infinity;
          if (e2) {
            e_preventDefault(e2);
            display.input.focus();
          }
          off(display.wrapper.ownerDocument, "mousemove", move);
          off(display.wrapper.ownerDocument, "mouseup", up);
          doc2.history.lastSelOrigin = null;
        }
        var move = operation(cm, function(e2) {
          if (e2.buttons === 0 || !e_button(e2)) {
            done(e2);
          } else {
            extend2(e2);
          }
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(display.wrapper.ownerDocument, "mousemove", move);
        on(display.wrapper.ownerDocument, "mouseup", up);
      }
      function bidiSimplify(cm, range2) {
        var anchor = range2.anchor;
        var head = range2.head;
        var anchorLine = getLine2(cm.doc, anchor.line);
        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
          return range2;
        }
        var order = getOrder(anchorLine);
        if (!order) {
          return range2;
        }
        var index2 = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index2];
        if (part.from != anchor.ch && part.to != anchor.ch) {
          return range2;
        }
        var boundary = index2 + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
        if (boundary == 0 || boundary == order.length) {
          return range2;
        }
        var leftSide;
        if (head.line != anchor.line) {
          leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
        } else {
          var headIndex = getBidiPartAt(order, head.ch, head.sticky);
          var dir = headIndex - index2 || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
          if (headIndex == boundary - 1 || headIndex == boundary) {
            leftSide = dir < 0;
          } else {
            leftSide = dir > 0;
          }
        }
        var usePart = order[boundary + (leftSide ? -1 : 0)];
        var from = leftSide == (usePart.level == 1);
        var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
        return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
      }
      function gutterEvent(cm, e2, type2, prevent) {
        var mX, mY;
        if (e2.touches) {
          mX = e2.touches[0].clientX;
          mY = e2.touches[0].clientY;
        } else {
          try {
            mX = e2.clientX;
            mY = e2.clientY;
          } catch (e$1) {
            return false;
          }
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
          return false;
        }
        if (prevent) {
          e_preventDefault(e2);
        }
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type2)) {
          return e_defaultPrevented(e2);
        }
        mY -= lineBox.top - display.viewOffset;
        for (var i3 = 0; i3 < cm.display.gutterSpecs.length; ++i3) {
          var g2 = display.gutters.childNodes[i3];
          if (g2 && g2.getBoundingClientRect().right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.display.gutterSpecs[i3];
            signal(cm, type2, cm, line, gutter.className, e2);
            return e_defaultPrevented(e2);
          }
        }
      }
      function clickInGutter(cm, e2) {
        return gutterEvent(cm, e2, "gutterClick", true);
      }
      function onContextMenu(cm, e2) {
        if (eventInWidget(cm.display, e2) || contextMenuInGutter(cm, e2)) {
          return;
        }
        if (signalDOMEvent(cm, e2, "contextmenu")) {
          return;
        }
        if (!captureRightClick) {
          cm.display.input.onContextMenu(e2);
        }
      }
      function contextMenuInGutter(cm, e2) {
        if (!hasHandler(cm, "gutterContextMenu")) {
          return false;
        }
        return gutterEvent(cm, e2, "gutterContextMenu", false);
      }
      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }
      var Init = { toString: function() {
        return "CodeMirror.Init";
      } };
      var defaults = {};
      var optionHandlers = {};
      function defineOptions(CodeMirror3) {
        var optionHandlers2 = CodeMirror3.optionHandlers;
        function option(name, deflt, handle, notOnInit) {
          CodeMirror3.defaults[name] = deflt;
          if (handle) {
            optionHandlers2[name] = notOnInit ? function(cm, val, old) {
              if (old != Init) {
                handle(cm, val, old);
              }
            } : handle;
          }
        }
        CodeMirror3.defineOption = option;
        CodeMirror3.Init = Init;
        option("value", "", function(cm, val) {
          return cm.setValue(val);
        }, true);
        option("mode", null, function(cm, val) {
          cm.doc.modeOption = val;
          loadMode(cm);
        }, true);
        option("indentUnit", 2, loadMode, true);
        option("indentWithTabs", false);
        option("smartIndent", true);
        option("tabSize", 4, function(cm) {
          resetModeState(cm);
          clearCaches(cm);
          regChange(cm);
        }, true);
        option("lineSeparator", null, function(cm, val) {
          cm.doc.lineSep = val;
          if (!val) {
            return;
          }
          var newBreaks = [], lineNo2 = cm.doc.first;
          cm.doc.iter(function(line) {
            for (var pos = 0; ; ) {
              var found = line.text.indexOf(val, pos);
              if (found == -1) {
                break;
              }
              pos = found + val.length;
              newBreaks.push(Pos(lineNo2, found));
            }
            lineNo2++;
          });
          for (var i3 = newBreaks.length - 1; i3 >= 0; i3--) {
            replaceRange(cm.doc, val, newBreaks[i3], Pos(newBreaks[i3].line, newBreaks[i3].ch + val.length));
          }
        });
        option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
          cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
          if (old != Init) {
            cm.refresh();
          }
        });
        option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
          return cm.refresh();
        }, true);
        option("electricChars", true);
        option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
          throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, true);
        option("spellcheck", false, function(cm, val) {
          return cm.getInputField().spellcheck = val;
        }, true);
        option("autocorrect", false, function(cm, val) {
          return cm.getInputField().autocorrect = val;
        }, true);
        option("autocapitalize", false, function(cm, val) {
          return cm.getInputField().autocapitalize = val;
        }, true);
        option("rtlMoveVisually", !windows);
        option("wholeLineUpdateBefore", true);
        option("theme", "default", function(cm) {
          themeChanged(cm);
          updateGutters(cm);
        }, true);
        option("keyMap", "default", function(cm, val, old) {
          var next = getKeyMap(val);
          var prev = old != Init && getKeyMap(old);
          if (prev && prev.detach) {
            prev.detach(cm, next);
          }
          if (next.attach) {
            next.attach(cm, prev || null);
          }
        });
        option("extraKeys", null);
        option("configureMouse", null);
        option("lineWrapping", false, wrappingChanged, true);
        option("gutters", [], function(cm, val) {
          cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
          updateGutters(cm);
        }, true);
        option("fixedGutter", true, function(cm, val) {
          cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
          cm.refresh();
        }, true);
        option("coverGutterNextToScrollbar", false, function(cm) {
          return updateScrollbars(cm);
        }, true);
        option("scrollbarStyle", "native", function(cm) {
          initScrollbars(cm);
          updateScrollbars(cm);
          cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
          cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option("lineNumbers", false, function(cm, val) {
          cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
          updateGutters(cm);
        }, true);
        option("firstLineNumber", 1, updateGutters, true);
        option("lineNumberFormatter", function(integer) {
          return integer;
        }, updateGutters, true);
        option("showCursorWhenSelecting", false, updateSelection, true);
        option("resetSelectionOnContextMenu", true);
        option("lineWiseCopyCut", true);
        option("pasteLinesPerSelection", true);
        option("selectionsMayTouch", false);
        option("readOnly", false, function(cm, val) {
          if (val == "nocursor") {
            onBlur(cm);
            cm.display.input.blur();
          }
          cm.display.input.readOnlyChanged(val);
        });
        option("screenReaderLabel", null, function(cm, val) {
          val = val === "" ? null : val;
          cm.display.input.screenReaderLabelChanged(val);
        });
        option("disableInput", false, function(cm, val) {
          if (!val) {
            cm.display.input.reset();
          }
        }, true);
        option("dragDrop", true, dragDropChanged);
        option("allowDropFileTypes", null);
        option("cursorBlinkRate", 530);
        option("cursorScrollMargin", 0);
        option("cursorHeight", 1, updateSelection, true);
        option("singleCursorHeightPerLine", true, updateSelection, true);
        option("workTime", 100);
        option("workDelay", 100);
        option("flattenSpans", true, resetModeState, true);
        option("addModeClass", false, resetModeState, true);
        option("pollInterval", 100);
        option("undoDepth", 200, function(cm, val) {
          return cm.doc.history.undoDepth = val;
        });
        option("historyEventDelay", 1250);
        option("viewportMargin", 10, function(cm) {
          return cm.refresh();
        }, true);
        option("maxHighlightLength", 1e4, resetModeState, true);
        option("moveInputWithCursor", true, function(cm, val) {
          if (!val) {
            cm.display.input.resetPosition();
          }
        });
        option("tabindex", null, function(cm, val) {
          return cm.display.input.getField().tabIndex = val || "";
        });
        option("autofocus", null);
        option("direction", "ltr", function(cm, val) {
          return cm.doc.setDirection(val);
        }, true);
        option("phrases", null);
      }
      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != Init;
        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }
      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function() {
          return updateScrollbars(cm);
        }, 100);
      }
      function CodeMirror2(place, options) {
        var this$1$1 = this;
        if (!(this instanceof CodeMirror2)) {
          return new CodeMirror2(place, options);
        }
        this.options = options = options ? copyObj(options) : {};
        copyObj(defaults, options, false);
        var doc2 = options.value;
        if (typeof doc2 == "string") {
          doc2 = new Doc(doc2, options.mode, null, options.lineSeparator, options.direction);
        } else if (options.mode) {
          doc2.modeOption = options.mode;
        }
        this.doc = doc2;
        var input = new CodeMirror2.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc2, input, options);
        display.wrapper.CodeMirror = this;
        themeChanged(this);
        if (options.lineWrapping) {
          this.display.wrapper.className += " CodeMirror-wrap";
        }
        initScrollbars(this);
        this.state = {
          keyMaps: [],
          // stores maps added by addKeyMap
          overlays: [],
          // highlighting overlays, as added by addOverlay
          modeGen: 0,
          // bumped when mode/overlay changes, used to invalidate highlighting info
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          // used to disable editing during key handlers when in readOnly mode
          pasteIncoming: -1,
          cutIncoming: -1,
          // help recognize paste/cut edits in input.poll
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(),
          // stores highlight worker timeout
          keySeq: null,
          // Unfinished key sequence
          specialChars: null
        };
        if (options.autofocus && !mobile) {
          display.input.focus();
        }
        if (ie && ie_version < 11) {
          setTimeout(function() {
            return this$1$1.display.input.reset(true);
          }, 20);
        }
        registerEventHandlers(this);
        ensureGlobalHandlers();
        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc2);
        if (options.autofocus && !mobile || this.hasFocus()) {
          setTimeout(function() {
            if (this$1$1.hasFocus() && !this$1$1.state.focused) {
              onFocus(this$1$1);
            }
          }, 20);
        } else {
          onBlur(this);
        }
        for (var opt in optionHandlers) {
          if (optionHandlers.hasOwnProperty(opt)) {
            optionHandlers[opt](this, options[opt], Init);
          }
        }
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit) {
          options.finishInit(this);
        }
        for (var i3 = 0; i3 < initHooks.length; ++i3) {
          initHooks[i3](this);
        }
        endOperation(this);
        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
          display.lineDiv.style.textRendering = "auto";
        }
      }
      CodeMirror2.defaults = defaults;
      CodeMirror2.optionHandlers = optionHandlers;
      function registerEventHandlers(cm) {
        var d2 = cm.display;
        on(d2.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie && ie_version < 11) {
          on(d2.scroller, "dblclick", operation(cm, function(e2) {
            if (signalDOMEvent(cm, e2)) {
              return;
            }
            var pos = posFromMouse(cm, e2);
            if (!pos || clickInGutter(cm, e2) || eventInWidget(cm.display, e2)) {
              return;
            }
            e_preventDefault(e2);
            var word = cm.findWordAt(pos);
            extendSelection(cm.doc, word.anchor, word.head);
          }));
        } else {
          on(d2.scroller, "dblclick", function(e2) {
            return signalDOMEvent(cm, e2) || e_preventDefault(e2);
          });
        }
        on(d2.scroller, "contextmenu", function(e2) {
          return onContextMenu(cm, e2);
        });
        on(d2.input.getField(), "contextmenu", function(e2) {
          if (!d2.scroller.contains(e2.target)) {
            onContextMenu(cm, e2);
          }
        });
        var touchFinished, prevTouch = { end: 0 };
        function finishTouch() {
          if (d2.activeTouch) {
            touchFinished = setTimeout(function() {
              return d2.activeTouch = null;
            }, 1e3);
            prevTouch = d2.activeTouch;
            prevTouch.end = +/* @__PURE__ */ new Date();
          }
        }
        function isMouseLikeTouchEvent(e2) {
          if (e2.touches.length != 1) {
            return false;
          }
          var touch = e2.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
          if (other.left == null) {
            return true;
          }
          var dx = other.left - touch.left, dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20;
        }
        on(d2.scroller, "touchstart", function(e2) {
          if (!signalDOMEvent(cm, e2) && !isMouseLikeTouchEvent(e2) && !clickInGutter(cm, e2)) {
            d2.input.ensurePolled();
            clearTimeout(touchFinished);
            var now2 = +/* @__PURE__ */ new Date();
            d2.activeTouch = {
              start: now2,
              moved: false,
              prev: now2 - prevTouch.end <= 300 ? prevTouch : null
            };
            if (e2.touches.length == 1) {
              d2.activeTouch.left = e2.touches[0].pageX;
              d2.activeTouch.top = e2.touches[0].pageY;
            }
          }
        });
        on(d2.scroller, "touchmove", function() {
          if (d2.activeTouch) {
            d2.activeTouch.moved = true;
          }
        });
        on(d2.scroller, "touchend", function(e2) {
          var touch = d2.activeTouch;
          if (touch && !eventInWidget(d2, e2) && touch.left != null && !touch.moved && /* @__PURE__ */ new Date() - touch.start < 300) {
            var pos = cm.coordsChar(d2.activeTouch, "page"), range2;
            if (!touch.prev || farAway(touch, touch.prev)) {
              range2 = new Range(pos, pos);
            } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
              range2 = cm.findWordAt(pos);
            } else {
              range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
            }
            cm.setSelection(range2.anchor, range2.head);
            cm.focus();
            e_preventDefault(e2);
          }
          finishTouch();
        });
        on(d2.scroller, "touchcancel", finishTouch);
        on(d2.scroller, "scroll", function() {
          if (d2.scroller.clientHeight) {
            updateScrollTop(cm, d2.scroller.scrollTop);
            setScrollLeft(cm, d2.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });
        on(d2.scroller, "mousewheel", function(e2) {
          return onScrollWheel(cm, e2);
        });
        on(d2.scroller, "DOMMouseScroll", function(e2) {
          return onScrollWheel(cm, e2);
        });
        on(d2.wrapper, "scroll", function() {
          return d2.wrapper.scrollTop = d2.wrapper.scrollLeft = 0;
        });
        d2.dragFunctions = {
          enter: function(e2) {
            if (!signalDOMEvent(cm, e2)) {
              e_stop(e2);
            }
          },
          over: function(e2) {
            if (!signalDOMEvent(cm, e2)) {
              onDragOver(cm, e2);
              e_stop(e2);
            }
          },
          start: function(e2) {
            return onDragStart(cm, e2);
          },
          drop: operation(cm, onDrop),
          leave: function(e2) {
            if (!signalDOMEvent(cm, e2)) {
              clearDragCursor(cm);
            }
          }
        };
        var inp = d2.input.getField();
        on(inp, "keyup", function(e2) {
          return onKeyUp.call(cm, e2);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", function(e2) {
          return onFocus(cm, e2);
        });
        on(inp, "blur", function(e2) {
          return onBlur(cm, e2);
        });
      }
      var initHooks = [];
      CodeMirror2.defineInitHook = function(f2) {
        return initHooks.push(f2);
      };
      function indentLine(cm, n2, how, aggressive) {
        var doc2 = cm.doc, state;
        if (how == null) {
          how = "add";
        }
        if (how == "smart") {
          if (!doc2.mode.indent) {
            how = "prev";
          } else {
            state = getContextBefore(cm, n2).state;
          }
        }
        var tabSize = cm.options.tabSize;
        var line = getLine2(doc2, n2), curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        var curSpaceString = line.text.match(/^\s*/)[0], indentation;
        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc2.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass || indentation > 150) {
            if (!aggressive) {
              return;
            }
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n2 > doc2.first) {
            indentation = countColumn(getLine2(doc2, n2 - 1).text, null, tabSize);
          } else {
            indentation = 0;
          }
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString2 = "", pos = 0;
        if (cm.options.indentWithTabs) {
          for (var i3 = Math.floor(indentation / tabSize); i3; --i3) {
            pos += tabSize;
            indentString2 += "	";
          }
        }
        if (pos < indentation) {
          indentString2 += spaceStr(indentation - pos);
        }
        if (indentString2 != curSpaceString) {
          replaceRange(doc2, indentString2, Pos(n2, 0), Pos(n2, curSpaceString.length), "+input");
          line.stateAfter = null;
          return true;
        } else {
          for (var i$13 = 0; i$13 < doc2.sel.ranges.length; i$13++) {
            var range2 = doc2.sel.ranges[i$13];
            if (range2.head.line == n2 && range2.head.ch < curSpaceString.length) {
              var pos$1 = Pos(n2, curSpaceString.length);
              replaceOneSelection(doc2, i$13, new Range(pos$1, pos$1));
              break;
            }
          }
        }
      }
      var lastCopied = null;
      function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
      }
      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc2 = cm.doc;
        cm.display.shift = false;
        if (!sel) {
          sel = doc2.sel;
        }
        var recent = +/* @__PURE__ */ new Date() - 200;
        var paste = origin == "paste" || cm.state.pasteIncoming > recent;
        var textLines = splitLinesAuto(inserted), multiPaste = null;
        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) {
              multiPaste = [];
              for (var i3 = 0; i3 < lastCopied.text.length; i3++) {
                multiPaste.push(doc2.splitLines(lastCopied.text[i3]));
              }
            }
          } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
            multiPaste = map2(textLines, function(l2) {
              return [l2];
            });
          }
        }
        var updateInput = cm.curOp.updateInput;
        for (var i$13 = sel.ranges.length - 1; i$13 >= 0; i$13--) {
          var range2 = sel.ranges[i$13];
          var from = range2.from(), to = range2.to();
          if (range2.empty()) {
            if (deleted && deleted > 0) {
              from = Pos(from.line, from.ch - deleted);
            } else if (cm.state.overwrite && !paste) {
              to = Pos(to.line, Math.min(getLine2(doc2, to.line).text.length, to.ch + lst(textLines).length));
            } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
              from = to = Pos(from.line, 0);
            }
          }
          var changeEvent = {
            from,
            to,
            text: multiPaste ? multiPaste[i$13 % multiPaste.length] : textLines,
            origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
          };
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }
        if (inserted && !paste) {
          triggerElectric(cm, inserted);
        }
        ensureCursorVisible(cm);
        if (cm.curOp.updateInput < 2) {
          cm.curOp.updateInput = updateInput;
        }
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = -1;
      }
      function handlePaste(e2, cm) {
        var pasted = e2.clipboardData && e2.clipboardData.getData("Text");
        if (pasted) {
          e2.preventDefault();
          if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {
            runInOp(cm, function() {
              return applyTextInput(cm, pasted, 0, null, "paste");
            });
          }
          return true;
        }
      }
      function triggerElectric(cm, inserted) {
        if (!cm.options.electricChars || !cm.options.smartIndent) {
          return;
        }
        var sel = cm.doc.sel;
        for (var i3 = sel.ranges.length - 1; i3 >= 0; i3--) {
          var range2 = sel.ranges[i3];
          if (range2.head.ch > 100 || i3 && sel.ranges[i3 - 1].head.line == range2.head.line) {
            continue;
          }
          var mode = cm.getModeAt(range2.head);
          var indented = false;
          if (mode.electricChars) {
            for (var j2 = 0; j2 < mode.electricChars.length; j2++) {
              if (inserted.indexOf(mode.electricChars.charAt(j2)) > -1) {
                indented = indentLine(cm, range2.head.line, "smart");
                break;
              }
            }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine2(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
              indented = indentLine(cm, range2.head.line, "smart");
            }
          }
          if (indented) {
            signalLater(cm, "electricInput", cm, range2.head.line);
          }
        }
      }
      function copyableRanges(cm) {
        var text = [], ranges = [];
        for (var i3 = 0; i3 < cm.doc.sel.ranges.length; i3++) {
          var line = cm.doc.sel.ranges[i3].head.line;
          var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return { text, ranges };
      }
      function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
        field.setAttribute("autocorrect", autocorrect ? "on" : "off");
        field.setAttribute("autocapitalize", autocapitalize ? "on" : "off");
        field.setAttribute("spellcheck", !!spellcheck);
      }
      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        if (webkit) {
          te.style.width = "1000px";
        } else {
          te.setAttribute("wrap", "off");
        }
        if (ios) {
          te.style.border = "1px solid black";
        }
        return div;
      }
      function addEditorMethods(CodeMirror3) {
        var optionHandlers2 = CodeMirror3.optionHandlers;
        var helpers = CodeMirror3.helpers = {};
        CodeMirror3.prototype = {
          constructor: CodeMirror3,
          focus: function() {
            win(this).focus();
            this.display.input.focus();
          },
          setOption: function(option, value) {
            var options = this.options, old = options[option];
            if (options[option] == value && option != "mode") {
              return;
            }
            options[option] = value;
            if (optionHandlers2.hasOwnProperty(option)) {
              operation(this, optionHandlers2[option])(this, value, old);
            }
            signal(this, "optionChange", this, option);
          },
          getOption: function(option) {
            return this.options[option];
          },
          getDoc: function() {
            return this.doc;
          },
          addKeyMap: function(map3, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map3));
          },
          removeKeyMap: function(map3) {
            var maps = this.state.keyMaps;
            for (var i3 = 0; i3 < maps.length; ++i3) {
              if (maps[i3] == map3 || maps[i3].name == map3) {
                maps.splice(i3, 1);
                return true;
              }
            }
          },
          addOverlay: methodOp(function(spec, options) {
            var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
            if (mode.startState) {
              throw new Error("Overlays may not be stateful.");
            }
            insertSorted(
              this.state.overlays,
              {
                mode,
                modeSpec: spec,
                opaque: options && options.opaque,
                priority: options && options.priority || 0
              },
              function(overlay2) {
                return overlay2.priority;
              }
            );
            this.state.modeGen++;
            regChange(this);
          }),
          removeOverlay: methodOp(function(spec) {
            var overlays = this.state.overlays;
            for (var i3 = 0; i3 < overlays.length; ++i3) {
              var cur = overlays[i3].modeSpec;
              if (cur == spec || typeof spec == "string" && cur.name == spec) {
                overlays.splice(i3, 1);
                this.state.modeGen++;
                regChange(this);
                return;
              }
            }
          }),
          indentLine: methodOp(function(n2, dir, aggressive) {
            if (typeof dir != "string" && typeof dir != "number") {
              if (dir == null) {
                dir = this.options.smartIndent ? "smart" : "prev";
              } else {
                dir = dir ? "add" : "subtract";
              }
            }
            if (isLine(this.doc, n2)) {
              indentLine(this, n2, dir, aggressive);
            }
          }),
          indentSelection: methodOp(function(how) {
            var ranges = this.doc.sel.ranges, end = -1;
            for (var i3 = 0; i3 < ranges.length; i3++) {
              var range2 = ranges[i3];
              if (!range2.empty()) {
                var from = range2.from(), to = range2.to();
                var start2 = Math.max(end, from.line);
                end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                for (var j2 = start2; j2 < end; ++j2) {
                  indentLine(this, j2, how);
                }
                var newRanges = this.doc.sel.ranges;
                if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i3].from().ch > 0) {
                  replaceOneSelection(this.doc, i3, new Range(from, newRanges[i3].to()), sel_dontScroll);
                }
              } else if (range2.head.line > end) {
                indentLine(this, range2.head.line, how, true);
                end = range2.head.line;
                if (i3 == this.doc.sel.primIndex) {
                  ensureCursorVisible(this);
                }
              }
            }
          }),
          // Fetch the parser token for a given character. Useful for hacks
          // that want to inspect the mode state (say, for completion).
          getTokenAt: function(pos, precise) {
            return takeToken(this, pos, precise);
          },
          getLineTokens: function(line, precise) {
            return takeToken(this, Pos(line), precise, true);
          },
          getTokenTypeAt: function(pos) {
            pos = clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine2(this.doc, pos.line));
            var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
            var type2;
            if (ch == 0) {
              type2 = styles[2];
            } else {
              for (; ; ) {
                var mid = before + after >> 1;
                if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                  after = mid;
                } else if (styles[mid * 2 + 1] < ch) {
                  before = mid + 1;
                } else {
                  type2 = styles[mid * 2 + 2];
                  break;
                }
              }
            }
            var cut = type2 ? type2.indexOf("overlay ") : -1;
            return cut < 0 ? type2 : cut == 0 ? null : type2.slice(0, cut - 1);
          },
          getModeAt: function(pos) {
            var mode = this.doc.mode;
            if (!mode.innerMode) {
              return mode;
            }
            return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
          },
          getHelper: function(pos, type2) {
            return this.getHelpers(pos, type2)[0];
          },
          getHelpers: function(pos, type2) {
            var found = [];
            if (!helpers.hasOwnProperty(type2)) {
              return found;
            }
            var help = helpers[type2], mode = this.getModeAt(pos);
            if (typeof mode[type2] == "string") {
              if (help[mode[type2]]) {
                found.push(help[mode[type2]]);
              }
            } else if (mode[type2]) {
              for (var i3 = 0; i3 < mode[type2].length; i3++) {
                var val = help[mode[type2][i3]];
                if (val) {
                  found.push(val);
                }
              }
            } else if (mode.helperType && help[mode.helperType]) {
              found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
              found.push(help[mode.name]);
            }
            for (var i$13 = 0; i$13 < help._global.length; i$13++) {
              var cur = help._global[i$13];
              if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                found.push(cur.val);
              }
            }
            return found;
          },
          getStateAfter: function(line, precise) {
            var doc2 = this.doc;
            line = clipLine(doc2, line == null ? doc2.first + doc2.size - 1 : line);
            return getContextBefore(this, line + 1, precise).state;
          },
          cursorCoords: function(start2, mode) {
            var pos, range2 = this.doc.sel.primary();
            if (start2 == null) {
              pos = range2.head;
            } else if (typeof start2 == "object") {
              pos = clipPos(this.doc, start2);
            } else {
              pos = start2 ? range2.from() : range2.to();
            }
            return cursorCoords(this, pos, mode || "page");
          },
          charCoords: function(pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || "page");
          },
          coordsChar: function(coords, mode) {
            coords = fromCoordSystem(this, coords, mode || "page");
            return coordsChar(this, coords.left, coords.top);
          },
          lineAtHeight: function(height, mode) {
            height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
            return lineAtHeight(this.doc, height + this.display.viewOffset);
          },
          heightAtLine: function(line, mode, includeWidgets) {
            var end = false, lineObj;
            if (typeof line == "number") {
              var last = this.doc.first + this.doc.size - 1;
              if (line < this.doc.first) {
                line = this.doc.first;
              } else if (line > last) {
                line = last;
                end = true;
              }
              lineObj = getLine2(this.doc, line);
            } else {
              lineObj = line;
            }
            return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
          },
          defaultTextHeight: function() {
            return textHeight(this.display);
          },
          defaultCharWidth: function() {
            return charWidth(this.display);
          },
          getViewport: function() {
            return { from: this.display.viewFrom, to: this.display.viewTo };
          },
          addWidget: function(pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom, left = pos.left;
            node.style.position = "absolute";
            node.setAttribute("cm-ignore-events", "true");
            this.display.input.setUneditable(node);
            display.sizer.appendChild(node);
            if (vert == "over") {
              top = pos.top;
            } else if (vert == "above" || vert == "near") {
              var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
              if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                top = pos.top - node.offsetHeight;
              } else if (pos.bottom + node.offsetHeight <= vspace) {
                top = pos.bottom;
              }
              if (left + node.offsetWidth > hspace) {
                left = hspace - node.offsetWidth;
              }
            }
            node.style.top = top + "px";
            node.style.left = node.style.right = "";
            if (horiz == "right") {
              left = display.sizer.clientWidth - node.offsetWidth;
              node.style.right = "0px";
            } else {
              if (horiz == "left") {
                left = 0;
              } else if (horiz == "middle") {
                left = (display.sizer.clientWidth - node.offsetWidth) / 2;
              }
              node.style.left = left + "px";
            }
            if (scroll) {
              scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
            }
          },
          triggerOnKeyDown: methodOp(onKeyDown),
          triggerOnKeyPress: methodOp(onKeyPress),
          triggerOnKeyUp: onKeyUp,
          triggerOnMouseDown: methodOp(onMouseDown),
          execCommand: function(cmd) {
            if (commands.hasOwnProperty(cmd)) {
              return commands[cmd].call(null, this);
            }
          },
          triggerElectric: methodOp(function(text) {
            triggerElectric(this, text);
          }),
          findPosH: function(from, amount, unit, visually) {
            var dir = 1;
            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }
            var cur = clipPos(this.doc, from);
            for (var i3 = 0; i3 < amount; ++i3) {
              cur = findPosH(this.doc, cur, dir, unit, visually);
              if (cur.hitSide) {
                break;
              }
            }
            return cur;
          },
          moveH: methodOp(function(dir, unit) {
            var this$1$1 = this;
            this.extendSelectionsBy(function(range2) {
              if (this$1$1.display.shift || this$1$1.doc.extend || range2.empty()) {
                return findPosH(this$1$1.doc, range2.head, dir, unit, this$1$1.options.rtlMoveVisually);
              } else {
                return dir < 0 ? range2.from() : range2.to();
              }
            }, sel_move);
          }),
          deleteH: methodOp(function(dir, unit) {
            var sel = this.doc.sel, doc2 = this.doc;
            if (sel.somethingSelected()) {
              doc2.replaceSelection("", null, "+delete");
            } else {
              deleteNearSelection(this, function(range2) {
                var other = findPosH(doc2, range2.head, dir, unit, false);
                return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
              });
            }
          }),
          findPosV: function(from, amount, unit, goalColumn) {
            var dir = 1, x2 = goalColumn;
            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }
            var cur = clipPos(this.doc, from);
            for (var i3 = 0; i3 < amount; ++i3) {
              var coords = cursorCoords(this, cur, "div");
              if (x2 == null) {
                x2 = coords.left;
              } else {
                coords.left = x2;
              }
              cur = findPosV(this, coords, dir, unit);
              if (cur.hitSide) {
                break;
              }
            }
            return cur;
          },
          moveV: methodOp(function(dir, unit) {
            var this$1$1 = this;
            var doc2 = this.doc, goals = [];
            var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();
            doc2.extendSelectionsBy(function(range2) {
              if (collapse) {
                return dir < 0 ? range2.from() : range2.to();
              }
              var headPos = cursorCoords(this$1$1, range2.head, "div");
              if (range2.goalColumn != null) {
                headPos.left = range2.goalColumn;
              }
              goals.push(headPos.left);
              var pos = findPosV(this$1$1, headPos, dir, unit);
              if (unit == "page" && range2 == doc2.sel.primary()) {
                addToScrollTop(this$1$1, charCoords(this$1$1, pos, "div").top - headPos.top);
              }
              return pos;
            }, sel_move);
            if (goals.length) {
              for (var i3 = 0; i3 < doc2.sel.ranges.length; i3++) {
                doc2.sel.ranges[i3].goalColumn = goals[i3];
              }
            }
          }),
          // Find the word at the given position (as returned by coordsChar).
          findWordAt: function(pos) {
            var doc2 = this.doc, line = getLine2(doc2, pos.line).text;
            var start2 = pos.ch, end = pos.ch;
            if (line) {
              var helper = this.getHelper(pos, "wordChars");
              if ((pos.sticky == "before" || end == line.length) && start2) {
                --start2;
              } else {
                ++end;
              }
              var startChar = line.charAt(start2);
              var check2 = isWordChar(startChar, helper) ? function(ch) {
                return isWordChar(ch, helper);
              } : /\s/.test(startChar) ? function(ch) {
                return /\s/.test(ch);
              } : function(ch) {
                return !/\s/.test(ch) && !isWordChar(ch);
              };
              while (start2 > 0 && check2(line.charAt(start2 - 1))) {
                --start2;
              }
              while (end < line.length && check2(line.charAt(end))) {
                ++end;
              }
            }
            return new Range(Pos(pos.line, start2), Pos(pos.line, end));
          },
          toggleOverwrite: function(value) {
            if (value != null && value == this.state.overwrite) {
              return;
            }
            if (this.state.overwrite = !this.state.overwrite) {
              addClass(this.display.cursorDiv, "CodeMirror-overwrite");
            } else {
              rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
            }
            signal(this, "overwriteToggle", this, this.state.overwrite);
          },
          hasFocus: function() {
            return this.display.input.getField() == activeElt(root2(this));
          },
          isReadOnly: function() {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: methodOp(function(x2, y2) {
            scrollToCoords(this, x2, y2);
          }),
          getScrollInfo: function() {
            var scroller = this.display.scroller;
            return {
              left: scroller.scrollLeft,
              top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this),
              clientWidth: displayWidth(this)
            };
          },
          scrollIntoView: methodOp(function(range2, margin) {
            if (range2 == null) {
              range2 = { from: this.doc.sel.primary().head, to: null };
              if (margin == null) {
                margin = this.options.cursorScrollMargin;
              }
            } else if (typeof range2 == "number") {
              range2 = { from: Pos(range2, 0), to: null };
            } else if (range2.from == null) {
              range2 = { from: range2, to: null };
            }
            if (!range2.to) {
              range2.to = range2.from;
            }
            range2.margin = margin || 0;
            if (range2.from.line != null) {
              scrollToRange(this, range2);
            } else {
              scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
            }
          }),
          setSize: methodOp(function(width, height) {
            var this$1$1 = this;
            var interpret = function(val) {
              return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
            };
            if (width != null) {
              this.display.wrapper.style.width = interpret(width);
            }
            if (height != null) {
              this.display.wrapper.style.height = interpret(height);
            }
            if (this.options.lineWrapping) {
              clearLineMeasurementCache(this);
            }
            var lineNo2 = this.display.viewFrom;
            this.doc.iter(lineNo2, this.display.viewTo, function(line) {
              if (line.widgets) {
                for (var i3 = 0; i3 < line.widgets.length; i3++) {
                  if (line.widgets[i3].noHScroll) {
                    regLineChange(this$1$1, lineNo2, "widget");
                    break;
                  }
                }
              }
              ++lineNo2;
            });
            this.curOp.forceUpdate = true;
            signal(this, "refresh", this);
          }),
          operation: function(f2) {
            return runInOp(this, f2);
          },
          startOperation: function() {
            return startOperation(this);
          },
          endOperation: function() {
            return endOperation(this);
          },
          refresh: methodOp(function() {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this.display);
            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
              estimateLineHeights(this);
            }
            signal(this, "refresh", this);
          }),
          swapDoc: methodOp(function(doc2) {
            var old = this.doc;
            old.cm = null;
            if (this.state.selectingText) {
              this.state.selectingText();
            }
            attachDoc(this, doc2);
            clearCaches(this);
            this.display.input.reset();
            scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);
            this.curOp.forceScroll = true;
            signalLater(this, "swapDoc", this, old);
            return old;
          }),
          phrase: function(phraseText) {
            var phrases = this.options.phrases;
            return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
          },
          getInputField: function() {
            return this.display.input.getField();
          },
          getWrapperElement: function() {
            return this.display.wrapper;
          },
          getScrollerElement: function() {
            return this.display.scroller;
          },
          getGutterElement: function() {
            return this.display.gutters;
          }
        };
        eventMixin(CodeMirror3);
        CodeMirror3.registerHelper = function(type2, name, value) {
          if (!helpers.hasOwnProperty(type2)) {
            helpers[type2] = CodeMirror3[type2] = { _global: [] };
          }
          helpers[type2][name] = value;
        };
        CodeMirror3.registerGlobalHelper = function(type2, name, predicate, value) {
          CodeMirror3.registerHelper(type2, name, value);
          helpers[type2]._global.push({ pred: predicate, val: value });
        };
      }
      function findPosH(doc2, pos, dir, unit, visually) {
        var oldPos = pos;
        var origDir = dir;
        var lineObj = getLine2(doc2, pos.line);
        var lineDir = visually && doc2.direction == "rtl" ? -dir : dir;
        function findNextLine() {
          var l2 = pos.line + lineDir;
          if (l2 < doc2.first || l2 >= doc2.first + doc2.size) {
            return false;
          }
          pos = new Pos(l2, pos.ch, pos.sticky);
          return lineObj = getLine2(doc2, l2);
        }
        function moveOnce(boundToLine) {
          var next;
          if (unit == "codepoint") {
            var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
            if (isNaN(ch)) {
              next = null;
            } else {
              var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
              next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
            }
          } else if (visually) {
            next = moveVisually(doc2.cm, lineObj, pos, dir);
          } else {
            next = moveLogically(lineObj, pos, dir);
          }
          if (next == null) {
            if (!boundToLine && findNextLine()) {
              pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);
            } else {
              return false;
            }
          } else {
            pos = next;
          }
          return true;
        }
        if (unit == "char" || unit == "codepoint") {
          moveOnce();
        } else if (unit == "column") {
          moveOnce(true);
        } else if (unit == "word" || unit == "group") {
          var sawType = null, group = unit == "group";
          var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");
          for (var first = true; ; first = false) {
            if (dir < 0 && !moveOnce(!first)) {
              break;
            }
            var cur = lineObj.text.charAt(pos.ch) || "\n";
            var type2 = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
            if (group && !first && !type2) {
              type2 = "s";
            }
            if (sawType && sawType != type2) {
              if (dir < 0) {
                dir = 1;
                moveOnce();
                pos.sticky = "after";
              }
              break;
            }
            if (type2) {
              sawType = type2;
            }
            if (dir > 0 && !moveOnce(!first)) {
              break;
            }
          }
        }
        var result = skipAtomic(doc2, pos, oldPos, origDir, true);
        if (equalCursorPos(oldPos, result)) {
          result.hitSide = true;
        }
        return result;
      }
      function findPosV(cm, pos, dir, unit) {
        var doc2 = cm.doc, x2 = pos.left, y2;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc2(cm).documentElement.clientHeight);
          var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
          y2 = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else if (unit == "line") {
          y2 = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        var target;
        for (; ; ) {
          target = coordsChar(cm, x2, y2);
          if (!target.outside) {
            break;
          }
          if (dir < 0 ? y2 <= 0 : y2 >= doc2.height) {
            target.hitSide = true;
            break;
          }
          y2 += dir * 5;
        }
        return target;
      }
      var ContentEditableInput = function(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.composing = null;
        this.gracePeriod = false;
        this.readDOMTimeout = null;
      };
      ContentEditableInput.prototype.init = function(display) {
        var this$1$1 = this;
        var input = this, cm = input.cm;
        var div = input.div = display.lineDiv;
        div.contentEditable = true;
        disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
        function belongsToInput(e2) {
          for (var t2 = e2.target; t2; t2 = t2.parentNode) {
            if (t2 == div) {
              return true;
            }
            if (/\bCodeMirror-(?:line)?widget\b/.test(t2.className)) {
              break;
            }
          }
          return false;
        }
        on(div, "paste", function(e2) {
          if (!belongsToInput(e2) || signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
            return;
          }
          if (ie_version <= 11) {
            setTimeout(operation(cm, function() {
              return this$1$1.updateFromDOM();
            }), 20);
          }
        });
        on(div, "compositionstart", function(e2) {
          this$1$1.composing = { data: e2.data, done: false };
        });
        on(div, "compositionupdate", function(e2) {
          if (!this$1$1.composing) {
            this$1$1.composing = { data: e2.data, done: false };
          }
        });
        on(div, "compositionend", function(e2) {
          if (this$1$1.composing) {
            if (e2.data != this$1$1.composing.data) {
              this$1$1.readFromDOMSoon();
            }
            this$1$1.composing.done = true;
          }
        });
        on(div, "touchstart", function() {
          return input.forceCompositionEnd();
        });
        on(div, "input", function() {
          if (!this$1$1.composing) {
            this$1$1.readFromDOMSoon();
          }
        });
        function onCopyCut(e2) {
          if (!belongsToInput(e2) || signalDOMEvent(cm, e2)) {
            return;
          }
          if (cm.somethingSelected()) {
            setLastCopied({ lineWise: false, text: cm.getSelections() });
            if (e2.type == "cut") {
              cm.replaceSelection("", null, "cut");
            }
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({ lineWise: true, text: ranges.text });
            if (e2.type == "cut") {
              cm.operation(function() {
                cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                cm.replaceSelection("", null, "cut");
              });
            }
          }
          if (e2.clipboardData) {
            e2.clipboardData.clearData();
            var content = lastCopied.text.join("\n");
            e2.clipboardData.setData("Text", content);
            if (e2.clipboardData.getData("Text") == content) {
              e2.preventDefault();
              return;
            }
          }
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          disableBrowserMagic(te);
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.text.join("\n");
          var hadFocus = activeElt(rootNode(div));
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
            if (hadFocus == div) {
              input.showPrimarySelection();
            }
          }, 50);
        }
        on(div, "copy", onCopyCut);
        on(div, "cut", onCopyCut);
      };
      ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
        if (label) {
          this.div.setAttribute("aria-label", label);
        } else {
          this.div.removeAttribute("aria-label");
        }
      };
      ContentEditableInput.prototype.prepareSelection = function() {
        var result = prepareSelection(this.cm, false);
        result.focus = activeElt(rootNode(this.div)) == this.div;
        return result;
      };
      ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
        if (!info || !this.cm.display.view.length) {
          return;
        }
        if (info.focus || takeFocus) {
          this.showPrimarySelection();
        }
        this.showMultipleSelections(info);
      };
      ContentEditableInput.prototype.getSelection = function() {
        return this.cm.display.wrapper.ownerDocument.getSelection();
      };
      ContentEditableInput.prototype.showPrimarySelection = function() {
        var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
        var from = prim.from(), to = prim.to();
        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
          sel.removeAllRanges();
          return;
        }
        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
          return;
        }
        var view = cm.display.view;
        var start2 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
        var end = to.line < cm.display.viewTo && posToDOM(cm, to);
        if (!end) {
          var measure = view[view.length - 1].measure;
          var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
          end = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };
        }
        if (!start2 || !end) {
          sel.removeAllRanges();
          return;
        }
        var old = sel.rangeCount && sel.getRangeAt(0), rng;
        try {
          rng = range(start2.node, start2.offset, end.offset, end.node);
        } catch (e2) {
        }
        if (rng) {
          if (!gecko && cm.state.focused) {
            sel.collapse(start2.node, start2.offset);
            if (!rng.collapsed) {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
          } else {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
          if (old && sel.anchorNode == null) {
            sel.addRange(old);
          } else if (gecko) {
            this.startGracePeriod();
          }
        }
        this.rememberSelection();
      };
      ContentEditableInput.prototype.startGracePeriod = function() {
        var this$1$1 = this;
        clearTimeout(this.gracePeriod);
        this.gracePeriod = setTimeout(function() {
          this$1$1.gracePeriod = false;
          if (this$1$1.selectionChanged()) {
            this$1$1.cm.operation(function() {
              return this$1$1.cm.curOp.selectionChanged = true;
            });
          }
        }, 20);
      };
      ContentEditableInput.prototype.showMultipleSelections = function(info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
      };
      ContentEditableInput.prototype.rememberSelection = function() {
        var sel = this.getSelection();
        this.lastAnchorNode = sel.anchorNode;
        this.lastAnchorOffset = sel.anchorOffset;
        this.lastFocusNode = sel.focusNode;
        this.lastFocusOffset = sel.focusOffset;
      };
      ContentEditableInput.prototype.selectionInEditor = function() {
        var sel = this.getSelection();
        if (!sel.rangeCount) {
          return false;
        }
        var node = sel.getRangeAt(0).commonAncestorContainer;
        return contains(this.div, node);
      };
      ContentEditableInput.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor") {
          if (!this.selectionInEditor() || activeElt(rootNode(this.div)) != this.div) {
            this.showSelection(this.prepareSelection(), true);
          }
          this.div.focus();
        }
      };
      ContentEditableInput.prototype.blur = function() {
        this.div.blur();
      };
      ContentEditableInput.prototype.getField = function() {
        return this.div;
      };
      ContentEditableInput.prototype.supportsTouch = function() {
        return true;
      };
      ContentEditableInput.prototype.receivedFocus = function() {
        var this$1$1 = this;
        var input = this;
        if (this.selectionInEditor()) {
          setTimeout(function() {
            return this$1$1.pollSelection();
          }, 20);
        } else {
          runInOp(this.cm, function() {
            return input.cm.curOp.selectionChanged = true;
          });
        }
        function poll() {
          if (input.cm.state.focused) {
            input.pollSelection();
            input.polling.set(input.cm.options.pollInterval, poll);
          }
        }
        this.polling.set(this.cm.options.pollInterval, poll);
      };
      ContentEditableInput.prototype.selectionChanged = function() {
        var sel = this.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
      };
      ContentEditableInput.prototype.pollSelection = function() {
        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
          return;
        }
        var sel = this.getSelection(), cm = this.cm;
        if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
          this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
          this.blur();
          this.focus();
          return;
        }
        if (this.composing) {
          return;
        }
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) {
          runInOp(cm, function() {
            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
            if (anchor.bad || head.bad) {
              cm.curOp.selectionChanged = true;
            }
          });
        }
      };
      ContentEditableInput.prototype.pollContent = function() {
        if (this.readDOMTimeout != null) {
          clearTimeout(this.readDOMTimeout);
          this.readDOMTimeout = null;
        }
        var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
        var from = sel.from(), to = sel.to();
        if (from.ch == 0 && from.line > cm.firstLine()) {
          from = Pos(from.line - 1, getLine2(cm.doc, from.line - 1).length);
        }
        if (to.ch == getLine2(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
          to = Pos(to.line + 1, 0);
        }
        if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
          return false;
        }
        var fromIndex, fromLine, fromNode;
        if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
          fromLine = lineNo(display.view[0].line);
          fromNode = display.view[0].node;
        } else {
          fromLine = lineNo(display.view[fromIndex].line);
          fromNode = display.view[fromIndex - 1].node.nextSibling;
        }
        var toIndex = findViewIndex(cm, to.line);
        var toLine, toNode;
        if (toIndex == display.view.length - 1) {
          toLine = display.viewTo - 1;
          toNode = display.lineDiv.lastChild;
        } else {
          toLine = lineNo(display.view[toIndex + 1].line) - 1;
          toNode = display.view[toIndex + 1].node.previousSibling;
        }
        if (!fromNode) {
          return false;
        }
        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine2(cm.doc, toLine).text.length));
        while (newText.length > 1 && oldText.length > 1) {
          if (lst(newText) == lst(oldText)) {
            newText.pop();
            oldText.pop();
            toLine--;
          } else if (newText[0] == oldText[0]) {
            newText.shift();
            oldText.shift();
            fromLine++;
          } else {
            break;
          }
        }
        var cutFront = 0, cutEnd = 0;
        var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
        while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
          ++cutFront;
        }
        var newBot = lst(newText), oldBot = lst(oldText);
        var maxCutEnd = Math.min(
          newBot.length - (newText.length == 1 ? cutFront : 0),
          oldBot.length - (oldText.length == 1 ? cutFront : 0)
        );
        while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          ++cutEnd;
        }
        if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
          while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            cutFront--;
            cutEnd++;
          }
        }
        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
        var chFrom = Pos(fromLine, cutFront);
        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
          replaceRange(cm.doc, newText, chFrom, chTo, "+input");
          return true;
        }
      };
      ContentEditableInput.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
      };
      ContentEditableInput.prototype.reset = function() {
        this.forceCompositionEnd();
      };
      ContentEditableInput.prototype.forceCompositionEnd = function() {
        if (!this.composing) {
          return;
        }
        clearTimeout(this.readDOMTimeout);
        this.composing = null;
        this.updateFromDOM();
        this.div.blur();
        this.div.focus();
      };
      ContentEditableInput.prototype.readFromDOMSoon = function() {
        var this$1$1 = this;
        if (this.readDOMTimeout != null) {
          return;
        }
        this.readDOMTimeout = setTimeout(function() {
          this$1$1.readDOMTimeout = null;
          if (this$1$1.composing) {
            if (this$1$1.composing.done) {
              this$1$1.composing = null;
            } else {
              return;
            }
          }
          this$1$1.updateFromDOM();
        }, 80);
      };
      ContentEditableInput.prototype.updateFromDOM = function() {
        var this$1$1 = this;
        if (this.cm.isReadOnly() || !this.pollContent()) {
          runInOp(this.cm, function() {
            return regChange(this$1$1.cm);
          });
        }
      };
      ContentEditableInput.prototype.setUneditable = function(node) {
        node.contentEditable = "false";
      };
      ContentEditableInput.prototype.onKeyPress = function(e2) {
        if (e2.charCode == 0 || this.composing) {
          return;
        }
        e2.preventDefault();
        if (!this.cm.isReadOnly()) {
          operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e2.charCode == null ? e2.keyCode : e2.charCode), 0);
        }
      };
      ContentEditableInput.prototype.readOnlyChanged = function(val) {
        this.div.contentEditable = String(val != "nocursor");
      };
      ContentEditableInput.prototype.onContextMenu = function() {
      };
      ContentEditableInput.prototype.resetPosition = function() {
      };
      ContentEditableInput.prototype.needsContentAttribute = true;
      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden) {
          return null;
        }
        var line = getLine2(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line, cm.doc.direction), side = "left";
        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
      }
      function isInGutter(node) {
        for (var scan = node; scan; scan = scan.parentNode) {
          if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
            return true;
          }
        }
        return false;
      }
      function badPos(pos, bad) {
        if (bad) {
          pos.bad = true;
        }
        return pos;
      }
      function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
        function recognizeMarker(id2) {
          return function(marker) {
            return marker.id == id2;
          };
        }
        function close() {
          if (closing) {
            text += lineSep;
            if (extraLinebreak) {
              text += lineSep;
            }
            closing = extraLinebreak = false;
          }
        }
        function addText(str2) {
          if (str2) {
            close();
            text += str2;
          }
        }
        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");
            if (cmText) {
              addText(cmText);
              return;
            }
            var markerID = node.getAttribute("cm-marker"), range2;
            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
              if (found.length && (range2 = found[0].find(0))) {
                addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
              }
              return;
            }
            if (node.getAttribute("contenteditable") == "false") {
              return;
            }
            var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
            if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
              return;
            }
            if (isBlock) {
              close();
            }
            for (var i3 = 0; i3 < node.childNodes.length; i3++) {
              walk(node.childNodes[i3]);
            }
            if (/^(pre|p)$/i.test(node.nodeName)) {
              extraLinebreak = true;
            }
            if (isBlock) {
              closing = true;
            }
          } else if (node.nodeType == 3) {
            addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
          }
        }
        for (; ; ) {
          walk(from);
          if (from == to) {
            break;
          }
          from = from.nextSibling;
          extraLinebreak = false;
        }
        return text;
      }
      function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];
          if (!lineNode) {
            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
          }
          node = null;
          offset = 0;
        } else {
          for (lineNode = node; ; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) {
              return null;
            }
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
              break;
            }
          }
        }
        for (var i3 = 0; i3 < cm.display.view.length; i3++) {
          var lineView = cm.display.view[i3];
          if (lineView.node == lineNode) {
            return locateNodeInLineView(lineView, node, offset);
          }
        }
      }
      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild, bad = false;
        if (!node || !contains(wrapper, node)) {
          return badPos(Pos(lineNo(lineView.line), 0), true);
        }
        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;
          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
          }
        }
        var textNode = node.nodeType == 3 ? node : null, topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;
          if (offset) {
            offset = textNode.nodeValue.length;
          }
        }
        while (topNode.parentNode != wrapper) {
          topNode = topNode.parentNode;
        }
        var measure = lineView.measure, maps = measure.maps;
        function find2(textNode2, topNode2, offset2) {
          for (var i3 = -1; i3 < (maps ? maps.length : 0); i3++) {
            var map3 = i3 < 0 ? measure.map : maps[i3];
            for (var j2 = 0; j2 < map3.length; j2 += 3) {
              var curNode = map3[j2 + 2];
              if (curNode == textNode2 || curNode == topNode2) {
                var line2 = lineNo(i3 < 0 ? lineView.line : lineView.rest[i3]);
                var ch = map3[j2] + offset2;
                if (offset2 < 0 || curNode != textNode2) {
                  ch = map3[j2 + (offset2 ? 1 : 0)];
                }
                return Pos(line2, ch);
              }
            }
          }
        }
        var found = find2(textNode, topNode, offset);
        if (found) {
          return badPos(found, bad);
        }
        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find2(after, after.firstChild, 0);
          if (found) {
            return badPos(Pos(found.line, found.ch - dist), bad);
          } else {
            dist += after.textContent.length;
          }
        }
        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
          found = find2(before, before.firstChild, -1);
          if (found) {
            return badPos(Pos(found.line, found.ch + dist$1), bad);
          } else {
            dist$1 += before.textContent.length;
          }
        }
      }
      var TextareaInput = function(cm) {
        this.cm = cm;
        this.prevInput = "";
        this.pollingFast = false;
        this.polling = new Delayed();
        this.hasSelection = false;
        this.composing = null;
        this.resetting = false;
      };
      TextareaInput.prototype.init = function(display) {
        var this$1$1 = this;
        var input = this, cm = this.cm;
        this.createField(display);
        var te = this.textarea;
        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
        if (ios) {
          te.style.width = "0px";
        }
        on(te, "input", function() {
          if (ie && ie_version >= 9 && this$1$1.hasSelection) {
            this$1$1.hasSelection = null;
          }
          input.poll();
        });
        on(te, "paste", function(e2) {
          if (signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
            return;
          }
          cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
          input.fastPoll();
        });
        function prepareCopyCut(e2) {
          if (signalDOMEvent(cm, e2)) {
            return;
          }
          if (cm.somethingSelected()) {
            setLastCopied({ lineWise: false, text: cm.getSelections() });
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({ lineWise: true, text: ranges.text });
            if (e2.type == "cut") {
              cm.setSelections(ranges.ranges, null, sel_dontScroll);
            } else {
              input.prevInput = "";
              te.value = ranges.text.join("\n");
              selectInput(te);
            }
          }
          if (e2.type == "cut") {
            cm.state.cutIncoming = +/* @__PURE__ */ new Date();
          }
        }
        on(te, "cut", prepareCopyCut);
        on(te, "copy", prepareCopyCut);
        on(display.scroller, "paste", function(e2) {
          if (eventInWidget(display, e2) || signalDOMEvent(cm, e2)) {
            return;
          }
          if (!te.dispatchEvent) {
            cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
            input.focus();
            return;
          }
          var event = new Event("paste");
          event.clipboardData = e2.clipboardData;
          te.dispatchEvent(event);
        });
        on(display.lineSpace, "selectstart", function(e2) {
          if (!eventInWidget(display, e2)) {
            e_preventDefault(e2);
          }
        });
        on(te, "compositionstart", function() {
          var start2 = cm.getCursor("from");
          if (input.composing) {
            input.composing.range.clear();
          }
          input.composing = {
            start: start2,
            range: cm.markText(start2, cm.getCursor("to"), { className: "CodeMirror-composing" })
          };
        });
        on(te, "compositionend", function() {
          if (input.composing) {
            input.poll();
            input.composing.range.clear();
            input.composing = null;
          }
        });
      };
      TextareaInput.prototype.createField = function(_display) {
        this.wrapper = hiddenTextarea();
        this.textarea = this.wrapper.firstChild;
        var opts = this.cm.options;
        disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);
      };
      TextareaInput.prototype.screenReaderLabelChanged = function(label) {
        if (label) {
          this.textarea.setAttribute("aria-label", label);
        } else {
          this.textarea.removeAttribute("aria-label");
        }
      };
      TextareaInput.prototype.prepareSelection = function() {
        var cm = this.cm, display = cm.display, doc2 = cm.doc;
        var result = prepareSelection(cm);
        if (cm.options.moveInputWithCursor) {
          var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");
          var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
          result.teTop = Math.max(0, Math.min(
            display.wrapper.clientHeight - 10,
            headPos.top + lineOff.top - wrapOff.top
          ));
          result.teLeft = Math.max(0, Math.min(
            display.wrapper.clientWidth - 10,
            headPos.left + lineOff.left - wrapOff.left
          ));
        }
        return result;
      };
      TextareaInput.prototype.showSelection = function(drawn) {
        var cm = this.cm, display = cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
        removeChildrenAndAdd(display.selectionDiv, drawn.selection);
        if (drawn.teTop != null) {
          this.wrapper.style.top = drawn.teTop + "px";
          this.wrapper.style.left = drawn.teLeft + "px";
        }
      };
      TextareaInput.prototype.reset = function(typing) {
        if (this.contextMenuPending || this.composing && typing) {
          return;
        }
        var cm = this.cm;
        this.resetting = true;
        if (cm.somethingSelected()) {
          this.prevInput = "";
          var content = cm.getSelection();
          this.textarea.value = content;
          if (cm.state.focused) {
            selectInput(this.textarea);
          }
          if (ie && ie_version >= 9) {
            this.hasSelection = content;
          }
        } else if (!typing) {
          this.prevInput = this.textarea.value = "";
          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
        }
        this.resetting = false;
      };
      TextareaInput.prototype.getField = function() {
        return this.textarea;
      };
      TextareaInput.prototype.supportsTouch = function() {
        return false;
      };
      TextareaInput.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(rootNode(this.textarea)) != this.textarea)) {
          try {
            this.textarea.focus();
          } catch (e2) {
          }
        }
      };
      TextareaInput.prototype.blur = function() {
        this.textarea.blur();
      };
      TextareaInput.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      };
      TextareaInput.prototype.receivedFocus = function() {
        this.slowPoll();
      };
      TextareaInput.prototype.slowPoll = function() {
        var this$1$1 = this;
        if (this.pollingFast) {
          return;
        }
        this.polling.set(this.cm.options.pollInterval, function() {
          this$1$1.poll();
          if (this$1$1.cm.state.focused) {
            this$1$1.slowPoll();
          }
        });
      };
      TextareaInput.prototype.fastPoll = function() {
        var missed = false, input = this;
        input.pollingFast = true;
        function p2() {
          var changed = input.poll();
          if (!changed && !missed) {
            missed = true;
            input.polling.set(60, p2);
          } else {
            input.pollingFast = false;
            input.slowPoll();
          }
        }
        input.polling.set(20, p2);
      };
      TextareaInput.prototype.poll = function() {
        var this$1$1 = this;
        var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
        if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
          return false;
        }
        var text = input.value;
        if (text == prevInput && !cm.somethingSelected()) {
          return false;
        }
        if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
          cm.display.input.reset();
          return false;
        }
        if (cm.doc.sel == cm.display.selForContextMenu) {
          var first = text.charCodeAt(0);
          if (first == 8203 && !prevInput) {
            prevInput = "â€‹";
          }
          if (first == 8666) {
            this.reset();
            return this.cm.execCommand("undo");
          }
        }
        var same = 0, l2 = Math.min(prevInput.length, text.length);
        while (same < l2 && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
          ++same;
        }
        runInOp(cm, function() {
          applyTextInput(
            cm,
            text.slice(same),
            prevInput.length - same,
            null,
            this$1$1.composing ? "*compose" : null
          );
          if (text.length > 1e3 || text.indexOf("\n") > -1) {
            input.value = this$1$1.prevInput = "";
          } else {
            this$1$1.prevInput = text;
          }
          if (this$1$1.composing) {
            this$1$1.composing.range.clear();
            this$1$1.composing.range = cm.markText(
              this$1$1.composing.start,
              cm.getCursor("to"),
              { className: "CodeMirror-composing" }
            );
          }
        });
        return true;
      };
      TextareaInput.prototype.ensurePolled = function() {
        if (this.pollingFast && this.poll()) {
          this.pollingFast = false;
        }
      };
      TextareaInput.prototype.onKeyPress = function() {
        if (ie && ie_version >= 9) {
          this.hasSelection = null;
        }
        this.fastPoll();
      };
      TextareaInput.prototype.onContextMenu = function(e2) {
        var input = this, cm = input.cm, display = cm.display, te = input.textarea;
        if (input.contextMenuPending) {
          input.contextMenuPending();
        }
        var pos = posFromMouse(cm, e2), scrollPos = display.scroller.scrollTop;
        if (!pos || presto) {
          return;
        }
        var reset = cm.options.resetSelectionOnContextMenu;
        if (reset && cm.doc.sel.contains(pos) == -1) {
          operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
        }
        var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
        input.wrapper.style.cssText = "position: static";
        te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e2.clientY - wrapperBox.top - 5) + "px; left: " + (e2.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
        var oldScrollY;
        if (webkit) {
          oldScrollY = te.ownerDocument.defaultView.scrollY;
        }
        display.input.focus();
        if (webkit) {
          te.ownerDocument.defaultView.scrollTo(null, oldScrollY);
        }
        display.input.reset();
        if (!cm.somethingSelected()) {
          te.value = input.prevInput = " ";
        }
        input.contextMenuPending = rehide;
        display.selForContextMenu = cm.doc.sel;
        clearTimeout(display.detectingSelectAll);
        function prepareSelectAllHack() {
          if (te.selectionStart != null) {
            var selected = cm.somethingSelected();
            var extval = "â€‹" + (selected ? te.value : "");
            te.value = "â‡š";
            te.value = extval;
            input.prevInput = selected ? "" : "â€‹";
            te.selectionStart = 1;
            te.selectionEnd = extval.length;
            display.selForContextMenu = cm.doc.sel;
          }
        }
        function rehide() {
          if (input.contextMenuPending != rehide) {
            return;
          }
          input.contextMenuPending = false;
          input.wrapper.style.cssText = oldWrapperCSS;
          te.style.cssText = oldCSS;
          if (ie && ie_version < 9) {
            display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
          }
          if (te.selectionStart != null) {
            if (!ie || ie && ie_version < 9) {
              prepareSelectAllHack();
            }
            var i3 = 0, poll = function() {
              if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "â€‹") {
                operation(cm, selectAll)(cm);
              } else if (i3++ < 10) {
                display.detectingSelectAll = setTimeout(poll, 500);
              } else {
                display.selForContextMenu = null;
                display.input.reset();
              }
            };
            display.detectingSelectAll = setTimeout(poll, 200);
          }
        }
        if (ie && ie_version >= 9) {
          prepareSelectAllHack();
        }
        if (captureRightClick) {
          e_stop(e2);
          var mouseup = function() {
            off(window, "mouseup", mouseup);
            setTimeout(rehide, 20);
          };
          on(window, "mouseup", mouseup);
        } else {
          setTimeout(rehide, 50);
        }
      };
      TextareaInput.prototype.readOnlyChanged = function(val) {
        if (!val) {
          this.reset();
        }
        this.textarea.disabled = val == "nocursor";
        this.textarea.readOnly = !!val;
      };
      TextareaInput.prototype.setUneditable = function() {
      };
      TextareaInput.prototype.needsContentAttribute = false;
      function fromTextArea(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex) {
          options.tabindex = textarea.tabIndex;
        }
        if (!options.placeholder && textarea.placeholder) {
          options.placeholder = textarea.placeholder;
        }
        if (options.autofocus == null) {
          var hasFocus = activeElt(rootNode(textarea));
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }
        function save() {
          textarea.value = cm.getValue();
        }
        var realSubmit;
        if (textarea.form) {
          on(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form;
            realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function() {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e2) {
            }
          }
        }
        options.finishInit = function(cm2) {
          cm2.save = save;
          cm2.getTextArea = function() {
            return textarea;
          };
          cm2.toTextArea = function() {
            cm2.toTextArea = isNaN;
            save();
            textarea.parentNode.removeChild(cm2.getWrapperElement());
            textarea.style.display = "";
            if (textarea.form) {
              off(textarea.form, "submit", save);
              if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                textarea.form.submit = realSubmit;
              }
            }
          };
        };
        textarea.style.display = "none";
        var cm = CodeMirror2(
          function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
          },
          options
        );
        return cm;
      }
      function addLegacyProps(CodeMirror3) {
        CodeMirror3.off = off;
        CodeMirror3.on = on;
        CodeMirror3.wheelEventPixels = wheelEventPixels;
        CodeMirror3.Doc = Doc;
        CodeMirror3.splitLines = splitLinesAuto;
        CodeMirror3.countColumn = countColumn;
        CodeMirror3.findColumn = findColumn;
        CodeMirror3.isWordChar = isWordCharBasic;
        CodeMirror3.Pass = Pass;
        CodeMirror3.signal = signal;
        CodeMirror3.Line = Line;
        CodeMirror3.changeEnd = changeEnd;
        CodeMirror3.scrollbarModel = scrollbarModel;
        CodeMirror3.Pos = Pos;
        CodeMirror3.cmpPos = cmp;
        CodeMirror3.modes = modes;
        CodeMirror3.mimeModes = mimeModes;
        CodeMirror3.resolveMode = resolveMode;
        CodeMirror3.getMode = getMode;
        CodeMirror3.modeExtensions = modeExtensions;
        CodeMirror3.extendMode = extendMode;
        CodeMirror3.copyState = copyState;
        CodeMirror3.startState = startState;
        CodeMirror3.innerMode = innerMode;
        CodeMirror3.commands = commands;
        CodeMirror3.keyMap = keyMap;
        CodeMirror3.keyName = keyName;
        CodeMirror3.isModifierKey = isModifierKey;
        CodeMirror3.lookupKey = lookupKey;
        CodeMirror3.normalizeKeyMap = normalizeKeyMap;
        CodeMirror3.StringStream = StringStream;
        CodeMirror3.SharedTextMarker = SharedTextMarker;
        CodeMirror3.TextMarker = TextMarker;
        CodeMirror3.LineWidget = LineWidget;
        CodeMirror3.e_preventDefault = e_preventDefault;
        CodeMirror3.e_stopPropagation = e_stopPropagation;
        CodeMirror3.e_stop = e_stop;
        CodeMirror3.addClass = addClass;
        CodeMirror3.contains = contains;
        CodeMirror3.rmClass = rmClass;
        CodeMirror3.keyNames = keyNames;
      }
      defineOptions(CodeMirror2);
      addEditorMethods(CodeMirror2);
      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
      for (var prop in Doc.prototype) {
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
          CodeMirror2.prototype[prop] = /* @__PURE__ */ function(method) {
            return function() {
              return method.apply(this.doc, arguments);
            };
          }(Doc.prototype[prop]);
        }
      }
      eventMixin(Doc);
      CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
      CodeMirror2.defineMode = function(name) {
        if (!CodeMirror2.defaults.mode && name != "null") {
          CodeMirror2.defaults.mode = name;
        }
        defineMode.apply(this, arguments);
      };
      CodeMirror2.defineMIME = defineMIME;
      CodeMirror2.defineMode("null", function() {
        return { token: function(stream) {
          return stream.skipToEnd();
        } };
      });
      CodeMirror2.defineMIME("text/plain", "null");
      CodeMirror2.defineExtension = function(name, func) {
        CodeMirror2.prototype[name] = func;
      };
      CodeMirror2.defineDocExtension = function(name, func) {
        Doc.prototype[name] = func;
      };
      CodeMirror2.fromTextArea = fromTextArea;
      addLegacyProps(CodeMirror2);
      CodeMirror2.version = "5.65.20";
      return CodeMirror2;
    });
  })(codemirror);
  var codemirrorExports = codemirror.exports;
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports);
    })(function(CodeMirror2) {
      var listRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]\s|[*+-]\s|(\d+)([.)]))(\s*)/, emptyListRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]|[*+-]|(\d+)[.)])(\s*)$/, unorderedListRE = /[*+-]\s/;
      CodeMirror2.commands.newlineAndIndentContinueMarkdownList = function(cm) {
        if (cm.getOption("disableInput")) return CodeMirror2.Pass;
        var ranges = cm.listSelections(), replacements = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var pos = ranges[i2].head;
          var eolState = cm.getStateAfter(pos.line);
          var inner = CodeMirror2.innerMode(cm.getMode(), eolState);
          if (inner.mode.name !== "markdown" && inner.mode.helperType !== "markdown") {
            cm.execCommand("newlineAndIndent");
            return;
          } else {
            eolState = inner.state;
          }
          var inList = eolState.list !== false;
          var inQuote = eolState.quote !== 0;
          var line = cm.getLine(pos.line), match = listRE.exec(line);
          var cursorBeforeBullet = /^\s*$/.test(line.slice(0, pos.ch));
          if (!ranges[i2].empty() || !inList && !inQuote || !match || cursorBeforeBullet) {
            cm.execCommand("newlineAndIndent");
            return;
          }
          if (emptyListRE.test(line)) {
            var endOfQuote = inQuote && />\s*$/.test(line);
            var endOfList = !/>\s*$/.test(line);
            if (endOfQuote || endOfList) cm.replaceRange("", {
              line: pos.line,
              ch: 0
            }, {
              line: pos.line,
              ch: pos.ch + 1
            });
            replacements[i2] = "\n";
          } else {
            var indent = match[1], after = match[5];
            var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(">") >= 0);
            var bullet = numbered ? parseInt(match[3], 10) + 1 + match[4] : match[2].replace("x", " ");
            replacements[i2] = "\n" + indent + bullet + after;
            if (numbered) incrementRemainingMarkdownListNumbers(cm, pos);
          }
        }
        cm.replaceSelections(replacements);
      };
      function incrementRemainingMarkdownListNumbers(cm, pos) {
        var startLine = pos.line, lookAhead = 0, skipCount = 0;
        var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];
        do {
          lookAhead += 1;
          var nextLineNumber = startLine + lookAhead;
          var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);
          if (nextItem) {
            var nextIndent = nextItem[1];
            var newNumber = parseInt(startItem[3], 10) + lookAhead - skipCount;
            var nextNumber = parseInt(nextItem[3], 10), itemNumber = nextNumber;
            if (startIndent === nextIndent && !isNaN(nextNumber)) {
              if (newNumber === nextNumber) itemNumber = nextNumber + 1;
              if (newNumber > nextNumber) itemNumber = newNumber + 1;
              cm.replaceRange(
                nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]),
                {
                  line: nextLineNumber,
                  ch: 0
                },
                {
                  line: nextLineNumber,
                  ch: nextLine.length
                }
              );
            } else {
              if (startIndent.length > nextIndent.length) return;
              if (startIndent.length < nextIndent.length && lookAhead === 1) return;
              skipCount += 1;
            }
          }
        } while (nextItem);
      }
    });
  })();
  var CodeMirror$1 = codemirrorExports;
  CodeMirror$1.commands.tabAndIndentMarkdownList = function(cm) {
    var ranges = cm.listSelections();
    var pos = ranges[0].head;
    var eolState = cm.getStateAfter(pos.line);
    var inList = eolState.list !== false;
    if (inList) {
      cm.execCommand("indentMore");
      return;
    }
    if (cm.options.indentWithTabs) {
      cm.execCommand("insertTab");
    } else {
      var spaces = Array(cm.options.tabSize + 1).join(" ");
      cm.replaceSelection(spaces);
    }
  };
  CodeMirror$1.commands.shiftTabAndUnindentMarkdownList = function(cm) {
    var ranges = cm.listSelections();
    var pos = ranges[0].head;
    var eolState = cm.getStateAfter(pos.line);
    var inList = eolState.list !== false;
    if (inList) {
      cm.execCommand("indentLess");
      return;
    }
    if (cm.options.indentWithTabs) {
      cm.execCommand("insertTab");
    } else {
      var spaces = Array(cm.options.tabSize + 1).join(" ");
      cm.replaceSelection(spaces);
    }
  };
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports);
    })(function(CodeMirror2) {
      CodeMirror2.defineOption("fullScreen", false, function(cm, val, old) {
        if (old == CodeMirror2.Init) old = false;
        if (!old == !val) return;
        if (val) setFullscreen(cm);
        else setNormal(cm);
      });
      function setFullscreen(cm) {
        var wrap = cm.getWrapperElement();
        cm.state.fullScreenRestore = {
          scrollTop: window.pageYOffset,
          scrollLeft: window.pageXOffset,
          width: wrap.style.width,
          height: wrap.style.height
        };
        wrap.style.width = "";
        wrap.style.height = "auto";
        wrap.className += " CodeMirror-fullscreen";
        document.documentElement.style.overflow = "hidden";
        cm.refresh();
      }
      function setNormal(cm) {
        var wrap = cm.getWrapperElement();
        wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");
        document.documentElement.style.overflow = "";
        var info = cm.state.fullScreenRestore;
        wrap.style.width = info.width;
        wrap.style.height = info.height;
        window.scrollTo(info.scrollLeft, info.scrollTop);
        cm.refresh();
      }
    });
  })();
  var markdown = { exports: {} };
  var xml = { exports: {} };
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports);
    })(function(CodeMirror2) {
      var htmlConfig = {
        autoSelfClosers: {
          "area": true,
          "base": true,
          "br": true,
          "col": true,
          "command": true,
          "embed": true,
          "frame": true,
          "hr": true,
          "img": true,
          "input": true,
          "keygen": true,
          "link": true,
          "meta": true,
          "param": true,
          "source": true,
          "track": true,
          "wbr": true,
          "menuitem": true
        },
        implicitlyClosed: {
          "dd": true,
          "li": true,
          "optgroup": true,
          "option": true,
          "p": true,
          "rp": true,
          "rt": true,
          "tbody": true,
          "td": true,
          "tfoot": true,
          "th": true,
          "tr": true
        },
        contextGrabbers: {
          "dd": { "dd": true, "dt": true },
          "dt": { "dd": true, "dt": true },
          "li": { "li": true },
          "option": { "option": true, "optgroup": true },
          "optgroup": { "optgroup": true },
          "p": {
            "address": true,
            "article": true,
            "aside": true,
            "blockquote": true,
            "dir": true,
            "div": true,
            "dl": true,
            "fieldset": true,
            "footer": true,
            "form": true,
            "h1": true,
            "h2": true,
            "h3": true,
            "h4": true,
            "h5": true,
            "h6": true,
            "header": true,
            "hgroup": true,
            "hr": true,
            "menu": true,
            "nav": true,
            "ol": true,
            "p": true,
            "pre": true,
            "section": true,
            "table": true,
            "ul": true
          },
          "rp": { "rp": true, "rt": true },
          "rt": { "rp": true, "rt": true },
          "tbody": { "tbody": true, "tfoot": true },
          "td": { "td": true, "th": true },
          "tfoot": { "tbody": true },
          "th": { "td": true, "th": true },
          "thead": { "tbody": true, "tfoot": true },
          "tr": { "tr": true }
        },
        doNotIndent: { "pre": true },
        allowUnquoted: true,
        allowMissing: true,
        caseFold: true
      };
      var xmlConfig = {
        autoSelfClosers: {},
        implicitlyClosed: {},
        contextGrabbers: {},
        doNotIndent: {},
        allowUnquoted: false,
        allowMissing: false,
        allowMissingTagName: false,
        caseFold: false
      };
      CodeMirror2.defineMode("xml", function(editorConf, config_) {
        var indentUnit = editorConf.indentUnit;
        var config = {};
        var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
        for (var prop in defaults) config[prop] = defaults[prop];
        for (var prop in config_) config[prop] = config_[prop];
        var type2, setStyle;
        function inText(stream, state) {
          function chain(parser) {
            state.tokenize = parser;
            return parser(stream, state);
          }
          var ch = stream.next();
          if (ch == "<") {
            if (stream.eat("!")) {
              if (stream.eat("[")) {
                if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
                else return null;
              } else if (stream.match("--")) {
                return chain(inBlock("comment", "-->"));
              } else if (stream.match("DOCTYPE", true, true)) {
                stream.eatWhile(/[\w\._\-]/);
                return chain(doctype(1));
              } else {
                return null;
              }
            } else if (stream.eat("?")) {
              stream.eatWhile(/[\w\._\-]/);
              state.tokenize = inBlock("meta", "?>");
              return "meta";
            } else {
              type2 = stream.eat("/") ? "closeTag" : "openTag";
              state.tokenize = inTag;
              return "tag bracket";
            }
          } else if (ch == "&") {
            var ok;
            if (stream.eat("#")) {
              if (stream.eat("x")) {
                ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
              } else {
                ok = stream.eatWhile(/[\d]/) && stream.eat(";");
              }
            } else {
              ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
            }
            return ok ? "atom" : "error";
          } else {
            stream.eatWhile(/[^&<]/);
            return null;
          }
        }
        inText.isInText = true;
        function inTag(stream, state) {
          var ch = stream.next();
          if (ch == ">" || ch == "/" && stream.eat(">")) {
            state.tokenize = inText;
            type2 = ch == ">" ? "endTag" : "selfcloseTag";
            return "tag bracket";
          } else if (ch == "=") {
            type2 = "equals";
            return null;
          } else if (ch == "<") {
            state.tokenize = inText;
            state.state = baseState;
            state.tagName = state.tagStart = null;
            var next = state.tokenize(stream, state);
            return next ? next + " tag error" : "tag error";
          } else if (/[\'\"]/.test(ch)) {
            state.tokenize = inAttribute(ch);
            state.stringStartCol = stream.column();
            return state.tokenize(stream, state);
          } else {
            stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
            return "word";
          }
        }
        function inAttribute(quote) {
          var closure = function(stream, state) {
            while (!stream.eol()) {
              if (stream.next() == quote) {
                state.tokenize = inTag;
                break;
              }
            }
            return "string";
          };
          closure.isInAttribute = true;
          return closure;
        }
        function inBlock(style, terminator) {
          return function(stream, state) {
            while (!stream.eol()) {
              if (stream.match(terminator)) {
                state.tokenize = inText;
                break;
              }
              stream.next();
            }
            return style;
          };
        }
        function doctype(depth) {
          return function(stream, state) {
            var ch;
            while ((ch = stream.next()) != null) {
              if (ch == "<") {
                state.tokenize = doctype(depth + 1);
                return state.tokenize(stream, state);
              } else if (ch == ">") {
                if (depth == 1) {
                  state.tokenize = inText;
                  break;
                } else {
                  state.tokenize = doctype(depth - 1);
                  return state.tokenize(stream, state);
                }
              }
            }
            return "meta";
          };
        }
        function lower2(tagName) {
          return tagName && tagName.toLowerCase();
        }
        function Context(state, tagName, startOfLine) {
          this.prev = state.context;
          this.tagName = tagName || "";
          this.indent = state.indented;
          this.startOfLine = startOfLine;
          if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent)
            this.noIndent = true;
        }
        function popContext(state) {
          if (state.context) state.context = state.context.prev;
        }
        function maybePopContext(state, nextTagName) {
          var parentTagName;
          while (true) {
            if (!state.context) {
              return;
            }
            parentTagName = state.context.tagName;
            if (!config.contextGrabbers.hasOwnProperty(lower2(parentTagName)) || !config.contextGrabbers[lower2(parentTagName)].hasOwnProperty(lower2(nextTagName))) {
              return;
            }
            popContext(state);
          }
        }
        function baseState(type3, stream, state) {
          if (type3 == "openTag") {
            state.tagStart = stream.column();
            return tagNameState;
          } else if (type3 == "closeTag") {
            return closeTagNameState;
          } else {
            return baseState;
          }
        }
        function tagNameState(type3, stream, state) {
          if (type3 == "word") {
            state.tagName = stream.current();
            setStyle = "tag";
            return attrState;
          } else if (config.allowMissingTagName && type3 == "endTag") {
            setStyle = "tag bracket";
            return attrState(type3, stream, state);
          } else {
            setStyle = "error";
            return tagNameState;
          }
        }
        function closeTagNameState(type3, stream, state) {
          if (type3 == "word") {
            var tagName = stream.current();
            if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(lower2(state.context.tagName)))
              popContext(state);
            if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
              setStyle = "tag";
              return closeState;
            } else {
              setStyle = "tag error";
              return closeStateErr;
            }
          } else if (config.allowMissingTagName && type3 == "endTag") {
            setStyle = "tag bracket";
            return closeState(type3, stream, state);
          } else {
            setStyle = "error";
            return closeStateErr;
          }
        }
        function closeState(type3, _stream, state) {
          if (type3 != "endTag") {
            setStyle = "error";
            return closeState;
          }
          popContext(state);
          return baseState;
        }
        function closeStateErr(type3, stream, state) {
          setStyle = "error";
          return closeState(type3, stream, state);
        }
        function attrState(type3, _stream, state) {
          if (type3 == "word") {
            setStyle = "attribute";
            return attrEqState;
          } else if (type3 == "endTag" || type3 == "selfcloseTag") {
            var tagName = state.tagName, tagStart = state.tagStart;
            state.tagName = state.tagStart = null;
            if (type3 == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(lower2(tagName))) {
              maybePopContext(state, tagName);
            } else {
              maybePopContext(state, tagName);
              state.context = new Context(state, tagName, tagStart == state.indented);
            }
            return baseState;
          }
          setStyle = "error";
          return attrState;
        }
        function attrEqState(type3, stream, state) {
          if (type3 == "equals") return attrValueState;
          if (!config.allowMissing) setStyle = "error";
          return attrState(type3, stream, state);
        }
        function attrValueState(type3, stream, state) {
          if (type3 == "string") return attrContinuedState;
          if (type3 == "word" && config.allowUnquoted) {
            setStyle = "string";
            return attrState;
          }
          setStyle = "error";
          return attrState(type3, stream, state);
        }
        function attrContinuedState(type3, stream, state) {
          if (type3 == "string") return attrContinuedState;
          return attrState(type3, stream, state);
        }
        return {
          startState: function(baseIndent) {
            var state = {
              tokenize: inText,
              state: baseState,
              indented: baseIndent || 0,
              tagName: null,
              tagStart: null,
              context: null
            };
            if (baseIndent != null) state.baseIndent = baseIndent;
            return state;
          },
          token: function(stream, state) {
            if (!state.tagName && stream.sol())
              state.indented = stream.indentation();
            if (stream.eatSpace()) return null;
            type2 = null;
            var style = state.tokenize(stream, state);
            if ((style || type2) && style != "comment") {
              setStyle = null;
              state.state = state.state(type2 || style, stream, state);
              if (setStyle)
                style = setStyle == "error" ? style + " error" : setStyle;
            }
            return style;
          },
          indent: function(state, textAfter, fullLine) {
            var context = state.context;
            if (state.tokenize.isInAttribute) {
              if (state.tagStart == state.indented)
                return state.stringStartCol + 1;
              else
                return state.indented + indentUnit;
            }
            if (context && context.noIndent) return CodeMirror2.Pass;
            if (state.tokenize != inTag && state.tokenize != inText)
              return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
            if (state.tagName) {
              if (config.multilineTagIndentPastTag !== false)
                return state.tagStart + state.tagName.length + 2;
              else
                return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
            }
            if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
            var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
            if (tagAfter && tagAfter[1]) {
              while (context) {
                if (context.tagName == tagAfter[2]) {
                  context = context.prev;
                  break;
                } else if (config.implicitlyClosed.hasOwnProperty(lower2(context.tagName))) {
                  context = context.prev;
                } else {
                  break;
                }
              }
            } else if (tagAfter) {
              while (context) {
                var grabbers = config.contextGrabbers[lower2(context.tagName)];
                if (grabbers && grabbers.hasOwnProperty(lower2(tagAfter[2])))
                  context = context.prev;
                else
                  break;
              }
            }
            while (context && context.prev && !context.startOfLine)
              context = context.prev;
            if (context) return context.indent + indentUnit;
            else return state.baseIndent || 0;
          },
          electricInput: /<\/[\s\w:]+>$/,
          blockCommentStart: "<!--",
          blockCommentEnd: "-->",
          configuration: config.htmlMode ? "html" : "xml",
          helperType: config.htmlMode ? "html" : "xml",
          skipAttribute: function(state) {
            if (state.state == attrValueState)
              state.state = attrState;
          },
          xmlCurrentTag: function(state) {
            return state.tagName ? { name: state.tagName, close: state.type == "closeTag" } : null;
          },
          xmlCurrentContext: function(state) {
            var context = [];
            for (var cx = state.context; cx; cx = cx.prev)
              context.push(cx.tagName);
            return context.reverse();
          }
        };
      });
      CodeMirror2.defineMIME("text/xml", "xml");
      CodeMirror2.defineMIME("application/xml", "xml");
      if (!CodeMirror2.mimeModes.hasOwnProperty("text/html"))
        CodeMirror2.defineMIME("text/html", { name: "xml", htmlMode: true });
    });
  })();
  var xmlExports = xml.exports;
  var meta = { exports: {} };
  var hasRequiredMeta;
  function requireMeta() {
    if (hasRequiredMeta) return meta.exports;
    hasRequiredMeta = 1;
    (function(module, exports$1) {
      (function(mod) {
        mod(codemirrorExports);
      })(function(CodeMirror2) {
        CodeMirror2.modeInfo = [
          { name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] },
          { name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"] },
          { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] },
          { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i },
          { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] },
          { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"] },
          { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] },
          { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy", "cbl"] },
          { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"] },
          { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"] },
          { name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"] },
          { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] },
          { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/ },
          { name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] },
          { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] },
          { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] },
          { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] },
          { name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"] },
          { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] },
          { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] },
          { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] },
          { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] },
          { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] },
          { name: "Django", mime: "text/x-django", mode: "django" },
          { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ },
          { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] },
          { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] },
          { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" },
          { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] },
          { name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"] },
          { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] },
          { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] },
          { name: "Embedded JavaScript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] },
          { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] },
          { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] },
          { name: "Esper", mime: "text/x-esper", mode: "sql" },
          { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] },
          { name: "FCL", mime: "text/x-fcl", mode: "fcl" },
          { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] },
          { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"] },
          { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] },
          { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] },
          { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] },
          { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i },
          { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] },
          { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/ },
          { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] },
          { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] },
          { name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"] },
          { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] },
          { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] },
          { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] },
          { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"] },
          { name: "HTTP", mime: "message/http", mode: "http" },
          { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] },
          { name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"] },
          { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] },
          { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] },
          {
            name: "JavaScript",
            mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
            mode: "javascript",
            ext: ["js"],
            alias: ["ecmascript", "js", "node"]
          },
          { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] },
          { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] },
          { name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"] },
          { name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"] },
          { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"], alias: ["jl"] },
          { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] },
          { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] },
          { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] },
          { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] },
          { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] },
          { name: "mIRC", mime: "text/mirc", mode: "mirc" },
          { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" },
          { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"] },
          { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] },
          { name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"] },
          { name: "MS SQL", mime: "text/x-mssql", mode: "sql" },
          { name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"] },
          { name: "MySQL", mime: "text/x-mysql", mode: "sql" },
          { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i },
          { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] },
          {
            name: "NTriples",
            mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
            mode: "ntriples",
            ext: ["nt", "nq"]
          },
          { name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"] },
          { name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"] },
          { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] },
          { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] },
          { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] },
          { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] },
          { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] },
          { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] },
          { name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"] },
          { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] },
          { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] },
          { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] },
          { name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql" },
          { name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"] },
          { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] },
          { name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"] },
          { name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/ },
          { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] },
          { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] },
          { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"] },
          { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] },
          { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" },
          { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] },
          { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] },
          { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] },
          { name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"] },
          { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] },
          { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] },
          { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] },
          { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] },
          { name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ },
          { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] },
          { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] },
          { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] },
          { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] },
          { name: "Solr", mime: "text/x-solr", mode: "solr" },
          { name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"] },
          { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] },
          { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] },
          { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] },
          { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] },
          { name: "SQLite", mime: "text/x-sqlite", mode: "sql" },
          { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] },
          { name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"] },
          { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] },
          { name: "sTeX", mime: "text/x-stex", mode: "stex" },
          { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"] },
          { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"] },
          { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] },
          { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] },
          { name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki" },
          { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" },
          { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] },
          { name: "Tornado", mime: "text/x-tornado", mode: "tornado" },
          { name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] },
          { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] },
          { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] },
          { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] },
          { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] },
          { name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"] },
          { name: "Twig", mime: "text/x-twig", mode: "twig" },
          { name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"] },
          { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] },
          { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] },
          { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] },
          { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] },
          { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] },
          { name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"] },
          { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"] },
          { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] },
          { name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"] },
          { name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] },
          { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] },
          { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] },
          { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] },
          { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] },
          { name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"] }
        ];
        for (var i2 = 0; i2 < CodeMirror2.modeInfo.length; i2++) {
          var info = CodeMirror2.modeInfo[i2];
          if (info.mimes) info.mime = info.mimes[0];
        }
        CodeMirror2.findModeByMIME = function(mime) {
          mime = mime.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror2.modeInfo.length; i3++) {
            var info2 = CodeMirror2.modeInfo[i3];
            if (info2.mime == mime) return info2;
            if (info2.mimes) {
              for (var j2 = 0; j2 < info2.mimes.length; j2++)
                if (info2.mimes[j2] == mime) return info2;
            }
          }
          if (/\+xml$/.test(mime)) return CodeMirror2.findModeByMIME("application/xml");
          if (/\+json$/.test(mime)) return CodeMirror2.findModeByMIME("application/json");
        };
        CodeMirror2.findModeByExtension = function(ext) {
          ext = ext.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror2.modeInfo.length; i3++) {
            var info2 = CodeMirror2.modeInfo[i3];
            if (info2.ext) {
              for (var j2 = 0; j2 < info2.ext.length; j2++)
                if (info2.ext[j2] == ext) return info2;
            }
          }
        };
        CodeMirror2.findModeByFileName = function(filename) {
          for (var i3 = 0; i3 < CodeMirror2.modeInfo.length; i3++) {
            var info2 = CodeMirror2.modeInfo[i3];
            if (info2.file && info2.file.test(filename)) return info2;
          }
          var dot = filename.lastIndexOf(".");
          var ext = dot > -1 && filename.substring(dot + 1, filename.length);
          if (ext) return CodeMirror2.findModeByExtension(ext);
        };
        CodeMirror2.findModeByName = function(name) {
          name = name.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror2.modeInfo.length; i3++) {
            var info2 = CodeMirror2.modeInfo[i3];
            if (info2.name.toLowerCase() == name) return info2;
            if (info2.alias) {
              for (var j2 = 0; j2 < info2.alias.length; j2++)
                if (info2.alias[j2].toLowerCase() == name) return info2;
            }
          }
        };
      });
    })();
    return meta.exports;
  }
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports, xmlExports, requireMeta());
    })(function(CodeMirror2) {
      CodeMirror2.defineMode("markdown", function(cmCfg, modeCfg) {
        var htmlMode = CodeMirror2.getMode(cmCfg, "text/html");
        var htmlModeMissing = htmlMode.name == "null";
        function getMode(name) {
          if (CodeMirror2.findModeByName) {
            var found = CodeMirror2.findModeByName(name);
            if (found) name = found.mime || found.mimes[0];
          }
          var mode2 = CodeMirror2.getMode(cmCfg, name);
          return mode2.name == "null" ? null : mode2;
        }
        if (modeCfg.highlightFormatting === void 0)
          modeCfg.highlightFormatting = false;
        if (modeCfg.maxBlockquoteDepth === void 0)
          modeCfg.maxBlockquoteDepth = 0;
        if (modeCfg.taskLists === void 0) modeCfg.taskLists = false;
        if (modeCfg.strikethrough === void 0)
          modeCfg.strikethrough = false;
        if (modeCfg.emoji === void 0)
          modeCfg.emoji = false;
        if (modeCfg.fencedCodeBlockHighlighting === void 0)
          modeCfg.fencedCodeBlockHighlighting = true;
        if (modeCfg.fencedCodeBlockDefaultMode === void 0)
          modeCfg.fencedCodeBlockDefaultMode = "text/plain";
        if (modeCfg.xml === void 0)
          modeCfg.xml = true;
        if (modeCfg.tokenTypeOverrides === void 0)
          modeCfg.tokenTypeOverrides = {};
        var tokenTypes = {
          header: "header",
          code: "comment",
          quote: "quote",
          list1: "variable-2",
          list2: "variable-3",
          list3: "keyword",
          hr: "hr",
          image: "image",
          imageAltText: "image-alt-text",
          imageMarker: "image-marker",
          formatting: "formatting",
          linkInline: "link",
          linkEmail: "link",
          linkText: "link",
          linkHref: "string",
          em: "em",
          strong: "strong",
          strikethrough: "strikethrough",
          emoji: "builtin"
        };
        for (var tokenType in tokenTypes) {
          if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
            tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
          }
        }
        var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/, listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/, taskListRE = /^\[(x| )\](?=\s)/i, atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, setextHeaderRE = /^ {0,3}(?:\={1,}|-{2,})\s*$/, textRE = /^[^#!\[\]*_\\<>` "'(~:]+/, fencedCodeRE = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/, linkDefRE = /^\s*\[[^\]]+?\]:.*$/, punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/, expandedTab = "    ";
        function switchInline(stream, state, f2) {
          state.f = state.inline = f2;
          return f2(stream, state);
        }
        function switchBlock(stream, state, f2) {
          state.f = state.block = f2;
          return f2(stream, state);
        }
        function lineIsEmpty(line) {
          return !line || !/\S/.test(line.string);
        }
        function blankLine(state) {
          state.linkTitle = false;
          state.linkHref = false;
          state.linkText = false;
          state.em = false;
          state.strong = false;
          state.strikethrough = false;
          state.quote = 0;
          state.indentedCode = false;
          if (state.f == htmlBlock) {
            var exit = htmlModeMissing;
            if (!exit) {
              var inner = CodeMirror2.innerMode(htmlMode, state.htmlState);
              exit = inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText);
            }
            if (exit) {
              state.f = inlineNormal;
              state.block = blockNormal;
              state.htmlState = null;
            }
          }
          state.trailingSpace = 0;
          state.trailingSpaceNewLine = false;
          state.prevLine = state.thisLine;
          state.thisLine = { stream: null };
          return null;
        }
        function blockNormal(stream, state) {
          var firstTokenOnLine = stream.column() === state.indentation;
          var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
          var prevLineIsIndentedCode = state.indentedCode;
          var prevLineIsHr = state.prevLine.hr;
          var prevLineIsList = state.list !== false;
          var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;
          state.indentedCode = false;
          var lineIndentation = state.indentation;
          if (state.indentationDiff === null) {
            state.indentationDiff = state.indentation;
            if (prevLineIsList) {
              state.list = null;
              while (lineIndentation < state.listStack[state.listStack.length - 1]) {
                state.listStack.pop();
                if (state.listStack.length) {
                  state.indentation = state.listStack[state.listStack.length - 1];
                } else {
                  state.list = false;
                }
              }
              if (state.list !== false) {
                state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1];
              }
            }
          }
          var allowsInlineContinuation = !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header && (!prevLineIsList || !prevLineIsIndentedCode) && !state.prevLine.fencedCodeEnd;
          var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) && state.indentation <= maxNonCodeIndentation && stream.match(hrRE);
          var match = null;
          if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd || state.prevLine.header || prevLineLineIsEmpty)) {
            stream.skipToEnd();
            state.indentedCode = true;
            return tokenTypes.code;
          } else if (stream.eatSpace()) {
            return null;
          } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
            state.quote = 0;
            state.header = match[1].length;
            state.thisLine.header = true;
            if (modeCfg.highlightFormatting) state.formatting = "header";
            state.f = state.inline;
            return getType(state);
          } else if (state.indentation <= maxNonCodeIndentation && stream.eat(">")) {
            state.quote = firstTokenOnLine ? 1 : state.quote + 1;
            if (modeCfg.highlightFormatting) state.formatting = "quote";
            stream.eatSpace();
            return getType(state);
          } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
            var listType = match[1] ? "ol" : "ul";
            state.indentation = lineIndentation + stream.current().length;
            state.list = true;
            state.quote = 0;
            state.listStack.push(state.indentation);
            state.em = false;
            state.strong = false;
            state.code = false;
            state.strikethrough = false;
            if (modeCfg.taskLists && stream.match(taskListRE, false)) {
              state.taskList = true;
            }
            state.f = state.inline;
            if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
            return getType(state);
          } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
            state.quote = 0;
            state.fencedEndRE = new RegExp(match[1] + "+ *$");
            state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2] || modeCfg.fencedCodeBlockDefaultMode);
            if (state.localMode) state.localState = CodeMirror2.startState(state.localMode);
            state.f = state.block = local;
            if (modeCfg.highlightFormatting) state.formatting = "code-block";
            state.code = -1;
            return getType(state);
          } else if (
            // if setext set, indicates line after ---/===
            state.setext || // line before ---/===
            (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false && !state.code && !isHr && !linkDefRE.test(stream.string) && (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))
          ) {
            if (!state.setext) {
              state.header = match[0].charAt(0) == "=" ? 1 : 2;
              state.setext = state.header;
            } else {
              state.header = state.setext;
              state.setext = 0;
              stream.skipToEnd();
              if (modeCfg.highlightFormatting) state.formatting = "header";
            }
            state.thisLine.header = true;
            state.f = state.inline;
            return getType(state);
          } else if (isHr) {
            stream.skipToEnd();
            state.hr = true;
            state.thisLine.hr = true;
            return tokenTypes.hr;
          } else if (stream.peek() === "[") {
            return switchInline(stream, state, footnoteLink);
          }
          return switchInline(stream, state, state.inline);
        }
        function htmlBlock(stream, state) {
          var style = htmlMode.token(stream, state.htmlState);
          if (!htmlModeMissing) {
            var inner = CodeMirror2.innerMode(htmlMode, state.htmlState);
            if (inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText) || state.md_inside && stream.current().indexOf(">") > -1) {
              state.f = inlineNormal;
              state.block = blockNormal;
              state.htmlState = null;
            }
          }
          return style;
        }
        function local(stream, state) {
          var currListInd = state.listStack[state.listStack.length - 1] || 0;
          var hasExitedList = state.indentation < currListInd;
          var maxFencedEndInd = currListInd + 3;
          if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
            if (modeCfg.highlightFormatting) state.formatting = "code-block";
            var returnType;
            if (!hasExitedList) returnType = getType(state);
            state.localMode = state.localState = null;
            state.block = blockNormal;
            state.f = inlineNormal;
            state.fencedEndRE = null;
            state.code = 0;
            state.thisLine.fencedCodeEnd = true;
            if (hasExitedList) return switchBlock(stream, state, state.block);
            return returnType;
          } else if (state.localMode) {
            return state.localMode.token(stream, state.localState);
          } else {
            stream.skipToEnd();
            return tokenTypes.code;
          }
        }
        function getType(state) {
          var styles = [];
          if (state.formatting) {
            styles.push(tokenTypes.formatting);
            if (typeof state.formatting === "string") state.formatting = [state.formatting];
            for (var i2 = 0; i2 < state.formatting.length; i2++) {
              styles.push(tokenTypes.formatting + "-" + state.formatting[i2]);
              if (state.formatting[i2] === "header") {
                styles.push(tokenTypes.formatting + "-" + state.formatting[i2] + "-" + state.header);
              }
              if (state.formatting[i2] === "quote") {
                if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                  styles.push(tokenTypes.formatting + "-" + state.formatting[i2] + "-" + state.quote);
                } else {
                  styles.push("error");
                }
              }
            }
          }
          if (state.taskOpen) {
            styles.push("meta");
            return styles.length ? styles.join(" ") : null;
          }
          if (state.taskClosed) {
            styles.push("property");
            return styles.length ? styles.join(" ") : null;
          }
          if (state.linkHref) {
            styles.push(tokenTypes.linkHref, "url");
          } else {
            if (state.strong) {
              styles.push(tokenTypes.strong);
            }
            if (state.em) {
              styles.push(tokenTypes.em);
            }
            if (state.strikethrough) {
              styles.push(tokenTypes.strikethrough);
            }
            if (state.emoji) {
              styles.push(tokenTypes.emoji);
            }
            if (state.linkText) {
              styles.push(tokenTypes.linkText);
            }
            if (state.code) {
              styles.push(tokenTypes.code);
            }
            if (state.image) {
              styles.push(tokenTypes.image);
            }
            if (state.imageAltText) {
              styles.push(tokenTypes.imageAltText, "link");
            }
            if (state.imageMarker) {
              styles.push(tokenTypes.imageMarker);
            }
          }
          if (state.header) {
            styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header);
          }
          if (state.quote) {
            styles.push(tokenTypes.quote);
            if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
              styles.push(tokenTypes.quote + "-" + state.quote);
            } else {
              styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
            }
          }
          if (state.list !== false) {
            var listMod = (state.listStack.length - 1) % 3;
            if (!listMod) {
              styles.push(tokenTypes.list1);
            } else if (listMod === 1) {
              styles.push(tokenTypes.list2);
            } else {
              styles.push(tokenTypes.list3);
            }
          }
          if (state.trailingSpaceNewLine) {
            styles.push("trailing-space-new-line");
          } else if (state.trailingSpace) {
            styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
          }
          return styles.length ? styles.join(" ") : null;
        }
        function handleText(stream, state) {
          if (stream.match(textRE, true)) {
            return getType(state);
          }
          return void 0;
        }
        function inlineNormal(stream, state) {
          var style = state.text(stream, state);
          if (typeof style !== "undefined")
            return style;
          if (state.list) {
            state.list = null;
            return getType(state);
          }
          if (state.taskList) {
            var taskOpen = stream.match(taskListRE, true)[1] === " ";
            if (taskOpen) state.taskOpen = true;
            else state.taskClosed = true;
            if (modeCfg.highlightFormatting) state.formatting = "task";
            state.taskList = false;
            return getType(state);
          }
          state.taskOpen = false;
          state.taskClosed = false;
          if (state.header && stream.match(/^#+$/, true)) {
            if (modeCfg.highlightFormatting) state.formatting = "header";
            return getType(state);
          }
          var ch = stream.next();
          if (state.linkTitle) {
            state.linkTitle = false;
            var matchCh = ch;
            if (ch === "(") {
              matchCh = ")";
            }
            matchCh = (matchCh + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
            var regex = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;
            if (stream.match(new RegExp(regex), true)) {
              return tokenTypes.linkHref;
            }
          }
          if (ch === "`") {
            var previousFormatting = state.formatting;
            if (modeCfg.highlightFormatting) state.formatting = "code";
            stream.eatWhile("`");
            var count = stream.current().length;
            if (state.code == 0 && (!state.quote || count == 1)) {
              state.code = count;
              return getType(state);
            } else if (count == state.code) {
              var t2 = getType(state);
              state.code = 0;
              return t2;
            } else {
              state.formatting = previousFormatting;
              return getType(state);
            }
          } else if (state.code) {
            return getType(state);
          }
          if (ch === "\\") {
            stream.next();
            if (modeCfg.highlightFormatting) {
              var type2 = getType(state);
              var formattingEscape = tokenTypes.formatting + "-escape";
              return type2 ? type2 + " " + formattingEscape : formattingEscape;
            }
          }
          if (ch === "!" && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
            state.imageMarker = true;
            state.image = true;
            if (modeCfg.highlightFormatting) state.formatting = "image";
            return getType(state);
          }
          if (ch === "[" && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
            state.imageMarker = false;
            state.imageAltText = true;
            if (modeCfg.highlightFormatting) state.formatting = "image";
            return getType(state);
          }
          if (ch === "]" && state.imageAltText) {
            if (modeCfg.highlightFormatting) state.formatting = "image";
            var type2 = getType(state);
            state.imageAltText = false;
            state.image = false;
            state.inline = state.f = linkHref;
            return type2;
          }
          if (ch === "[" && !state.image) {
            if (state.linkText && stream.match(/^.*?\]/)) return getType(state);
            state.linkText = true;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            return getType(state);
          }
          if (ch === "]" && state.linkText) {
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type2 = getType(state);
            state.linkText = false;
            state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal;
            return type2;
          }
          if (ch === "<" && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
            state.f = state.inline = linkInline;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type2 = getType(state);
            if (type2) {
              type2 += " ";
            } else {
              type2 = "";
            }
            return type2 + tokenTypes.linkInline;
          }
          if (ch === "<" && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
            state.f = state.inline = linkInline;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type2 = getType(state);
            if (type2) {
              type2 += " ";
            } else {
              type2 = "";
            }
            return type2 + tokenTypes.linkEmail;
          }
          if (modeCfg.xml && ch === "<" && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
            var end = stream.string.indexOf(">", stream.pos);
            if (end != -1) {
              var atts = stream.string.substring(stream.start, end);
              if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
            }
            stream.backUp(1);
            state.htmlState = CodeMirror2.startState(htmlMode);
            return switchBlock(stream, state, htmlBlock);
          }
          if (modeCfg.xml && ch === "<" && stream.match(/^\/\w*?>/)) {
            state.md_inside = false;
            return "tag";
          } else if (ch === "*" || ch === "_") {
            var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2);
            while (len < 3 && stream.eat(ch)) len++;
            var after = stream.peek() || " ";
            var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before));
            var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after));
            var setEm = null, setStrong = null;
            if (len % 2) {
              if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
                setEm = true;
              else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
                setEm = false;
            }
            if (len > 1) {
              if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
                setStrong = true;
              else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
                setStrong = false;
            }
            if (setStrong != null || setEm != null) {
              if (modeCfg.highlightFormatting) state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em";
              if (setEm === true) state.em = ch;
              if (setStrong === true) state.strong = ch;
              var t2 = getType(state);
              if (setEm === false) state.em = false;
              if (setStrong === false) state.strong = false;
              return t2;
            }
          } else if (ch === " ") {
            if (stream.eat("*") || stream.eat("_")) {
              if (stream.peek() === " ") {
                return getType(state);
              } else {
                stream.backUp(1);
              }
            }
          }
          if (modeCfg.strikethrough) {
            if (ch === "~" && stream.eatWhile(ch)) {
              if (state.strikethrough) {
                if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
                var t2 = getType(state);
                state.strikethrough = false;
                return t2;
              } else if (stream.match(/^[^\s]/, false)) {
                state.strikethrough = true;
                if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
                return getType(state);
              }
            } else if (ch === " ") {
              if (stream.match("~~", true)) {
                if (stream.peek() === " ") {
                  return getType(state);
                } else {
                  stream.backUp(2);
                }
              }
            }
          }
          if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
            state.emoji = true;
            if (modeCfg.highlightFormatting) state.formatting = "emoji";
            var retType = getType(state);
            state.emoji = false;
            return retType;
          }
          if (ch === " ") {
            if (stream.match(/^ +$/, false)) {
              state.trailingSpace++;
            } else if (state.trailingSpace) {
              state.trailingSpaceNewLine = true;
            }
          }
          return getType(state);
        }
        function linkInline(stream, state) {
          var ch = stream.next();
          if (ch === ">") {
            state.f = state.inline = inlineNormal;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var type2 = getType(state);
            if (type2) {
              type2 += " ";
            } else {
              type2 = "";
            }
            return type2 + tokenTypes.linkInline;
          }
          stream.match(/^[^>]+/, true);
          return tokenTypes.linkInline;
        }
        function linkHref(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }
          var ch = stream.next();
          if (ch === "(" || ch === "[") {
            state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
            if (modeCfg.highlightFormatting) state.formatting = "link-string";
            state.linkHref = true;
            return getType(state);
          }
          return "error";
        }
        var linkRE = {
          ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
          "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
        };
        function getLinkHrefInside(endChar) {
          return function(stream, state) {
            var ch = stream.next();
            if (ch === endChar) {
              state.f = state.inline = inlineNormal;
              if (modeCfg.highlightFormatting) state.formatting = "link-string";
              var returnState = getType(state);
              state.linkHref = false;
              return returnState;
            }
            stream.match(linkRE[endChar]);
            state.linkHref = true;
            return getType(state);
          };
        }
        function footnoteLink(stream, state) {
          if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
            state.f = footnoteLinkInside;
            stream.next();
            if (modeCfg.highlightFormatting) state.formatting = "link";
            state.linkText = true;
            return getType(state);
          }
          return switchInline(stream, state, inlineNormal);
        }
        function footnoteLinkInside(stream, state) {
          if (stream.match("]:", true)) {
            state.f = state.inline = footnoteUrl;
            if (modeCfg.highlightFormatting) state.formatting = "link";
            var returnType = getType(state);
            state.linkText = false;
            return returnType;
          }
          stream.match(/^([^\]\\]|\\.)+/, true);
          return tokenTypes.linkText;
        }
        function footnoteUrl(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }
          stream.match(/^[^\s]+/, true);
          if (stream.peek() === void 0) {
            state.linkTitle = true;
          } else {
            stream.match(/^(?:\s+(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, true);
          }
          state.f = state.inline = inlineNormal;
          return tokenTypes.linkHref + " url";
        }
        var mode = {
          startState: function() {
            return {
              f: blockNormal,
              prevLine: { stream: null },
              thisLine: { stream: null },
              block: blockNormal,
              htmlState: null,
              indentation: 0,
              inline: inlineNormal,
              text: handleText,
              formatting: false,
              linkText: false,
              linkHref: false,
              linkTitle: false,
              code: 0,
              em: false,
              strong: false,
              header: 0,
              setext: 0,
              hr: false,
              taskList: false,
              list: false,
              listStack: [],
              quote: 0,
              trailingSpace: 0,
              trailingSpaceNewLine: false,
              strikethrough: false,
              emoji: false,
              fencedEndRE: null
            };
          },
          copyState: function(s2) {
            return {
              f: s2.f,
              prevLine: s2.prevLine,
              thisLine: s2.thisLine,
              block: s2.block,
              htmlState: s2.htmlState && CodeMirror2.copyState(htmlMode, s2.htmlState),
              indentation: s2.indentation,
              localMode: s2.localMode,
              localState: s2.localMode ? CodeMirror2.copyState(s2.localMode, s2.localState) : null,
              inline: s2.inline,
              text: s2.text,
              formatting: false,
              linkText: s2.linkText,
              linkTitle: s2.linkTitle,
              linkHref: s2.linkHref,
              code: s2.code,
              em: s2.em,
              strong: s2.strong,
              strikethrough: s2.strikethrough,
              emoji: s2.emoji,
              header: s2.header,
              setext: s2.setext,
              hr: s2.hr,
              taskList: s2.taskList,
              list: s2.list,
              listStack: s2.listStack.slice(0),
              quote: s2.quote,
              indentedCode: s2.indentedCode,
              trailingSpace: s2.trailingSpace,
              trailingSpaceNewLine: s2.trailingSpaceNewLine,
              md_inside: s2.md_inside,
              fencedEndRE: s2.fencedEndRE
            };
          },
          token: function(stream, state) {
            state.formatting = false;
            if (stream != state.thisLine.stream) {
              state.header = 0;
              state.hr = false;
              if (stream.match(/^\s*$/, true)) {
                blankLine(state);
                return null;
              }
              state.prevLine = state.thisLine;
              state.thisLine = { stream };
              state.taskList = false;
              state.trailingSpace = 0;
              state.trailingSpaceNewLine = false;
              if (!state.localState) {
                state.f = state.block;
                if (state.f != htmlBlock) {
                  var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
                  state.indentation = indentation;
                  state.indentationDiff = null;
                  if (indentation > 0) return null;
                }
              }
            }
            return state.f(stream, state);
          },
          innerMode: function(state) {
            if (state.block == htmlBlock) return { state: state.htmlState, mode: htmlMode };
            if (state.localState) return { state: state.localState, mode: state.localMode };
            return { state, mode };
          },
          indent: function(state, textAfter, line) {
            if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line);
            if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line);
            return CodeMirror2.Pass;
          },
          blankLine,
          getType,
          blockCommentStart: "<!--",
          blockCommentEnd: "-->",
          closeBrackets: "()[]{}''\"\"``",
          fold: "markdown"
        };
        return mode;
      }, "xml");
      CodeMirror2.defineMIME("text/markdown", "markdown");
      CodeMirror2.defineMIME("text/x-markdown", "markdown");
    });
  })();
  var markdownExports = markdown.exports;
  var overlay = { exports: {} };
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports);
    })(function(CodeMirror2) {
      CodeMirror2.overlayMode = function(base, overlay2, combine) {
        return {
          startState: function() {
            return {
              base: CodeMirror2.startState(base),
              overlay: CodeMirror2.startState(overlay2),
              basePos: 0,
              baseCur: null,
              overlayPos: 0,
              overlayCur: null,
              streamSeen: null
            };
          },
          copyState: function(state) {
            return {
              base: CodeMirror2.copyState(base, state.base),
              overlay: CodeMirror2.copyState(overlay2, state.overlay),
              basePos: state.basePos,
              baseCur: null,
              overlayPos: state.overlayPos,
              overlayCur: null
            };
          },
          token: function(stream, state) {
            if (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) {
              state.streamSeen = stream;
              state.basePos = state.overlayPos = stream.start;
            }
            if (stream.start == state.basePos) {
              state.baseCur = base.token(stream, state.base);
              state.basePos = stream.pos;
            }
            if (stream.start == state.overlayPos) {
              stream.pos = stream.start;
              state.overlayCur = overlay2.token(stream, state.overlay);
              state.overlayPos = stream.pos;
            }
            stream.pos = Math.min(state.basePos, state.overlayPos);
            if (state.overlayCur == null) return state.baseCur;
            else if (state.baseCur != null && state.overlay.combineTokens || combine && state.overlay.combineTokens == null)
              return state.baseCur + " " + state.overlayCur;
            else return state.overlayCur;
          },
          indent: base.indent && function(state, textAfter, line) {
            return base.indent(state.base, textAfter, line);
          },
          electricChars: base.electricChars,
          innerMode: function(state) {
            return { state: state.base, mode: base };
          },
          blankLine: function(state) {
            var baseToken, overlayToken;
            if (base.blankLine) baseToken = base.blankLine(state.base);
            if (overlay2.blankLine) overlayToken = overlay2.blankLine(state.overlay);
            return overlayToken == null ? baseToken : combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken;
          }
        };
      };
    });
  })();
  var overlayExports = overlay.exports;
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports);
    })(function(CodeMirror2) {
      CodeMirror2.defineOption("placeholder", "", function(cm, val, old) {
        var prev = old && old != CodeMirror2.Init;
        if (val && !prev) {
          cm.on("blur", onBlur);
          cm.on("change", onChange);
          cm.on("swapDoc", onChange);
          CodeMirror2.on(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose = function() {
            onComposition(cm);
          });
          onChange(cm);
        } else if (!val && prev) {
          cm.off("blur", onBlur);
          cm.off("change", onChange);
          cm.off("swapDoc", onChange);
          CodeMirror2.off(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose);
          clearPlaceholder(cm);
          var wrapper = cm.getWrapperElement();
          wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
        }
        if (val && !cm.hasFocus()) onBlur(cm);
      });
      function clearPlaceholder(cm) {
        if (cm.state.placeholder) {
          cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
          cm.state.placeholder = null;
        }
      }
      function setPlaceholder(cm) {
        clearPlaceholder(cm);
        var elt = cm.state.placeholder = document.createElement("pre");
        elt.style.cssText = "height: 0; overflow: visible";
        elt.style.direction = cm.getOption("direction");
        elt.className = "CodeMirror-placeholder CodeMirror-line-like";
        var placeHolder = cm.getOption("placeholder");
        if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder);
        elt.appendChild(placeHolder);
        cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
      }
      function onComposition(cm) {
        setTimeout(function() {
          var empty2 = false;
          if (cm.lineCount() == 1) {
            var input = cm.getInputField();
            empty2 = input.nodeName == "TEXTAREA" ? !cm.getLine(0).length : !/[^\u200b]/.test(input.querySelector(".CodeMirror-line").textContent);
          }
          if (empty2) setPlaceholder(cm);
          else clearPlaceholder(cm);
        }, 20);
      }
      function onBlur(cm) {
        if (isEmpty(cm)) setPlaceholder(cm);
      }
      function onChange(cm) {
        var wrapper = cm.getWrapperElement(), empty2 = isEmpty(cm);
        wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty2 ? " CodeMirror-empty" : "");
        if (empty2) setPlaceholder(cm);
        else clearPlaceholder(cm);
      }
      function isEmpty(cm) {
        return cm.lineCount() === 1 && cm.getLine(0) === "";
      }
    });
  })();
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports);
    })(function(CodeMirror2) {
      CodeMirror2.defineOption("autoRefresh", false, function(cm, val) {
        if (cm.state.autoRefresh) {
          stopListening(cm, cm.state.autoRefresh);
          cm.state.autoRefresh = null;
        }
        if (val && cm.display.wrapper.offsetHeight == 0)
          startListening(cm, cm.state.autoRefresh = { delay: val.delay || 250 });
      });
      function startListening(cm, state) {
        function check2() {
          if (cm.display.wrapper.offsetHeight) {
            stopListening(cm, state);
            if (cm.display.lastWrapHeight != cm.display.wrapper.clientHeight)
              cm.refresh();
          } else {
            state.timeout = setTimeout(check2, state.delay);
          }
        }
        state.timeout = setTimeout(check2, state.delay);
        state.hurry = function() {
          clearTimeout(state.timeout);
          state.timeout = setTimeout(check2, 50);
        };
        CodeMirror2.on(window, "mouseup", state.hurry);
        CodeMirror2.on(window, "keyup", state.hurry);
      }
      function stopListening(_cm, state) {
        clearTimeout(state.timeout);
        CodeMirror2.off(window, "mouseup", state.hurry);
        CodeMirror2.off(window, "keyup", state.hurry);
      }
    });
  })();
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports);
    })(function(CodeMirror2) {
      CodeMirror2.defineOption("styleSelectedText", false, function(cm, val, old) {
        var prev = old && old != CodeMirror2.Init;
        if (val && !prev) {
          cm.state.markedSelection = [];
          cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
          reset(cm);
          cm.on("cursorActivity", onCursorActivity);
          cm.on("change", onChange);
        } else if (!val && prev) {
          cm.off("cursorActivity", onCursorActivity);
          cm.off("change", onChange);
          clear(cm);
          cm.state.markedSelection = cm.state.markedSelectionStyle = null;
        }
      });
      function onCursorActivity(cm) {
        if (cm.state.markedSelection)
          cm.operation(function() {
            update(cm);
          });
      }
      function onChange(cm) {
        if (cm.state.markedSelection && cm.state.markedSelection.length)
          cm.operation(function() {
            clear(cm);
          });
      }
      var CHUNK_SIZE = 8;
      var Pos = CodeMirror2.Pos;
      var cmp = CodeMirror2.cmpPos;
      function coverRange(cm, from, to, addAt) {
        if (cmp(from, to) == 0) return;
        var array2 = cm.state.markedSelection;
        var cls = cm.state.markedSelectionStyle;
        for (var line = from.line; ; ) {
          var start2 = line == from.line ? from : Pos(line, 0);
          var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;
          var end = atEnd ? to : Pos(endLine, 0);
          var mark = cm.markText(start2, end, { className: cls });
          if (addAt == null) array2.push(mark);
          else array2.splice(addAt++, 0, mark);
          if (atEnd) break;
          line = endLine;
        }
      }
      function clear(cm) {
        var array2 = cm.state.markedSelection;
        for (var i2 = 0; i2 < array2.length; ++i2) array2[i2].clear();
        array2.length = 0;
      }
      function reset(cm) {
        clear(cm);
        var ranges = cm.listSelections();
        for (var i2 = 0; i2 < ranges.length; i2++)
          coverRange(cm, ranges[i2].from(), ranges[i2].to());
      }
      function update(cm) {
        if (!cm.somethingSelected()) return clear(cm);
        if (cm.listSelections().length > 1) return reset(cm);
        var from = cm.getCursor("start"), to = cm.getCursor("end");
        var array2 = cm.state.markedSelection;
        if (!array2.length) return coverRange(cm, from, to);
        var coverStart = array2[0].find(), coverEnd = array2[array2.length - 1].find();
        if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE || cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)
          return reset(cm);
        while (cmp(from, coverStart.from) > 0) {
          array2.shift().clear();
          coverStart = array2[0].find();
        }
        if (cmp(from, coverStart.from) < 0) {
          if (coverStart.to.line - from.line < CHUNK_SIZE) {
            array2.shift().clear();
            coverRange(cm, from, coverStart.to, 0);
          } else {
            coverRange(cm, from, coverStart.from, 0);
          }
        }
        while (cmp(to, coverEnd.to) < 0) {
          array2.pop().clear();
          coverEnd = array2[array2.length - 1].find();
        }
        if (cmp(to, coverEnd.to) > 0) {
          if (to.line - coverEnd.from.line < CHUNK_SIZE) {
            array2.pop().clear();
            coverRange(cm, coverEnd.from, to);
          } else {
            coverRange(cm, coverEnd.to, to);
          }
        }
      }
    });
  })();
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports);
    })(function(CodeMirror2) {
      var Pos = CodeMirror2.Pos;
      function regexpFlags(regexp) {
        var flags = regexp.flags;
        return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
      }
      function ensureFlags(regexp, flags) {
        var current = regexpFlags(regexp), target = current;
        for (var i2 = 0; i2 < flags.length; i2++) if (target.indexOf(flags.charAt(i2)) == -1)
          target += flags.charAt(i2);
        return current == target ? regexp : new RegExp(regexp.source, target);
      }
      function maybeMultiline(regexp) {
        return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source);
      }
      function searchRegexpForward(doc, regexp, start2) {
        regexp = ensureFlags(regexp, "g");
        for (var line = start2.line, ch = start2.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
          regexp.lastIndex = ch;
          var string = doc.getLine(line), match = regexp.exec(string);
          if (match)
            return {
              from: Pos(line, match.index),
              to: Pos(line, match.index + match[0].length),
              match
            };
        }
      }
      function searchRegexpForwardMultiline(doc, regexp, start2) {
        if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start2);
        regexp = ensureFlags(regexp, "gm");
        var string, chunk = 1;
        for (var line = start2.line, last = doc.lastLine(); line <= last; ) {
          for (var i2 = 0; i2 < chunk; i2++) {
            if (line > last) break;
            var curLine = doc.getLine(line++);
            string = string == null ? curLine : string + "\n" + curLine;
          }
          chunk = chunk * 2;
          regexp.lastIndex = start2.ch;
          var match = regexp.exec(string);
          if (match) {
            var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n");
            var startLine = start2.line + before.length - 1, startCh = before[before.length - 1].length;
            return {
              from: Pos(startLine, startCh),
              to: Pos(
                startLine + inside.length - 1,
                inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length
              ),
              match
            };
          }
        }
      }
      function lastMatchIn(string, regexp, endMargin) {
        var match, from = 0;
        while (from <= string.length) {
          regexp.lastIndex = from;
          var newMatch = regexp.exec(string);
          if (!newMatch) break;
          var end = newMatch.index + newMatch[0].length;
          if (end > string.length - endMargin) break;
          if (!match || end > match.index + match[0].length)
            match = newMatch;
          from = newMatch.index + 1;
        }
        return match;
      }
      function searchRegexpBackward(doc, regexp, start2) {
        regexp = ensureFlags(regexp, "g");
        for (var line = start2.line, ch = start2.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
          var string = doc.getLine(line);
          var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);
          if (match)
            return {
              from: Pos(line, match.index),
              to: Pos(line, match.index + match[0].length),
              match
            };
        }
      }
      function searchRegexpBackwardMultiline(doc, regexp, start2) {
        if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start2);
        regexp = ensureFlags(regexp, "gm");
        var string, chunkSize = 1, endMargin = doc.getLine(start2.line).length - start2.ch;
        for (var line = start2.line, first = doc.firstLine(); line >= first; ) {
          for (var i2 = 0; i2 < chunkSize && line >= first; i2++) {
            var curLine = doc.getLine(line--);
            string = string == null ? curLine : curLine + "\n" + string;
          }
          chunkSize *= 2;
          var match = lastMatchIn(string, regexp, endMargin);
          if (match) {
            var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n");
            var startLine = line + before.length, startCh = before[before.length - 1].length;
            return {
              from: Pos(startLine, startCh),
              to: Pos(
                startLine + inside.length - 1,
                inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length
              ),
              match
            };
          }
        }
      }
      var doFold, noFold;
      if (String.prototype.normalize) {
        doFold = function(str2) {
          return str2.normalize("NFD").toLowerCase();
        };
        noFold = function(str2) {
          return str2.normalize("NFD");
        };
      } else {
        doFold = function(str2) {
          return str2.toLowerCase();
        };
        noFold = function(str2) {
          return str2;
        };
      }
      function adjustPos(orig, folded, pos, foldFunc) {
        if (orig.length == folded.length) return pos;
        for (var min2 = 0, max2 = pos + Math.max(0, orig.length - folded.length); ; ) {
          if (min2 == max2) return min2;
          var mid = min2 + max2 >> 1;
          var len = foldFunc(orig.slice(0, mid)).length;
          if (len == pos) return mid;
          else if (len > pos) max2 = mid;
          else min2 = mid + 1;
        }
      }
      function searchStringForward(doc, query, start2, caseFold) {
        if (!query.length) return null;
        var fold = caseFold ? doFold : noFold;
        var lines = fold(query).split(/\r|\n\r?/);
        search: for (var line = start2.line, ch = start2.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
          var orig = doc.getLine(line).slice(ch), string = fold(orig);
          if (lines.length == 1) {
            var found = string.indexOf(lines[0]);
            if (found == -1) continue search;
            var start2 = adjustPos(orig, string, found, fold) + ch;
            return {
              from: Pos(line, adjustPos(orig, string, found, fold) + ch),
              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)
            };
          } else {
            var cutFrom = string.length - lines[0].length;
            if (string.slice(cutFrom) != lines[0]) continue search;
            for (var i2 = 1; i2 < lines.length - 1; i2++)
              if (fold(doc.getLine(line + i2)) != lines[i2]) continue search;
            var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1];
            if (endString.slice(0, lastLine.length) != lastLine) continue search;
            return {
              from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
              to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))
            };
          }
        }
      }
      function searchStringBackward(doc, query, start2, caseFold) {
        if (!query.length) return null;
        var fold = caseFold ? doFold : noFold;
        var lines = fold(query).split(/\r|\n\r?/);
        search: for (var line = start2.line, ch = start2.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
          var orig = doc.getLine(line);
          if (ch > -1) orig = orig.slice(0, ch);
          var string = fold(orig);
          if (lines.length == 1) {
            var found = string.lastIndexOf(lines[0]);
            if (found == -1) continue search;
            return {
              from: Pos(line, adjustPos(orig, string, found, fold)),
              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))
            };
          } else {
            var lastLine = lines[lines.length - 1];
            if (string.slice(0, lastLine.length) != lastLine) continue search;
            for (var i2 = 1, start2 = line - lines.length + 1; i2 < lines.length - 1; i2++)
              if (fold(doc.getLine(start2 + i2)) != lines[i2]) continue search;
            var top = doc.getLine(line + 1 - lines.length), topString = fold(top);
            if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search;
            return {
              from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
              to: Pos(line, adjustPos(orig, string, lastLine.length, fold))
            };
          }
        }
      }
      function SearchCursor(doc, query, pos, options) {
        this.atOccurrence = false;
        this.afterEmptyMatch = false;
        this.doc = doc;
        pos = pos ? doc.clipPos(pos) : Pos(0, 0);
        this.pos = { from: pos, to: pos };
        var caseFold;
        if (typeof options == "object") {
          caseFold = options.caseFold;
        } else {
          caseFold = options;
          options = null;
        }
        if (typeof query == "string") {
          if (caseFold == null) caseFold = false;
          this.matches = function(reverse, pos2) {
            return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos2, caseFold);
          };
        } else {
          query = ensureFlags(query, "gm");
          if (!options || options.multiline !== false)
            this.matches = function(reverse, pos2) {
              return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos2);
            };
          else
            this.matches = function(reverse, pos2) {
              return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos2);
            };
        }
      }
      SearchCursor.prototype = {
        findNext: function() {
          return this.find(false);
        },
        findPrevious: function() {
          return this.find(true);
        },
        find: function(reverse) {
          var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
          if (this.afterEmptyMatch && this.atOccurrence) {
            head = Pos(head.line, head.ch);
            if (reverse) {
              head.ch--;
              if (head.ch < 0) {
                head.line--;
                head.ch = (this.doc.getLine(head.line) || "").length;
              }
            } else {
              head.ch++;
              if (head.ch > (this.doc.getLine(head.line) || "").length) {
                head.ch = 0;
                head.line++;
              }
            }
            if (CodeMirror2.cmpPos(head, this.doc.clipPos(head)) != 0) {
              return this.atOccurrence = false;
            }
          }
          var result = this.matches(reverse, head);
          this.afterEmptyMatch = result && CodeMirror2.cmpPos(result.from, result.to) == 0;
          if (result) {
            this.pos = result;
            this.atOccurrence = true;
            return this.pos.match || true;
          } else {
            var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
            this.pos = { from: end, to: end };
            return this.atOccurrence = false;
          }
        },
        from: function() {
          if (this.atOccurrence) return this.pos.from;
        },
        to: function() {
          if (this.atOccurrence) return this.pos.to;
        },
        replace: function(newText, origin) {
          if (!this.atOccurrence) return;
          var lines = CodeMirror2.splitLines(newText);
          this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
          this.pos.to = Pos(
            this.pos.from.line + lines.length - 1,
            lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0)
          );
        }
      };
      CodeMirror2.defineExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this.doc, query, pos, caseFold);
      });
      CodeMirror2.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this, query, pos, caseFold);
      });
      CodeMirror2.defineExtension("selectMatches", function(query, caseFold) {
        var ranges = [];
        var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
        while (cur.findNext()) {
          if (CodeMirror2.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
          ranges.push({ anchor: cur.from(), head: cur.to() });
        }
        if (ranges.length)
          this.setSelections(ranges, 0);
      });
    });
  })();
  (function(module, exports$1) {
    (function(mod) {
      mod(codemirrorExports, markdownExports, overlayExports);
    })(function(CodeMirror2) {
      var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?Â«Â»â€œâ€â€˜â€™]))/i;
      CodeMirror2.defineMode("gfm", function(config, modeConfig) {
        var codeDepth = 0;
        function blankLine(state) {
          state.code = false;
          return null;
        }
        var gfmOverlay = {
          startState: function() {
            return {
              code: false,
              codeBlock: false,
              ateSpace: false
            };
          },
          copyState: function(s2) {
            return {
              code: s2.code,
              codeBlock: s2.codeBlock,
              ateSpace: s2.ateSpace
            };
          },
          token: function(stream, state) {
            state.combineTokens = null;
            if (state.codeBlock) {
              if (stream.match(/^```+/)) {
                state.codeBlock = false;
                return null;
              }
              stream.skipToEnd();
              return null;
            }
            if (stream.sol()) {
              state.code = false;
            }
            if (stream.sol() && stream.match(/^```+/)) {
              stream.skipToEnd();
              state.codeBlock = true;
              return null;
            }
            if (stream.peek() === "`") {
              stream.next();
              var before = stream.pos;
              stream.eatWhile("`");
              var difference = 1 + stream.pos - before;
              if (!state.code) {
                codeDepth = difference;
                state.code = true;
              } else {
                if (difference === codeDepth) {
                  state.code = false;
                }
              }
              return null;
            } else if (state.code) {
              stream.next();
              return null;
            }
            if (stream.eatSpace()) {
              state.ateSpace = true;
              return null;
            }
            if (stream.sol() || state.ateSpace) {
              state.ateSpace = false;
              if (modeConfig.gitHubSpice !== false) {
                if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) {
                  state.combineTokens = true;
                  return "link";
                } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
                  state.combineTokens = true;
                  return "link";
                }
              }
            }
            if (stream.match(urlRE) && stream.string.slice(stream.start - 2, stream.start) != "](" && (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
              state.combineTokens = true;
              return "link";
            }
            stream.next();
            return null;
          },
          blankLine
        };
        var markdownConfig = {
          taskLists: true,
          strikethrough: true,
          emoji: true
        };
        for (var attr in modeConfig) {
          markdownConfig[attr] = modeConfig[attr];
        }
        markdownConfig.name = "markdown";
        return CodeMirror2.overlayMode(CodeMirror2.getMode(config, markdownConfig), gfmOverlay);
      }, "markdown");
      CodeMirror2.defineMIME("text/x-gfm", "gfm");
    });
  })();
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var typo = { exports: {} };
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  (function(module) {
    var Typo2;
    (function() {
      Typo2 = function(dictionary, affData, wordsData, settings) {
        settings = settings || {};
        this.dictionary = null;
        this.rules = {};
        this.dictionaryTable = {};
        this.compoundRules = [];
        this.compoundRuleCodes = {};
        this.replacementTable = [];
        this.flags = settings.flags || {};
        this.memoized = {};
        this.loaded = false;
        var self2 = this;
        var path;
        var i2, j2, _len, _jlen;
        if (dictionary) {
          self2.dictionary = dictionary;
          if (affData && wordsData) {
            setup();
          } else if (typeof window !== "undefined" && (window.chrome && window.chrome.runtime || window.browser && window.browser.runtime)) {
            var runtime = window.chrome && window.chrome.runtime ? window.chrome.runtime : window.browser.runtime;
            if (settings.dictionaryPath) {
              path = settings.dictionaryPath;
            } else {
              path = "typo/dictionaries";
            }
            if (!affData)
              readDataFile(runtime.getURL(path + "/" + dictionary + "/" + dictionary + ".aff"), setAffData);
            if (!wordsData)
              readDataFile(runtime.getURL(path + "/" + dictionary + "/" + dictionary + ".dic"), setWordsData);
          } else {
            if (settings.dictionaryPath) {
              path = settings.dictionaryPath;
            } else if (typeof __dirname !== "undefined") {
              path = __dirname + "/dictionaries";
            } else {
              path = "./dictionaries";
            }
            if (!affData)
              readDataFile(path + "/" + dictionary + "/" + dictionary + ".aff", setAffData);
            if (!wordsData)
              readDataFile(path + "/" + dictionary + "/" + dictionary + ".dic", setWordsData);
          }
        }
        function readDataFile(url, setFunc) {
          var response = self2._readFile(url, null, settings === null || settings === void 0 ? void 0 : settings.asyncLoad);
          if (settings === null || settings === void 0 ? void 0 : settings.asyncLoad) {
            response.then(function(data) {
              setFunc(data);
            });
          } else {
            setFunc(response);
          }
        }
        function setAffData(data) {
          affData = data;
          if (wordsData) {
            setup();
          }
        }
        function setWordsData(data) {
          wordsData = data;
          if (affData) {
            setup();
          }
        }
        function setup() {
          self2.rules = self2._parseAFF(affData);
          self2.compoundRuleCodes = {};
          for (i2 = 0, _len = self2.compoundRules.length; i2 < _len; i2++) {
            var rule = self2.compoundRules[i2];
            for (j2 = 0, _jlen = rule.length; j2 < _jlen; j2++) {
              self2.compoundRuleCodes[rule[j2]] = [];
            }
          }
          if ("ONLYINCOMPOUND" in self2.flags) {
            self2.compoundRuleCodes[self2.flags.ONLYINCOMPOUND] = [];
          }
          self2.dictionaryTable = self2._parseDIC(wordsData);
          for (i2 in self2.compoundRuleCodes) {
            if (self2.compoundRuleCodes[i2].length === 0) {
              delete self2.compoundRuleCodes[i2];
            }
          }
          for (i2 = 0, _len = self2.compoundRules.length; i2 < _len; i2++) {
            var ruleText = self2.compoundRules[i2];
            var expressionText = "";
            for (j2 = 0, _jlen = ruleText.length; j2 < _jlen; j2++) {
              var character = ruleText[j2];
              if (character in self2.compoundRuleCodes) {
                expressionText += "(" + self2.compoundRuleCodes[character].join("|") + ")";
              } else {
                expressionText += character;
              }
            }
            self2.compoundRules[i2] = new RegExp("^" + expressionText + "$", "i");
          }
          self2.loaded = true;
          if ((settings === null || settings === void 0 ? void 0 : settings.asyncLoad) && (settings === null || settings === void 0 ? void 0 : settings.loadedCallback)) {
            settings.loadedCallback(self2);
          }
        }
        return this;
      };
      Typo2.prototype = {
        /**
         * Loads a Typo instance from a hash of all of the Typo properties.
         *
         * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).
         */
        load: function(obj) {
          for (var i2 in obj) {
            if (obj.hasOwnProperty(i2)) {
              this[i2] = obj[i2];
            }
          }
          return this;
        },
        /**
         * Read the contents of a file.
         *
         * @param {string} path The path (relative) to the file.
         * @param {string} [charset="ISO8859-1"] The expected charset of the file
         * @param {boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all
         *        files are read synchronously.
         * @returns {string} The file data if async is false, otherwise a promise object. If running node.js, the data is
         *          always returned.
         */
        _readFile: function(path, charset, async) {
          var _a;
          charset = charset || "utf8";
          if (typeof XMLHttpRequest !== "undefined") {
            var req_1 = new XMLHttpRequest();
            req_1.open("GET", path, !!async);
            (_a = req_1.overrideMimeType) === null || _a === void 0 ? void 0 : _a.call(req_1, "text/plain; charset=" + charset);
            if (!!async) {
              var promise = new Promise(function(resolve, reject) {
                req_1.onload = function() {
                  if (req_1.status === 200) {
                    resolve(req_1.responseText);
                  } else {
                    reject(req_1.statusText);
                  }
                };
                req_1.onerror = function() {
                  reject(req_1.statusText);
                };
              });
              req_1.send(null);
              return promise;
            } else {
              req_1.send(null);
              return req_1.responseText;
            }
          } else if (typeof commonjsRequire !== "undefined") {
            var fs = require$$0;
            try {
              if (fs.existsSync(path)) {
                return fs.readFileSync(path, charset);
              } else {
                console.log("Path " + path + " does not exist.");
              }
            } catch (e2) {
              console.log(e2);
            }
            return "";
          }
          return "";
        },
        /**
         * Parse the rules out from a .aff file.
         *
         * @param {string} data The contents of the affix file.
         * @returns object The rules from the file.
         */
        _parseAFF: function(data) {
          var rules = {};
          var line, subline, numEntries, lineParts;
          var i2, j2, _len, _jlen;
          var lines = data.split(/\r?\n/);
          for (i2 = 0, _len = lines.length; i2 < _len; i2++) {
            line = this._removeAffixComments(lines[i2]);
            line = line.trim();
            if (!line) {
              continue;
            }
            var definitionParts = line.split(/\s+/);
            var ruleType = definitionParts[0];
            if (ruleType === "PFX" || ruleType === "SFX") {
              var ruleCode = definitionParts[1];
              var combineable = definitionParts[2];
              numEntries = parseInt(definitionParts[3], 10);
              var entries = [];
              for (j2 = i2 + 1, _jlen = i2 + 1 + numEntries; j2 < _jlen; j2++) {
                subline = lines[j2];
                lineParts = subline.split(/\s+/);
                var charactersToRemove = lineParts[2];
                var additionParts = lineParts[3].split("/");
                var charactersToAdd = additionParts[0];
                if (charactersToAdd === "0")
                  charactersToAdd = "";
                var continuationClasses = this.parseRuleCodes(additionParts[1]);
                var regexToMatch = lineParts[4];
                var entry = {
                  add: charactersToAdd
                };
                if (continuationClasses.length > 0)
                  entry.continuationClasses = continuationClasses;
                if (regexToMatch !== ".") {
                  if (ruleType === "SFX") {
                    entry.match = new RegExp(regexToMatch + "$");
                  } else {
                    entry.match = new RegExp("^" + regexToMatch);
                  }
                }
                if (charactersToRemove != "0") {
                  if (ruleType === "SFX") {
                    entry.remove = new RegExp(charactersToRemove + "$");
                  } else {
                    entry.remove = charactersToRemove;
                  }
                }
                entries.push(entry);
              }
              rules[ruleCode] = { "type": ruleType, "combineable": combineable === "Y", "entries": entries };
              i2 += numEntries;
            } else if (ruleType === "COMPOUNDRULE") {
              numEntries = parseInt(definitionParts[1], 10);
              for (j2 = i2 + 1, _jlen = i2 + 1 + numEntries; j2 < _jlen; j2++) {
                line = lines[j2];
                lineParts = line.split(/\s+/);
                this.compoundRules.push(lineParts[1]);
              }
              i2 += numEntries;
            } else if (ruleType === "REP") {
              lineParts = line.split(/\s+/);
              if (lineParts.length === 3) {
                this.replacementTable.push([lineParts[1], lineParts[2]]);
              }
            } else {
              this.flags[ruleType] = definitionParts[1];
            }
          }
          return rules;
        },
        /**
         * Removes comments.
         *
         * @param {string} data A line from an affix file.
         * @return {string} The cleaned-up line.
         */
        _removeAffixComments: function(line) {
          if (line.match(/^\s*#/)) {
            return "";
          }
          return line;
        },
        /**
         * Parses the words out from the .dic file.
         *
         * @param {string} data The data from the dictionary file.
         * @returns HashMap The lookup table containing all of the words and
         *                 word forms from the dictionary.
         */
        _parseDIC: function(data) {
          data = this._removeDicComments(data);
          var lines = data.split(/\r?\n/);
          var dictionaryTable = {};
          function addWord(word2, rules) {
            if (!dictionaryTable.hasOwnProperty(word2)) {
              dictionaryTable[word2] = null;
            }
            if (rules.length > 0) {
              if (dictionaryTable[word2] === null) {
                dictionaryTable[word2] = [];
              }
              dictionaryTable[word2].push(rules);
            }
          }
          for (var i2 = 1, _len = lines.length; i2 < _len; i2++) {
            var line = lines[i2];
            if (!line) {
              continue;
            }
            var just_word_and_flags = line.replace(/\s.*$/, "");
            var parts = just_word_and_flags.split("/", 2);
            var word = parts[0];
            if (parts.length > 1) {
              var ruleCodesArray = this.parseRuleCodes(parts[1]);
              if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1) {
                addWord(word, ruleCodesArray);
              }
              for (var j2 = 0, _jlen = ruleCodesArray.length; j2 < _jlen; j2++) {
                var code = ruleCodesArray[j2];
                var rule = this.rules[code];
                if (rule) {
                  var newWords = this._applyRule(word, rule);
                  for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                    var newWord = newWords[ii];
                    addWord(newWord, []);
                    if (rule.combineable) {
                      for (var k2 = j2 + 1; k2 < _jlen; k2++) {
                        var combineCode = ruleCodesArray[k2];
                        var combineRule = this.rules[combineCode];
                        if (combineRule) {
                          if (combineRule.combineable && rule.type != combineRule.type) {
                            var otherNewWords = this._applyRule(newWord, combineRule);
                            for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                              var otherNewWord = otherNewWords[iii];
                              addWord(otherNewWord, []);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (code in this.compoundRuleCodes) {
                  this.compoundRuleCodes[code].push(word);
                }
              }
            } else {
              addWord(word.trim(), []);
            }
          }
          return dictionaryTable;
        },
        /**
         * Removes comment lines and then cleans up blank lines and trailing whitespace.
         *
         * @param {string} data The data from a .dic file.
         * @return {string} The cleaned-up data.
         */
        _removeDicComments: function(data) {
          data = data.replace(/^\t.*$/mg, "");
          return data;
        },
        parseRuleCodes: function(textCodes) {
          if (!textCodes) {
            return [];
          } else if (!("FLAG" in this.flags)) {
            return textCodes.split("");
          } else if (this.flags.FLAG === "long") {
            var flags = [];
            for (var i2 = 0, _len = textCodes.length; i2 < _len; i2 += 2) {
              flags.push(textCodes.substr(i2, 2));
            }
            return flags;
          } else if (this.flags.FLAG === "num") {
            return textCodes.split(",");
          } else if (this.flags.FLAG === "UTF-8") {
            return Array.from(textCodes);
          } else {
            return textCodes.split("");
          }
        },
        /**
         * Applies an affix rule to a word.
         *
         * @param {string} word The base word.
         * @param {Object} rule The affix rule.
         * @returns {string[]} The new words generated by the rule.
         */
        _applyRule: function(word, rule) {
          var entries = rule.entries;
          var newWords = [];
          for (var i2 = 0, _len = entries.length; i2 < _len; i2++) {
            var entry = entries[i2];
            if (!entry.match || word.match(entry.match)) {
              var newWord = word;
              if (entry.remove) {
                newWord = newWord.replace(entry.remove, "");
              }
              if (rule.type === "SFX") {
                newWord = newWord + entry.add;
              } else {
                newWord = entry.add + newWord;
              }
              newWords.push(newWord);
              if ("continuationClasses" in entry) {
                for (var j2 = 0, _jlen = entry.continuationClasses.length; j2 < _jlen; j2++) {
                  var continuationRule = this.rules[entry.continuationClasses[j2]];
                  if (continuationRule) {
                    newWords = newWords.concat(this._applyRule(newWord, continuationRule));
                  }
                }
              }
            }
          }
          return newWords;
        },
        /**
         * Checks whether a word or a capitalization variant exists in the current dictionary.
         * The word is trimmed and several variations of capitalizations are checked.
         * If you want to check a word without any changes made to it, call checkExact()
         *
         * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function
         *
         * @param {string} aWord The word to check.
         * @returns {boolean}
         */
        check: function(aWord) {
          if (!this.loaded) {
            throw "Dictionary not loaded.";
          }
          if (!aWord) {
            return false;
          }
          var trimmedWord = aWord.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
          if (this.checkExact(trimmedWord)) {
            return true;
          }
          if (trimmedWord.toUpperCase() === trimmedWord) {
            var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
            if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
              return false;
            }
            if (this.checkExact(capitalizedWord)) {
              return true;
            }
            if (this.checkExact(trimmedWord.toLowerCase())) {
              return true;
            }
          }
          var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);
          if (uncapitalizedWord !== trimmedWord) {
            if (this.hasFlag(uncapitalizedWord, "KEEPCASE")) {
              return false;
            }
            if (this.checkExact(uncapitalizedWord)) {
              return true;
            }
          }
          return false;
        },
        /**
         * Checks whether a word exists in the current dictionary.
         *
         * @param {string} word The word to check.
         * @returns {boolean}
         */
        checkExact: function(word) {
          if (!this.loaded) {
            throw "Dictionary not loaded.";
          }
          var ruleCodes = this.dictionaryTable[word];
          var i2, _len;
          if (typeof ruleCodes === "undefined") {
            if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) {
              for (i2 = 0, _len = this.compoundRules.length; i2 < _len; i2++) {
                if (word.match(this.compoundRules[i2])) {
                  return true;
                }
              }
            }
          } else if (ruleCodes === null) {
            return true;
          } else if (typeof ruleCodes === "object") {
            for (i2 = 0, _len = ruleCodes.length; i2 < _len; i2++) {
              if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i2])) {
                return true;
              }
            }
          }
          return false;
        },
        /**
         * Looks up whether a given word is flagged with a given flag.
         *
         * @param {string} word The word in question.
         * @param {string} flag The flag in question.
         * @return {boolean}
         */
        hasFlag: function(word, flag, wordFlags) {
          if (!this.loaded) {
            throw "Dictionary not loaded.";
          }
          if (flag in this.flags) {
            if (typeof wordFlags === "undefined") {
              wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
            }
            if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
              return true;
            }
          }
          return false;
        },
        /**
         * Returns a list of suggestions for a misspelled word.
         *
         * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.
         * This suggestor is primitive, but it works.
         *
         * @param {string} word The misspelling.
         * @param {number} [limit=5] The maximum number of suggestions to return.
         * @returns {string[]} The array of suggestions.
         */
        alphabet: "",
        suggest: function(word, limit) {
          if (!this.loaded) {
            throw "Dictionary not loaded.";
          }
          limit = limit || 5;
          if (this.memoized.hasOwnProperty(word)) {
            var memoizedLimit = this.memoized[word]["limit"];
            if (limit <= memoizedLimit || this.memoized[word]["suggestions"].length < memoizedLimit) {
              return this.memoized[word]["suggestions"].slice(0, limit);
            }
          }
          if (this.check(word))
            return [];
          for (var i2 = 0, _len = this.replacementTable.length; i2 < _len; i2++) {
            var replacementEntry = this.replacementTable[i2];
            if (word.indexOf(replacementEntry[0]) !== -1) {
              var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
              if (this.check(correctedWord)) {
                return [correctedWord];
              }
            }
          }
          if (!this.alphabet) {
            this.alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            if ("TRY" in this.flags) {
              this.alphabet += this.flags["TRY"];
            }
            if ("WORDCHARS" in this.flags) {
              this.alphabet += this.flags["WORDCHARS"];
            }
            var alphaArray = this.alphabet.split("");
            alphaArray.sort();
            var alphaHash = {};
            for (var i2 = 0; i2 < alphaArray.length; i2++) {
              alphaHash[alphaArray[i2]] = true;
            }
            this.alphabet = "";
            for (var i2 in alphaHash) {
              this.alphabet += i2;
            }
          }
          var self2 = this;
          function edits1(words, known_only) {
            var rv = {};
            var i3, j2, _len2, _edit;
            var alphabetLength = self2.alphabet.length;
            for (var word_1 in words) {
              for (i3 = 0, _len2 = word_1.length + 1; i3 < _len2; i3++) {
                var s2 = [word_1.substring(0, i3), word_1.substring(i3)];
                if (s2[1]) {
                  _edit = s2[0] + s2[1].substring(1);
                  if (!known_only || self2.check(_edit)) {
                    if (!(_edit in rv)) {
                      rv[_edit] = 1;
                    } else {
                      rv[_edit] += 1;
                    }
                  }
                }
                if (s2[1].length > 1 && s2[1][1] !== s2[1][0]) {
                  _edit = s2[0] + s2[1][1] + s2[1][0] + s2[1].substring(2);
                  if (!known_only || self2.check(_edit)) {
                    if (!(_edit in rv)) {
                      rv[_edit] = 1;
                    } else {
                      rv[_edit] += 1;
                    }
                  }
                }
                if (s2[1]) {
                  var lettercase = s2[1].substring(0, 1).toUpperCase() === s2[1].substring(0, 1) ? "uppercase" : "lowercase";
                  for (j2 = 0; j2 < alphabetLength; j2++) {
                    var replacementLetter = self2.alphabet[j2];
                    if ("uppercase" === lettercase) {
                      replacementLetter = replacementLetter.toUpperCase();
                    }
                    if (replacementLetter != s2[1].substring(0, 1)) {
                      _edit = s2[0] + replacementLetter + s2[1].substring(1);
                      if (!known_only || self2.check(_edit)) {
                        if (!(_edit in rv)) {
                          rv[_edit] = 1;
                        } else {
                          rv[_edit] += 1;
                        }
                      }
                    }
                  }
                }
                if (s2[1]) {
                  for (j2 = 0; j2 < alphabetLength; j2++) {
                    var lettercase = s2[0].substring(-1).toUpperCase() === s2[0].substring(-1) && s2[1].substring(0, 1).toUpperCase() === s2[1].substring(0, 1) ? "uppercase" : "lowercase";
                    var replacementLetter = self2.alphabet[j2];
                    if ("uppercase" === lettercase) {
                      replacementLetter = replacementLetter.toUpperCase();
                    }
                    _edit = s2[0] + replacementLetter + s2[1];
                    if (!known_only || self2.check(_edit)) {
                      if (!(_edit in rv)) {
                        rv[_edit] = 1;
                      } else {
                        rv[_edit] += 1;
                      }
                    }
                  }
                }
              }
            }
            return rv;
          }
          function correct(word2) {
            var _a;
            var ed1 = edits1((_a = {}, _a[word2] = true, _a));
            var ed2 = edits1(ed1, true);
            var weighted_corrections = ed2;
            for (var ed1word in ed1) {
              if (!self2.check(ed1word)) {
                continue;
              }
              if (ed1word in weighted_corrections) {
                weighted_corrections[ed1word] += ed1[ed1word];
              } else {
                weighted_corrections[ed1word] = ed1[ed1word];
              }
            }
            var i3;
            var sorted_corrections = [];
            for (i3 in weighted_corrections) {
              if (weighted_corrections.hasOwnProperty(i3)) {
                if (self2.hasFlag(i3, "PRIORITYSUGGEST")) {
                  weighted_corrections[i3] += 1e3;
                }
                sorted_corrections.push([i3, weighted_corrections[i3]]);
              }
            }
            function sorter(a2, b) {
              var a_val = a2[1];
              var b_val = b[1];
              if (a_val < b_val) {
                return -1;
              } else if (a_val > b_val) {
                return 1;
              }
              return b[0].localeCompare(a2[0]);
            }
            sorted_corrections.sort(sorter).reverse();
            var rv = [];
            var capitalization_scheme = "lowercase";
            if (word2.toUpperCase() === word2) {
              capitalization_scheme = "uppercase";
            } else if (word2.substr(0, 1).toUpperCase() + word2.substr(1).toLowerCase() === word2) {
              capitalization_scheme = "capitalized";
            }
            var working_limit = limit;
            for (i3 = 0; i3 < Math.min(working_limit, sorted_corrections.length); i3++) {
              if ("uppercase" === capitalization_scheme) {
                sorted_corrections[i3][0] = sorted_corrections[i3][0].toUpperCase();
              } else if ("capitalized" === capitalization_scheme) {
                sorted_corrections[i3][0] = sorted_corrections[i3][0].substr(0, 1).toUpperCase() + sorted_corrections[i3][0].substr(1);
              }
              if (!self2.hasFlag(sorted_corrections[i3][0], "NOSUGGEST") && rv.indexOf(sorted_corrections[i3][0]) === -1) {
                rv.push(sorted_corrections[i3][0]);
              } else {
                working_limit++;
              }
            }
            return rv;
          }
          this.memoized[word] = {
            "suggestions": correct(word),
            "limit": limit
          };
          return this.memoized[word]["suggestions"];
        }
      };
    })();
    {
      module.exports = Typo2;
    }
  })(typo);
  var typoExports = typo.exports;
  var Typo = typoExports;
  function CodeMirrorSpellChecker$1(options) {
    options = options || {};
    if (typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {
      console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");
      return;
    }
    if (!String.prototype.includes) {
      String.prototype.includes = function() {
        return String.prototype.indexOf.apply(this, arguments) !== -1;
      };
    }
    options.codeMirrorInstance.defineMode("spell-checker", function(config) {
      if (!CodeMirrorSpellChecker$1.aff_loading) {
        CodeMirrorSpellChecker$1.aff_loading = true;
        var xhr_aff = new XMLHttpRequest();
        xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);
        xhr_aff.onload = function() {
          if (xhr_aff.readyState === 4 && xhr_aff.status === 200) {
            CodeMirrorSpellChecker$1.aff_data = xhr_aff.responseText;
            CodeMirrorSpellChecker$1.num_loaded++;
            if (CodeMirrorSpellChecker$1.num_loaded == 2) {
              CodeMirrorSpellChecker$1.typo = new Typo("en_US", CodeMirrorSpellChecker$1.aff_data, CodeMirrorSpellChecker$1.dic_data, {
                platform: "any"
              });
            }
          }
        };
        xhr_aff.send(null);
      }
      if (!CodeMirrorSpellChecker$1.dic_loading) {
        CodeMirrorSpellChecker$1.dic_loading = true;
        var xhr_dic = new XMLHttpRequest();
        xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);
        xhr_dic.onload = function() {
          if (xhr_dic.readyState === 4 && xhr_dic.status === 200) {
            CodeMirrorSpellChecker$1.dic_data = xhr_dic.responseText;
            CodeMirrorSpellChecker$1.num_loaded++;
            if (CodeMirrorSpellChecker$1.num_loaded == 2) {
              CodeMirrorSpellChecker$1.typo = new Typo("en_US", CodeMirrorSpellChecker$1.aff_data, CodeMirrorSpellChecker$1.dic_data, {
                platform: "any"
              });
            }
          }
        };
        xhr_dic.send(null);
      }
      var rx_word = '!"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ';
      var overlay2 = {
        token: function(stream) {
          var ch = stream.peek();
          var word = "";
          if (rx_word.includes(ch)) {
            stream.next();
            return null;
          }
          while ((ch = stream.peek()) != null && !rx_word.includes(ch)) {
            word += ch;
            stream.next();
          }
          if (CodeMirrorSpellChecker$1.typo && !CodeMirrorSpellChecker$1.typo.check(word))
            return "spell-error";
          return null;
        }
      };
      var mode = options.codeMirrorInstance.getMode(
        config,
        config.backdrop || "text/plain"
      );
      return options.codeMirrorInstance.overlayMode(mode, overlay2, true);
    });
  }
  CodeMirrorSpellChecker$1.num_loaded = 0;
  CodeMirrorSpellChecker$1.aff_loading = false;
  CodeMirrorSpellChecker$1.dic_loading = false;
  CodeMirrorSpellChecker$1.aff_data = "";
  CodeMirrorSpellChecker$1.dic_data = "";
  CodeMirrorSpellChecker$1.typo;
  var spellChecker = CodeMirrorSpellChecker$1;
  var marked$1 = {};
  (function(exports$1) {
    function _defineProperties2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (staticProps) _defineProperties2(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _unsupportedIterableToArray2(o2, minLen) {
      if (!o2) return;
      if (typeof o2 === "string") return _arrayLikeToArray2(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray2(o2, minLen);
    }
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
      if (it) return (it = it.call(o2)).next.bind(it);
      if (Array.isArray(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike) {
        if (it) o2 = it;
        var i2 = 0;
        return function() {
          if (i2 >= o2.length) return {
            done: true
          };
          return {
            done: false,
            value: o2[i2++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toPrimitive2(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint);
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(input);
    }
    function _toPropertyKey2(arg) {
      var key = _toPrimitive2(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function getDefaults() {
      return {
        async: false,
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        hooks: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    exports$1.defaults = getDefaults();
    function changeDefaults(newDefaults) {
      exports$1.defaults = newDefaults;
    }
    var escapeTest = /[&<>"']/;
    var escapeReplace = new RegExp(escapeTest.source, "g");
    var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = function getEscapeReplacement2(ch) {
      return escapeReplacements[ch];
    };
    function escape(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape(html) {
      return html.replace(unescapeTest, function(_2, n2) {
        n2 = n2.toLowerCase();
        if (n2 === "colon") return ":";
        if (n2.charAt(0) === "#") {
          return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = typeof regex === "string" ? regex : regex.source;
      opt = opt || "";
      var obj = {
        replace: function replace(name, val) {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: function getRegex() {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        var prot;
        try {
          prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e2) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e2) {
        return null;
      }
      return href;
    }
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      var relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    var noopTest = {
      exec: function noopTest2() {
      }
    };
    function splitCells(tableRow, count) {
      var row = tableRow.replace(/\|/g, function(match, offset, str2) {
        var escaped = false, curr = offset;
        while (--curr >= 0 && str2[curr] === "\\") {
          escaped = !escaped;
        }
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      var i2 = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) {
          cells.push("");
        }
      }
      for (; i2 < cells.length; i2++) {
        cells[i2] = cells[i2].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str2, c2, invert) {
      var l2 = str2.length;
      if (l2 === 0) {
        return "";
      }
      var suffLen = 0;
      while (suffLen < l2) {
        var currChar = str2.charAt(l2 - suffLen - 1);
        if (currChar === c2 && !invert) {
          suffLen++;
        } else if (currChar !== c2 && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str2.slice(0, l2 - suffLen);
    }
    function findClosingBracket(str2, b) {
      if (str2.indexOf(b[1]) === -1) {
        return -1;
      }
      var l2 = str2.length;
      var level = 0, i2 = 0;
      for (; i2 < l2; i2++) {
        if (str2[i2] === "\\") {
          i2++;
        } else if (str2[i2] === b[0]) {
          level++;
        } else if (str2[i2] === b[1]) {
          level--;
          if (level < 0) {
            return i2;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString(pattern, count) {
      if (count < 1) {
        return "";
      }
      var result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    function outputLink(cap, link, raw, lexer2) {
      var href = link.href;
      var title = link.title ? escape(link.title) : null;
      var text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        lexer2.state.inLink = true;
        var token = {
          type: "link",
          raw,
          href,
          title,
          text,
          tokens: lexer2.inlineTokens(text)
        };
        lexer2.state.inLink = false;
        return token;
      }
      return {
        type: "image",
        raw,
        href,
        title,
        text: escape(text)
      };
    }
    function indentCodeCompensation(raw, text) {
      var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      var indentToCode = matchIndentToCode[1];
      return text.split("\n").map(function(node) {
        var matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        var indentInNode = matchIndentInNode[0];
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    var Tokenizer = /* @__PURE__ */ function() {
      function Tokenizer2(options2) {
        this.options = options2 || exports$1.defaults;
      }
      var _proto = Tokenizer2.prototype;
      _proto.space = function space(src) {
        var cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      };
      _proto.code = function code(src) {
        var cap = this.rules.block.code.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      };
      _proto.fences = function fences(src) {
        var cap = this.rules.block.fences.exec(src);
        if (cap) {
          var raw = cap[0];
          var text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
            text
          };
        }
      };
      _proto.heading = function heading(src) {
        var cap = this.rules.block.heading.exec(src);
        if (cap) {
          var text = cap[2].trim();
          if (/#$/.test(text)) {
            var trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      };
      _proto.hr = function hr(src) {
        var cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      };
      _proto.blockquote = function blockquote(src) {
        var cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ *>[ \t]?/gm, "");
          var top = this.lexer.state.top;
          this.lexer.state.top = true;
          var tokens = this.lexer.blockTokens(text);
          this.lexer.state.top = top;
          return {
            type: "blockquote",
            raw: cap[0],
            tokens,
            text
          };
        }
      };
      _proto.list = function list(src) {
        var cap = this.rules.block.list.exec(src);
        if (cap) {
          var raw, istask, ischecked, indent, i2, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
          var bull = cap[1].trim();
          var isordered = bull.length > 1;
          var list2 = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          var itemRegex = new RegExp("^( {0,3}" + bull + ")((?:[	 ][^\\n]*)?(?:\\n|$))");
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            line = cap[2].split("\n", 1)[0].replace(/^\t+/, function(t2) {
              return " ".repeat(3 * t2.length);
            });
            nextLine = src.split("\n", 1)[0];
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))");
              var hrRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
              var fencesBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:```|~~~)");
              var headingBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}#");
              while (src) {
                rawLine = src.split("\n", 1)[0];
                nextLine = rawLine;
                if (this.options.pedantic) {
                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (fencesBeginRegex.test(nextLine)) {
                  break;
                }
                if (headingBeginRegex.test(nextLine)) {
                  break;
                }
                if (nextBulletRegex.test(nextLine)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                  itemContents += "\n" + nextLine.slice(indent);
                } else {
                  if (blankLine) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= 4) {
                    break;
                  }
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (hrRegex.test(line)) {
                    break;
                  }
                  itemContents += "\n" + nextLine;
                }
                if (!blankLine && !nextLine.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
                line = nextLine.slice(indent);
              }
            }
            if (!list2.loose) {
              if (endsWithBlankLine) {
                list2.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list2.raw += raw;
          }
          list2.items[list2.items.length - 1].raw = raw.trimRight();
          list2.items[list2.items.length - 1].text = itemContents.trimRight();
          list2.raw = list2.raw.trimRight();
          var l2 = list2.items.length;
          for (i2 = 0; i2 < l2; i2++) {
            this.lexer.state.top = false;
            list2.items[i2].tokens = this.lexer.blockTokens(list2.items[i2].text, []);
            if (!list2.loose) {
              var spacers = list2.items[i2].tokens.filter(function(t2) {
                return t2.type === "space";
              });
              var hasMultipleLineBreaks = spacers.length > 0 && spacers.some(function(t2) {
                return /\n.*\n/.test(t2.raw);
              });
              list2.loose = hasMultipleLineBreaks;
            }
          }
          if (list2.loose) {
            for (i2 = 0; i2 < l2; i2++) {
              list2.items[i2].loose = true;
            }
          }
          return list2;
        }
      };
      _proto.html = function html(src) {
        var cap = this.rules.block.html.exec(src);
        if (cap) {
          var token = {
            type: "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
            token.type = "paragraph";
            token.text = text;
            token.tokens = this.lexer.inline(text);
          }
          return token;
        }
      };
      _proto.def = function def(src) {
        var cap = this.rules.block.def.exec(src);
        if (cap) {
          var tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
          var href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
          var title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
          return {
            type: "def",
            tag: tag2,
            raw: cap[0],
            href,
            title
          };
        }
      };
      _proto.table = function table(src) {
        var cap = this.rules.block.table.exec(src);
        if (cap) {
          var item = {
            type: "table",
            header: splitCells(cap[1]).map(function(c2) {
              return {
                text: c2
              };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            var l2 = item.align.length;
            var i2, j2, k2, row;
            for (i2 = 0; i2 < l2; i2++) {
              if (/^ *-+: *$/.test(item.align[i2])) {
                item.align[i2] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i2])) {
                item.align[i2] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i2])) {
                item.align[i2] = "left";
              } else {
                item.align[i2] = null;
              }
            }
            l2 = item.rows.length;
            for (i2 = 0; i2 < l2; i2++) {
              item.rows[i2] = splitCells(item.rows[i2], item.header.length).map(function(c2) {
                return {
                  text: c2
                };
              });
            }
            l2 = item.header.length;
            for (j2 = 0; j2 < l2; j2++) {
              item.header[j2].tokens = this.lexer.inline(item.header[j2].text);
            }
            l2 = item.rows.length;
            for (j2 = 0; j2 < l2; j2++) {
              row = item.rows[j2];
              for (k2 = 0; k2 < row.length; k2++) {
                row[k2].tokens = this.lexer.inline(row[k2].text);
              }
            }
            return item;
          }
        }
      };
      _proto.lheading = function lheading(src) {
        var cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      };
      _proto.paragraph = function paragraph(src) {
        var cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          var text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
          return {
            type: "paragraph",
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      };
      _proto.text = function text(src) {
        var cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      };
      _proto.escape = function escape$1(src) {
        var cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      };
      _proto.tag = function tag2(src) {
        var cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      };
      _proto.link = function link(src) {
        var cap = this.rules.inline.link.exec(src);
        if (cap) {
          var trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            var lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              var start2 = cap[0].indexOf("!") === 0 ? 5 : 4;
              var linkLen = start2 + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          var href = cap[2];
          var title = "";
          if (this.options.pedantic) {
            var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title = link2[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      };
      _proto.reflink = function reflink(src, links) {
        var cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link) {
            var text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      };
      _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
        if (prevChar === void 0) {
          prevChar = "";
        }
        var match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match) return;
        if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
        var nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          var lLength = match[0].length - 1;
          var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          var endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim) continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0) continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            var raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
            if (Math.min(lLength, rLength) % 2) {
              var _text = raw.slice(1, -1);
              return {
                type: "em",
                raw,
                text: _text,
                tokens: this.lexer.inlineTokens(_text)
              };
            }
            var text = raw.slice(2, -2);
            return {
              type: "strong",
              raw,
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      };
      _proto.codespan = function codespan(src) {
        var cap = this.rules.inline.code.exec(src);
        if (cap) {
          var text = cap[2].replace(/\n/g, " ");
          var hasNonSpaceChars = /[^ ]/.test(text);
          var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      };
      _proto.br = function br(src) {
        var cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      };
      _proto.del = function del(src) {
        var cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      };
      _proto.autolink = function autolink(src, mangle2) {
        var cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          var text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      };
      _proto.url = function url(src, mangle2) {
        var cap;
        if (cap = this.rules.inline.url.exec(src)) {
          var text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            var prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      };
      _proto.inlineText = function inlineText(src, smartypants2) {
        var cap = this.rules.inline.text.exec(src);
        if (cap) {
          var text;
          if (this.lexer.state.inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          } else {
            text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      };
      return Tokenizer2;
    }();
    var block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = _extends({}, block);
    block.gfm = _extends({}, block.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    });
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = _extends({}, block.normal, {
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
        rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = _extends({}, inline);
    inline.pedantic = _extends({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = _extends({}, inline.normal, {
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = _extends({}, inline.gfm, {
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    function smartypants(text) {
      return text.replace(/---/g, "â€”").replace(/--/g, "â€“").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1â€˜").replace(/'/g, "â€™").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1â€œ").replace(/"/g, "â€").replace(/\.{3}/g, "â€¦");
    }
    function mangle(text) {
      var out = "", i2, ch;
      var l2 = text.length;
      for (i2 = 0; i2 < l2; i2++) {
        ch = text.charCodeAt(i2);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    var Lexer = /* @__PURE__ */ function() {
      function Lexer2(options2) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options2 || exports$1.defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        var rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      Lexer2.lex = function lex(src, options2) {
        var lexer2 = new Lexer2(options2);
        return lexer2.lex(src);
      };
      Lexer2.lexInline = function lexInline(src, options2) {
        var lexer2 = new Lexer2(options2);
        return lexer2.inlineTokens(src);
      };
      var _proto = Lexer2.prototype;
      _proto.lex = function lex(src) {
        src = src.replace(/\r\n|\r/g, "\n");
        this.blockTokens(src, this.tokens);
        var next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      };
      _proto.blockTokens = function blockTokens(src, tokens) {
        var _this = this;
        if (tokens === void 0) {
          tokens = [];
        }
        if (this.options.pedantic) {
          src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
        } else {
          src = src.replace(/^( *)(\t+)/gm, function(_2, leading, tabs) {
            return leading + "    ".repeat(tabs.length);
          });
        }
        var token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
            if (token = extTokenizer.call({
              lexer: _this
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            (function() {
              var startIndex = Infinity;
              var tempSrc = src.slice(1);
              var tempStart = void 0;
              _this.options.extensions.startBlock.forEach(function(getStartIndex) {
                tempStart = getStartIndex.call({
                  lexer: this
                }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            })();
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      };
      _proto.inline = function inline2(src, tokens) {
        if (tokens === void 0) {
          tokens = [];
        }
        this.inlineQueue.push({
          src,
          tokens
        });
        return tokens;
      };
      _proto.inlineTokens = function inlineTokens(src, tokens) {
        var _this2 = this;
        if (tokens === void 0) {
          tokens = [];
        }
        var token, lastToken, cutSrc;
        var maskedSrc = src;
        var match;
        var keepPrevChar, prevChar;
        if (this.tokens.links) {
          var links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
            if (token = extTokenizer.call({
              lexer: _this2
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            (function() {
              var startIndex = Infinity;
              var tempSrc = src.slice(1);
              var tempStart = void 0;
              _this2.options.extensions.startInline.forEach(function(getStartIndex) {
                tempStart = getStartIndex.call({
                  lexer: this
                }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            })();
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      };
      _createClass2(Lexer2, null, [{
        key: "rules",
        get: function get2() {
          return {
            block,
            inline
          };
        }
      }]);
      return Lexer2;
    }();
    var Renderer = /* @__PURE__ */ function() {
      function Renderer2(options2) {
        this.options = options2 || exports$1.defaults;
      }
      var _proto = Renderer2.prototype;
      _proto.code = function code(_code, infostring, escaped) {
        var lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          var out = this.options.highlight(_code, lang);
          if (out != null && out !== _code) {
            escaped = true;
            _code = out;
          }
        }
        _code = _code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? _code : escape(_code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? _code : escape(_code, true)) + "</code></pre>\n";
      };
      _proto.blockquote = function blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      };
      _proto.html = function html(_html) {
        return _html;
      };
      _proto.heading = function heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          var id2 = this.options.headerPrefix + slugger.slug(raw);
          return "<h" + level + ' id="' + id2 + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      };
      _proto.hr = function hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      };
      _proto.list = function list(body, ordered, start2) {
        var type2 = ordered ? "ol" : "ul", startatt = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
        return "<" + type2 + startatt + ">\n" + body + "</" + type2 + ">\n";
      };
      _proto.listitem = function listitem(text) {
        return "<li>" + text + "</li>\n";
      };
      _proto.checkbox = function checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      };
      _proto.paragraph = function paragraph(text) {
        return "<p>" + text + "</p>\n";
      };
      _proto.table = function table(header, body) {
        if (body) body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      };
      _proto.tablerow = function tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      };
      _proto.tablecell = function tablecell(content, flags) {
        var type2 = flags.header ? "th" : "td";
        var tag2 = flags.align ? "<" + type2 + ' align="' + flags.align + '">' : "<" + type2 + ">";
        return tag2 + content + ("</" + type2 + ">\n");
      };
      _proto.strong = function strong(text) {
        return "<strong>" + text + "</strong>";
      };
      _proto.em = function em(text) {
        return "<em>" + text + "</em>";
      };
      _proto.codespan = function codespan(text) {
        return "<code>" + text + "</code>";
      };
      _proto.br = function br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      };
      _proto.del = function del(text) {
        return "<del>" + text + "</del>";
      };
      _proto.link = function link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      };
      _proto.image = function image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      };
      _proto.text = function text(_text) {
        return _text;
      };
      return Renderer2;
    }();
    var TextRenderer = /* @__PURE__ */ function() {
      function TextRenderer2() {
      }
      var _proto = TextRenderer2.prototype;
      _proto.strong = function strong(text) {
        return text;
      };
      _proto.em = function em(text) {
        return text;
      };
      _proto.codespan = function codespan(text) {
        return text;
      };
      _proto.del = function del(text) {
        return text;
      };
      _proto.html = function html(text) {
        return text;
      };
      _proto.text = function text(_text) {
        return _text;
      };
      _proto.link = function link(href, title, text) {
        return "" + text;
      };
      _proto.image = function image(href, title, text) {
        return "" + text;
      };
      _proto.br = function br() {
        return "";
      };
      return TextRenderer2;
    }();
    var Slugger = /* @__PURE__ */ function() {
      function Slugger2() {
        this.seen = {};
      }
      var _proto = Slugger2.prototype;
      _proto.serialize = function serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      };
      _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
        var slug = originalSlug;
        var occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      };
      _proto.slug = function slug(value, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        var slug2 = this.serialize(value);
        return this.getNextSafeSlug(slug2, options2.dryrun);
      };
      return Slugger2;
    }();
    var Parser = /* @__PURE__ */ function() {
      function Parser2(options2) {
        this.options = options2 || exports$1.defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      Parser2.parse = function parse2(tokens, options2) {
        var parser2 = new Parser2(options2);
        return parser2.parse(tokens);
      };
      Parser2.parseInline = function parseInline2(tokens, options2) {
        var parser2 = new Parser2(options2);
        return parser2.parseInline(tokens);
      };
      var _proto = Parser2.prototype;
      _proto.parse = function parse2(tokens, top) {
        if (top === void 0) {
          top = true;
        }
        var out = "", i2, j2, k2, l2, l3, row, cell, header, body, token, ordered, start2, loose, itemBody, item, checked, task, checkbox, ret;
        var l4 = tokens.length;
        for (i2 = 0; i2 < l4; i2++) {
          token = tokens[i2];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j2 = 0; j2 < l2; j2++) {
                cell += this.renderer.tablecell(this.parseInline(token.header[j2].tokens), {
                  header: true,
                  align: token.align[j2]
                });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.rows.length;
              for (j2 = 0; j2 < l2; j2++) {
                row = token.rows[j2];
                cell = "";
                l3 = row.length;
                for (k2 = 0; k2 < l3; k2++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k2].tokens), {
                    header: false,
                    align: token.align[k2]
                  });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start2 = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j2 = 0; j2 < l2; j2++) {
                item = token.items[j2];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start2);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i2 + 1 < l4 && tokens[i2 + 1].type === "text") {
                token = tokens[++i2];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      _proto.parseInline = function parseInline2(tokens, renderer) {
        renderer = renderer || this.renderer;
        var out = "", i2, token, ret;
        var l2 = tokens.length;
        for (i2 = 0; i2 < l2; i2++) {
          token = tokens[i2];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      return Parser2;
    }();
    var Hooks = /* @__PURE__ */ function() {
      function Hooks2(options2) {
        this.options = options2 || exports$1.defaults;
      }
      var _proto = Hooks2.prototype;
      _proto.preprocess = function preprocess(markdown2) {
        return markdown2;
      };
      _proto.postprocess = function postprocess(html) {
        return html;
      };
      return Hooks2;
    }();
    Hooks.passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess"]);
    function onError(silent, async, callback) {
      return function(e2) {
        e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          var msg = "<p>An error occurred:</p><pre>" + escape(e2.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          if (callback) {
            callback(null, msg);
            return;
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e2);
        }
        if (callback) {
          callback(e2);
          return;
        }
        throw e2;
      };
    }
    function parseMarkdown(lexer2, parser2) {
      return function(src, opt, callback) {
        if (typeof opt === "function") {
          callback = opt;
          opt = null;
        }
        var origOpt = _extends({}, opt);
        opt = _extends({}, marked2.defaults, origOpt);
        var throwError2 = onError(opt.silent, opt.async, callback);
        if (typeof src === "undefined" || src === null) {
          return throwError2(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError2(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        checkSanitizeDeprecation(opt);
        if (opt.hooks) {
          opt.hooks.options = opt;
        }
        if (callback) {
          var highlight = opt.highlight;
          var tokens;
          try {
            if (opt.hooks) {
              src = opt.hooks.preprocess(src);
            }
            tokens = lexer2(src, opt);
          } catch (e2) {
            return throwError2(e2);
          }
          var done = function done2(err) {
            var out;
            if (!err) {
              try {
                if (opt.walkTokens) {
                  marked2.walkTokens(tokens, opt.walkTokens);
                }
                out = parser2(tokens, opt);
                if (opt.hooks) {
                  out = opt.hooks.postprocess(out);
                }
              } catch (e2) {
                err = e2;
              }
            }
            opt.highlight = highlight;
            return err ? throwError2(err) : callback(null, out);
          };
          if (!highlight || highlight.length < 3) {
            return done();
          }
          delete opt.highlight;
          if (!tokens.length) return done();
          var pending = 0;
          marked2.walkTokens(tokens, function(token) {
            if (token.type === "code") {
              pending++;
              setTimeout(function() {
                highlight(token.text, token.lang, function(err, code) {
                  if (err) {
                    return done(err);
                  }
                  if (code != null && code !== token.text) {
                    token.text = code;
                    token.escaped = true;
                  }
                  pending--;
                  if (pending === 0) {
                    done();
                  }
                });
              }, 0);
            }
          });
          if (pending === 0) {
            done();
          }
          return;
        }
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(function(src2) {
            return lexer2(src2, opt);
          }).then(function(tokens2) {
            return opt.walkTokens ? Promise.all(marked2.walkTokens(tokens2, opt.walkTokens)).then(function() {
              return tokens2;
            }) : tokens2;
          }).then(function(tokens2) {
            return parser2(tokens2, opt);
          }).then(function(html2) {
            return opt.hooks ? opt.hooks.postprocess(html2) : html2;
          })["catch"](throwError2);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          var _tokens = lexer2(src, opt);
          if (opt.walkTokens) {
            marked2.walkTokens(_tokens, opt.walkTokens);
          }
          var html = parser2(_tokens, opt);
          if (opt.hooks) {
            html = opt.hooks.postprocess(html);
          }
          return html;
        } catch (e2) {
          return throwError2(e2);
        }
      };
    }
    function marked2(src, opt, callback) {
      return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);
    }
    marked2.options = marked2.setOptions = function(opt) {
      marked2.defaults = _extends({}, marked2.defaults, opt);
      changeDefaults(marked2.defaults);
      return marked2;
    };
    marked2.getDefaults = getDefaults;
    marked2.defaults = exports$1.defaults;
    marked2.use = function() {
      var extensions = marked2.defaults.extensions || {
        renderers: {},
        childTokens: {}
      };
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      args.forEach(function(pack) {
        var opts = _extends({}, pack);
        opts.async = marked2.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach(function(ext) {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              var prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function() {
                  for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args2[_key2] = arguments[_key2];
                  }
                  var ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          (function() {
            var renderer = marked2.defaults.renderer || new Renderer();
            var _loop = function _loop2(prop2) {
              var prevRenderer = renderer[prop2];
              renderer[prop2] = function() {
                for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args2[_key3] = arguments[_key3];
                }
                var ret = pack.renderer[prop2].apply(renderer, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args2);
                }
                return ret;
              };
            };
            for (var prop in pack.renderer) {
              _loop(prop);
            }
            opts.renderer = renderer;
          })();
        }
        if (pack.tokenizer) {
          (function() {
            var tokenizer = marked2.defaults.tokenizer || new Tokenizer();
            var _loop2 = function _loop22(prop2) {
              var prevTokenizer = tokenizer[prop2];
              tokenizer[prop2] = function() {
                for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args2[_key4] = arguments[_key4];
                }
                var ret = pack.tokenizer[prop2].apply(tokenizer, args2);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args2);
                }
                return ret;
              };
            };
            for (var prop in pack.tokenizer) {
              _loop2(prop);
            }
            opts.tokenizer = tokenizer;
          })();
        }
        if (pack.hooks) {
          (function() {
            var hooks = marked2.defaults.hooks || new Hooks();
            var _loop3 = function _loop32(prop2) {
              var prevHook = hooks[prop2];
              if (Hooks.passThroughHooks.has(prop2)) {
                hooks[prop2] = function(arg) {
                  if (marked2.defaults.async) {
                    return Promise.resolve(pack.hooks[prop2].call(hooks, arg)).then(function(ret2) {
                      return prevHook.call(hooks, ret2);
                    });
                  }
                  var ret = pack.hooks[prop2].call(hooks, arg);
                  return prevHook.call(hooks, ret);
                };
              } else {
                hooks[prop2] = function() {
                  for (var _len5 = arguments.length, args2 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                    args2[_key5] = arguments[_key5];
                  }
                  var ret = pack.hooks[prop2].apply(hooks, args2);
                  if (ret === false) {
                    ret = prevHook.apply(hooks, args2);
                  }
                  return ret;
                };
              }
            };
            for (var prop in pack.hooks) {
              _loop3(prop);
            }
            opts.hooks = hooks;
          })();
        }
        if (pack.walkTokens) {
          var _walkTokens = marked2.defaults.walkTokens;
          opts.walkTokens = function(token) {
            var values = [];
            values.push(pack.walkTokens.call(this, token));
            if (_walkTokens) {
              values = values.concat(_walkTokens.call(this, token));
            }
            return values;
          };
        }
        marked2.setOptions(opts);
      });
    };
    marked2.walkTokens = function(tokens, callback) {
      var values = [];
      var _loop4 = function _loop42() {
        var token = _step.value;
        values = values.concat(callback.call(marked2, token));
        switch (token.type) {
          case "table": {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done; ) {
              var cell = _step2.value;
              values = values.concat(marked2.walkTokens(cell.tokens, callback));
            }
            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done; ) {
              var row = _step3.value;
              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                var _cell = _step4.value;
                values = values.concat(marked2.walkTokens(_cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            values = values.concat(marked2.walkTokens(token.items, callback));
            break;
          }
          default: {
            if (marked2.defaults.extensions && marked2.defaults.extensions.childTokens && marked2.defaults.extensions.childTokens[token.type]) {
              marked2.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                values = values.concat(marked2.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(marked2.walkTokens(token.tokens, callback));
            }
          }
        }
      };
      for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
        _loop4();
      }
      return values;
    };
    marked2.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);
    marked2.Parser = Parser;
    marked2.parser = Parser.parse;
    marked2.Renderer = Renderer;
    marked2.TextRenderer = TextRenderer;
    marked2.Lexer = Lexer;
    marked2.lexer = Lexer.lex;
    marked2.Tokenizer = Tokenizer;
    marked2.Slugger = Slugger;
    marked2.Hooks = Hooks;
    marked2.parse = marked2;
    var options = marked2.options;
    var setOptions = marked2.setOptions;
    var use = marked2.use;
    var walkTokens = marked2.walkTokens;
    var parseInline = marked2.parseInline;
    var parse = marked2;
    var parser = Parser.parse;
    var lexer = Lexer.lex;
    exports$1.Hooks = Hooks;
    exports$1.Lexer = Lexer;
    exports$1.Parser = Parser;
    exports$1.Renderer = Renderer;
    exports$1.Slugger = Slugger;
    exports$1.TextRenderer = TextRenderer;
    exports$1.Tokenizer = Tokenizer;
    exports$1.getDefaults = getDefaults;
    exports$1.lexer = lexer;
    exports$1.marked = marked2;
    exports$1.options = options;
    exports$1.parse = parse;
    exports$1.parseInline = parseInline;
    exports$1.parser = parser;
    exports$1.setOptions = setOptions;
    exports$1.use = use;
    exports$1.walkTokens = walkTokens;
  })(marked$1);
  var CodeMirror = codemirrorExports;
  var CodeMirrorSpellChecker = spellChecker;
  var marked = marked$1.marked;
  var isMac = /Mac/.test(navigator.platform);
  var anchorToExternalRegex = new RegExp(/(<a.*?https?:\/\/.*?[^a]>)+?/g);
  var bindings = {
    "toggleBold": toggleBold,
    "toggleItalic": toggleItalic,
    "drawLink": drawLink,
    "toggleHeadingSmaller": toggleHeadingSmaller,
    "toggleHeadingBigger": toggleHeadingBigger,
    "drawImage": drawImage,
    "toggleBlockquote": toggleBlockquote,
    "toggleOrderedList": toggleOrderedList,
    "toggleUnorderedList": toggleUnorderedList,
    "toggleCodeBlock": toggleCodeBlock,
    "togglePreview": togglePreview,
    "toggleStrikethrough": toggleStrikethrough,
    "toggleHeading1": toggleHeading1,
    "toggleHeading2": toggleHeading2,
    "toggleHeading3": toggleHeading3,
    "toggleHeading4": toggleHeading4,
    "toggleHeading5": toggleHeading5,
    "toggleHeading6": toggleHeading6,
    "cleanBlock": cleanBlock,
    "drawTable": drawTable,
    "drawHorizontalRule": drawHorizontalRule,
    "undo": undo,
    "redo": redo,
    "toggleSideBySide": toggleSideBySide,
    "toggleFullScreen": toggleFullScreen
  };
  var shortcuts = {
    "toggleBold": "Cmd-B",
    "toggleItalic": "Cmd-I",
    "drawLink": "Cmd-K",
    "toggleHeadingSmaller": "Cmd-H",
    "toggleHeadingBigger": "Shift-Cmd-H",
    "toggleHeading1": "Ctrl+Alt+1",
    "toggleHeading2": "Ctrl+Alt+2",
    "toggleHeading3": "Ctrl+Alt+3",
    "toggleHeading4": "Ctrl+Alt+4",
    "toggleHeading5": "Ctrl+Alt+5",
    "toggleHeading6": "Ctrl+Alt+6",
    "cleanBlock": "Cmd-E",
    "drawImage": "Cmd-Alt-I",
    "toggleBlockquote": "Cmd-'",
    "toggleOrderedList": "Cmd-Alt-L",
    "toggleUnorderedList": "Cmd-L",
    "toggleCodeBlock": "Cmd-Alt-C",
    "togglePreview": "Cmd-P",
    "toggleSideBySide": "F9",
    "toggleFullScreen": "F11"
  };
  var getBindingName = function(f2) {
    for (var key in bindings) {
      if (bindings[key] === f2) {
        return key;
      }
    }
    return null;
  };
  var isMobile = function() {
    var check2 = false;
    (function(a2) {
      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a2.substr(0, 4))) check2 = true;
    })(navigator.userAgent || navigator.vendor || window.opera);
    return check2;
  };
  function addAnchorTargetBlank(htmlText) {
    var match;
    while ((match = anchorToExternalRegex.exec(htmlText)) !== null) {
      var linkString = match[0];
      if (linkString.indexOf("target=") === -1) {
        var fixedLinkString = linkString.replace(/>$/, ' target="_blank">');
        htmlText = htmlText.replace(linkString, fixedLinkString);
      }
    }
    return htmlText;
  }
  function removeListStyleWhenCheckbox(htmlText) {
    var parser = new DOMParser();
    var htmlDoc = parser.parseFromString(htmlText, "text/html");
    var listItems = htmlDoc.getElementsByTagName("li");
    for (var i2 = 0; i2 < listItems.length; i2++) {
      var listItem = listItems[i2];
      for (var j2 = 0; j2 < listItem.children.length; j2++) {
        var listItemChild = listItem.children[j2];
        if (listItemChild instanceof HTMLInputElement && listItemChild.type === "checkbox") {
          listItem.style.marginLeft = "-1.5em";
          listItem.style.listStyleType = "none";
        }
      }
    }
    return htmlDoc.documentElement.innerHTML;
  }
  function fixShortcut(name) {
    if (isMac) {
      name = name.replace("Ctrl", "Cmd");
    } else {
      name = name.replace("Cmd", "Ctrl");
    }
    return name;
  }
  function createToolbarDropdown(options, enableTooltips, shortcuts2, parent) {
    var el = createToolbarButton(options, false, enableTooltips, shortcuts2, "button", parent);
    el.classList.add("easymde-dropdown");
    el.onclick = function() {
      el.focus();
    };
    var content = document.createElement("div");
    content.className = "easymde-dropdown-content";
    for (var childrenIndex = 0; childrenIndex < options.children.length; childrenIndex++) {
      var child = options.children[childrenIndex];
      var childElement;
      if (typeof child === "string" && child in toolbarBuiltInButtons) {
        childElement = createToolbarButton(toolbarBuiltInButtons[child], true, enableTooltips, shortcuts2, "button", parent);
      } else {
        childElement = createToolbarButton(child, true, enableTooltips, shortcuts2, "button", parent);
      }
      childElement.addEventListener("click", function(e2) {
        e2.stopPropagation();
      }, false);
      content.appendChild(childElement);
    }
    el.appendChild(content);
    return el;
  }
  function createToolbarButton(options, enableActions, enableTooltips, shortcuts2, markup, parent) {
    options = options || {};
    var el = document.createElement(markup);
    if (options.attributes) {
      for (var attribute in options.attributes) {
        if (Object.prototype.hasOwnProperty.call(options.attributes, attribute)) {
          el.setAttribute(attribute, options.attributes[attribute]);
        }
      }
    }
    var classNamePrefix = parent.options.toolbarButtonClassPrefix ? parent.options.toolbarButtonClassPrefix + "-" : "";
    el.className = classNamePrefix + options.name;
    el.setAttribute("type", markup);
    enableTooltips = enableTooltips == void 0 ? true : enableTooltips;
    if (options.text) {
      el.innerText = options.text;
    }
    if (options.name && options.name in shortcuts2) {
      bindings[options.name] = options.action;
    }
    if (options.title && enableTooltips) {
      el.title = createTooltip(options.title, options.action, shortcuts2);
      if (isMac) {
        el.title = el.title.replace("Ctrl", "âŒ˜");
        el.title = el.title.replace("Alt", "âŒ¥");
      }
    }
    if (options.title) {
      el.setAttribute("aria-label", options.title);
    }
    if (options.noDisable) {
      el.classList.add("no-disable");
    }
    if (options.noMobile) {
      el.classList.add("no-mobile");
    }
    var classNameParts = [];
    if (typeof options.className !== "undefined") {
      classNameParts = options.className.split(" ");
    }
    var iconClasses = [];
    for (var classNameIndex = 0; classNameIndex < classNameParts.length; classNameIndex++) {
      var classNamePart = classNameParts[classNameIndex];
      if (classNamePart.match(/^fa([srlb]|(-[\w-]*)|$)/)) {
        iconClasses.push(classNamePart);
      } else {
        el.classList.add(classNamePart);
      }
    }
    el.tabIndex = -1;
    if (iconClasses.length > 0) {
      var icon = document.createElement("i");
      for (var iconClassIndex = 0; iconClassIndex < iconClasses.length; iconClassIndex++) {
        var iconClass = iconClasses[iconClassIndex];
        icon.classList.add(iconClass);
      }
      el.appendChild(icon);
    }
    if (typeof options.icon !== "undefined") {
      el.innerHTML = options.icon;
    }
    if (options.action && enableActions) {
      if (typeof options.action === "function") {
        el.onclick = function(e2) {
          e2.preventDefault();
          options.action(parent);
        };
      } else if (typeof options.action === "string") {
        el.onclick = function(e2) {
          e2.preventDefault();
          window.open(options.action, "_blank");
        };
      }
    }
    return el;
  }
  function createSep() {
    var el = document.createElement("i");
    el.className = "separator";
    el.innerHTML = "|";
    return el;
  }
  function createTooltip(title, action, shortcuts2) {
    var actionName;
    var tooltip = title;
    if (action) {
      actionName = getBindingName(action);
      if (shortcuts2[actionName]) {
        tooltip += " (" + fixShortcut(shortcuts2[actionName]) + ")";
      }
    }
    return tooltip;
  }
  function getState(cm, pos) {
    pos = pos || cm.getCursor("start");
    var stat = cm.getTokenAt(pos);
    if (!stat.type) return {};
    var types2 = stat.type.split(" ");
    var ret = {}, data, text;
    for (var i2 = 0; i2 < types2.length; i2++) {
      data = types2[i2];
      if (data === "strong") {
        ret.bold = true;
      } else if (data === "variable-2") {
        text = cm.getLine(pos.line);
        if (/^\s*\d+\.\s/.test(text)) {
          ret["ordered-list"] = true;
        } else {
          ret["unordered-list"] = true;
        }
      } else if (data === "atom") {
        ret.quote = true;
      } else if (data === "em") {
        ret.italic = true;
      } else if (data === "quote") {
        ret.quote = true;
      } else if (data === "strikethrough") {
        ret.strikethrough = true;
      } else if (data === "comment") {
        ret.code = true;
      } else if (data === "link" && !ret.image) {
        ret.link = true;
      } else if (data === "image") {
        ret.image = true;
      } else if (data.match(/^header(-[1-6])?$/)) {
        ret[data.replace("header", "heading")] = true;
      }
    }
    return ret;
  }
  var saved_overflow = "";
  function toggleFullScreen(editor) {
    var cm = editor.codemirror;
    cm.setOption("fullScreen", !cm.getOption("fullScreen"));
    if (cm.getOption("fullScreen")) {
      saved_overflow = document.body.style.overflow;
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = saved_overflow;
    }
    var wrapper = cm.getWrapperElement();
    var sidebyside = wrapper.nextSibling;
    if (sidebyside.classList.contains("editor-preview-active-side")) {
      if (editor.options.sideBySideFullscreen === false) {
        var easyMDEContainer = wrapper.parentNode;
        if (cm.getOption("fullScreen")) {
          easyMDEContainer.classList.remove("sided--no-fullscreen");
        } else {
          easyMDEContainer.classList.add("sided--no-fullscreen");
        }
      } else {
        toggleSideBySide(editor);
      }
    }
    if (editor.options.onToggleFullScreen) {
      editor.options.onToggleFullScreen(cm.getOption("fullScreen") || false);
    }
    if (typeof editor.options.maxHeight !== "undefined") {
      if (cm.getOption("fullScreen")) {
        cm.getScrollerElement().style.removeProperty("height");
        sidebyside.style.removeProperty("height");
      } else {
        cm.getScrollerElement().style.height = editor.options.maxHeight;
        editor.setPreviewMaxHeight();
      }
    }
    editor.toolbar_div.classList.toggle("fullscreen");
    if (editor.toolbarElements && editor.toolbarElements.fullscreen) {
      var toolbarButton = editor.toolbarElements.fullscreen;
      toolbarButton.classList.toggle("active");
    }
  }
  function toggleBold(editor) {
    _toggleBlock(editor, "bold", editor.options.blockStyles.bold);
  }
  function toggleItalic(editor) {
    _toggleBlock(editor, "italic", editor.options.blockStyles.italic);
  }
  function toggleStrikethrough(editor) {
    _toggleBlock(editor, "strikethrough", "~~");
  }
  function toggleCodeBlock(editor) {
    var fenceCharsToInsert = editor.options.blockStyles.code;
    function fencing_line(line2) {
      if (typeof line2 !== "object") {
        throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof line2 + ": " + line2;
      }
      return line2.styles && line2.styles[2] && line2.styles[2].indexOf("formatting-code-block") !== -1;
    }
    function token_state(token) {
      return token.state.base.base || token.state.base;
    }
    function code_type(cm2, line_num, line2, firstTok, lastTok) {
      line2 = line2 || cm2.getLineHandle(line_num);
      firstTok = firstTok || cm2.getTokenAt({
        line: line_num,
        ch: 1
      });
      lastTok = lastTok || !!line2.text && cm2.getTokenAt({
        line: line_num,
        ch: line2.text.length - 1
      });
      var types2 = firstTok.type ? firstTok.type.split(" ") : [];
      if (lastTok && token_state(lastTok).indentedCode) {
        return "indented";
      } else if (types2.indexOf("comment") === -1) {
        return false;
      } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line2)) {
        return "fenced";
      } else {
        return "single";
      }
    }
    function insertFencingAtSelection(cm2, cur_start2, cur_end2, fenceCharsToInsert2) {
      var start_line_sel = cur_start2.line + 1, end_line_sel = cur_end2.line + 1, sel_multi2 = cur_start2.line !== cur_end2.line, repl_start = fenceCharsToInsert2 + "\n", repl_end = "\n" + fenceCharsToInsert2;
      if (sel_multi2) {
        end_line_sel++;
      }
      if (sel_multi2 && cur_end2.ch === 0) {
        repl_end = fenceCharsToInsert2 + "\n";
        end_line_sel--;
      }
      _replaceSelection(cm2, false, [repl_start, repl_end]);
      cm2.setSelection({
        line: start_line_sel,
        ch: 0
      }, {
        line: end_line_sel,
        ch: 0
      });
    }
    var cm = editor.codemirror, cur_start = cm.getCursor("start"), cur_end = cm.getCursor("end"), tok = cm.getTokenAt({
      line: cur_start.line,
      ch: cur_start.ch || 1
    }), line = cm.getLineHandle(cur_start.line), is_code = code_type(cm, cur_start.line, line, tok);
    var block_start, block_end, lineCount;
    if (is_code === "single") {
      var start2 = line.text.slice(0, cur_start.ch).replace("`", ""), end = line.text.slice(cur_start.ch).replace("`", "");
      cm.replaceRange(start2 + end, {
        line: cur_start.line,
        ch: 0
      }, {
        line: cur_start.line,
        ch: 99999999999999
      });
      cur_start.ch--;
      if (cur_start !== cur_end) {
        cur_end.ch--;
      }
      cm.setSelection(cur_start, cur_end);
      cm.focus();
    } else if (is_code === "fenced") {
      if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
        for (block_start = cur_start.line; block_start >= 0; block_start--) {
          line = cm.getLineHandle(block_start);
          if (fencing_line(line)) {
            break;
          }
        }
        var fencedTok = cm.getTokenAt({
          line: block_start,
          ch: 1
        });
        var fence_chars = token_state(fencedTok).fencedChars;
        var start_text, start_line;
        var end_text, end_line;
        if (fencing_line(cm.getLineHandle(cur_start.line))) {
          start_text = "";
          start_line = cur_start.line;
        } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {
          start_text = "";
          start_line = cur_start.line - 1;
        } else {
          start_text = fence_chars + "\n";
          start_line = cur_start.line;
        }
        if (fencing_line(cm.getLineHandle(cur_end.line))) {
          end_text = "";
          end_line = cur_end.line;
          if (cur_end.ch === 0) {
            end_line += 1;
          }
        } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {
          end_text = "";
          end_line = cur_end.line + 1;
        } else {
          end_text = fence_chars + "\n";
          end_line = cur_end.line + 1;
        }
        if (cur_end.ch === 0) {
          end_line -= 1;
        }
        cm.operation(function() {
          cm.replaceRange(end_text, {
            line: end_line,
            ch: 0
          }, {
            line: end_line + (end_text ? 0 : 1),
            ch: 0
          });
          cm.replaceRange(start_text, {
            line: start_line,
            ch: 0
          }, {
            line: start_line + (start_text ? 0 : 1),
            ch: 0
          });
        });
        cm.setSelection({
          line: start_line + (start_text ? 1 : 0),
          ch: 0
        }, {
          line: end_line + (start_text ? 1 : -1),
          ch: 0
        });
        cm.focus();
      } else {
        var search_from = cur_start.line;
        if (fencing_line(cm.getLineHandle(cur_start.line))) {
          if (code_type(cm, cur_start.line + 1) === "fenced") {
            block_start = cur_start.line;
            search_from = cur_start.line + 1;
          } else {
            block_end = cur_start.line;
            search_from = cur_start.line - 1;
          }
        }
        if (block_start === void 0) {
          for (block_start = search_from; block_start >= 0; block_start--) {
            line = cm.getLineHandle(block_start);
            if (fencing_line(line)) {
              break;
            }
          }
        }
        if (block_end === void 0) {
          lineCount = cm.lineCount();
          for (block_end = search_from; block_end < lineCount; block_end++) {
            line = cm.getLineHandle(block_end);
            if (fencing_line(line)) {
              break;
            }
          }
        }
        cm.operation(function() {
          cm.replaceRange("", {
            line: block_start,
            ch: 0
          }, {
            line: block_start + 1,
            ch: 0
          });
          cm.replaceRange("", {
            line: block_end - 1,
            ch: 0
          }, {
            line: block_end,
            ch: 0
          });
        });
        cm.focus();
      }
    } else if (is_code === "indented") {
      if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
        block_start = cur_start.line;
        block_end = cur_end.line;
        if (cur_end.ch === 0) {
          block_end--;
        }
      } else {
        for (block_start = cur_start.line; block_start >= 0; block_start--) {
          line = cm.getLineHandle(block_start);
          if (line.text.match(/^\s*$/)) {
            continue;
          } else {
            if (code_type(cm, block_start, line) !== "indented") {
              block_start += 1;
              break;
            }
          }
        }
        lineCount = cm.lineCount();
        for (block_end = cur_start.line; block_end < lineCount; block_end++) {
          line = cm.getLineHandle(block_end);
          if (line.text.match(/^\s*$/)) {
            continue;
          } else {
            if (code_type(cm, block_end, line) !== "indented") {
              block_end -= 1;
              break;
            }
          }
        }
      }
      var next_line = cm.getLineHandle(block_end + 1), next_line_last_tok = next_line && cm.getTokenAt({
        line: block_end + 1,
        ch: next_line.text.length - 1
      }), next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;
      if (next_line_indented) {
        cm.replaceRange("\n", {
          line: block_end + 1,
          ch: 0
        });
      }
      for (var i2 = block_start; i2 <= block_end; i2++) {
        cm.indentLine(i2, "subtract");
      }
      cm.focus();
    } else {
      var no_sel_and_starting_of_line = cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0;
      var sel_multi = cur_start.line !== cur_end.line;
      if (no_sel_and_starting_of_line || sel_multi) {
        insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);
      } else {
        _replaceSelection(cm, false, ["`", "`"]);
      }
    }
  }
  function toggleBlockquote(editor) {
    _toggleLine(editor.codemirror, "quote");
  }
  function toggleHeadingSmaller(editor) {
    _toggleHeading(editor.codemirror, "smaller");
  }
  function toggleHeadingBigger(editor) {
    _toggleHeading(editor.codemirror, "bigger");
  }
  function toggleHeading1(editor) {
    _toggleHeading(editor.codemirror, void 0, 1);
  }
  function toggleHeading2(editor) {
    _toggleHeading(editor.codemirror, void 0, 2);
  }
  function toggleHeading3(editor) {
    _toggleHeading(editor.codemirror, void 0, 3);
  }
  function toggleHeading4(editor) {
    _toggleHeading(editor.codemirror, void 0, 4);
  }
  function toggleHeading5(editor) {
    _toggleHeading(editor.codemirror, void 0, 5);
  }
  function toggleHeading6(editor) {
    _toggleHeading(editor.codemirror, void 0, 6);
  }
  function toggleUnorderedList(editor) {
    var cm = editor.codemirror;
    var listStyle = "*";
    if (["-", "+", "*"].includes(editor.options.unorderedListStyle)) {
      listStyle = editor.options.unorderedListStyle;
    }
    _toggleLine(cm, "unordered-list", listStyle);
  }
  function toggleOrderedList(editor) {
    _toggleLine(editor.codemirror, "ordered-list");
  }
  function cleanBlock(editor) {
    _cleanBlock(editor.codemirror);
  }
  function drawLink(editor) {
    var options = editor.options;
    var url = "https://";
    if (options.promptURLs) {
      var result = prompt(options.promptTexts.link, url);
      if (!result) {
        return false;
      }
      url = escapePromptURL(result);
    }
    _toggleLink(editor, "link", options.insertTexts.link, url);
  }
  function drawImage(editor) {
    var options = editor.options;
    var url = "https://";
    if (options.promptURLs) {
      var result = prompt(options.promptTexts.image, url);
      if (!result) {
        return false;
      }
      url = escapePromptURL(result);
    }
    _toggleLink(editor, "image", options.insertTexts.image, url);
  }
  function escapePromptURL(url) {
    return encodeURI(url).replace(/([\\()])/g, "\\$1");
  }
  function drawUploadedImage(editor) {
    editor.openBrowseFileWindow();
  }
  function afterImageUploaded(editor, url) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    var imageName = url.substr(url.lastIndexOf("/") + 1);
    var ext = imageName.substring(imageName.lastIndexOf(".") + 1).replace(/\?.*$/, "").toLowerCase();
    if (["png", "jpg", "jpeg", "gif", "svg", "apng", "avif", "webp"].includes(ext)) {
      _replaceSelection(cm, stat.image, options.insertTexts.uploadedImage, url);
    } else {
      var text_link = options.insertTexts.link;
      text_link[0] = "[" + imageName;
      _replaceSelection(cm, stat.link, text_link, url);
    }
    editor.updateStatusBar("upload-image", editor.options.imageTexts.sbOnUploaded.replace("#image_name#", imageName));
    setTimeout(function() {
      editor.updateStatusBar("upload-image", editor.options.imageTexts.sbInit);
    }, 1e3);
  }
  function drawTable(editor) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    _replaceSelection(cm, stat.table, options.insertTexts.table);
  }
  function drawHorizontalRule(editor) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
  }
  function undo(editor) {
    var cm = editor.codemirror;
    cm.undo();
    cm.focus();
  }
  function redo(editor) {
    var cm = editor.codemirror;
    cm.redo();
    cm.focus();
  }
  function toggleSideBySide(editor) {
    var cm = editor.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.nextSibling;
    var toolbarButton = editor.toolbarElements && editor.toolbarElements["side-by-side"];
    var useSideBySideListener = false;
    var easyMDEContainer = wrapper.parentNode;
    if (preview.classList.contains("editor-preview-active-side")) {
      if (editor.options.sideBySideFullscreen === false) {
        easyMDEContainer.classList.remove("sided--no-fullscreen");
      }
      preview.classList.remove("editor-preview-active-side");
      if (toolbarButton) toolbarButton.classList.remove("active");
      wrapper.classList.remove("CodeMirror-sided");
    } else {
      setTimeout(function() {
        if (!cm.getOption("fullScreen")) {
          if (editor.options.sideBySideFullscreen === false) {
            easyMDEContainer.classList.add("sided--no-fullscreen");
          } else {
            toggleFullScreen(editor);
          }
        }
        preview.classList.add("editor-preview-active-side");
      }, 1);
      if (toolbarButton) toolbarButton.classList.add("active");
      wrapper.classList.add("CodeMirror-sided");
      useSideBySideListener = true;
    }
    var previewNormal = wrapper.lastChild;
    if (previewNormal.classList.contains("editor-preview-active")) {
      previewNormal.classList.remove("editor-preview-active");
      var toolbar = editor.toolbarElements.preview;
      var toolbar_div = editor.toolbar_div;
      toolbar.classList.remove("active");
      toolbar_div.classList.remove("disabled-for-preview");
    }
    var sideBySideRenderingFunction = function() {
      var newValue2 = editor.options.previewRender(editor.value(), preview);
      if (newValue2 != null) {
        preview.innerHTML = newValue2;
      }
    };
    if (!cm.sideBySideRenderingFunction) {
      cm.sideBySideRenderingFunction = sideBySideRenderingFunction;
    }
    if (useSideBySideListener) {
      var newValue = editor.options.previewRender(editor.value(), preview);
      if (newValue != null) {
        preview.innerHTML = newValue;
      }
      cm.on("update", cm.sideBySideRenderingFunction);
    } else {
      cm.off("update", cm.sideBySideRenderingFunction);
    }
    cm.refresh();
  }
  function togglePreview(editor) {
    var cm = editor.codemirror;
    var wrapper = cm.getWrapperElement();
    var toolbar_div = editor.toolbar_div;
    var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;
    var preview = wrapper.lastChild;
    var sidebyside = cm.getWrapperElement().nextSibling;
    if (sidebyside.classList.contains("editor-preview-active-side"))
      toggleSideBySide(editor);
    if (!preview || !preview.classList.contains("editor-preview-full")) {
      preview = document.createElement("div");
      preview.className = "editor-preview-full";
      if (editor.options.previewClass) {
        if (Array.isArray(editor.options.previewClass)) {
          for (var i2 = 0; i2 < editor.options.previewClass.length; i2++) {
            preview.classList.add(editor.options.previewClass[i2]);
          }
        } else if (typeof editor.options.previewClass === "string") {
          preview.classList.add(editor.options.previewClass);
        }
      }
      wrapper.appendChild(preview);
    }
    if (preview.classList.contains("editor-preview-active")) {
      preview.classList.remove("editor-preview-active");
      if (toolbar) {
        toolbar.classList.remove("active");
        toolbar_div.classList.remove("disabled-for-preview");
      }
    } else {
      setTimeout(function() {
        preview.classList.add("editor-preview-active");
      }, 1);
      if (toolbar) {
        toolbar.classList.add("active");
        toolbar_div.classList.add("disabled-for-preview");
      }
    }
    var preview_result = editor.options.previewRender(editor.value(), preview);
    if (preview_result !== null) {
      preview.innerHTML = preview_result;
    }
  }
  function _replaceSelection(cm, active, startEnd, url) {
    if (cm.getWrapperElement().lastChild.classList.contains("editor-preview-active"))
      return;
    var text;
    var start2 = startEnd[0];
    var end = startEnd[1];
    var startPoint = {}, endPoint = {};
    Object.assign(startPoint, cm.getCursor("start"));
    Object.assign(endPoint, cm.getCursor("end"));
    if (url) {
      start2 = start2.replace("#url#", url);
      end = end.replace("#url#", url);
    }
    if (active) {
      text = cm.getLine(startPoint.line);
      start2 = text.slice(0, startPoint.ch);
      end = text.slice(startPoint.ch);
      cm.replaceRange(start2 + end, {
        line: startPoint.line,
        ch: 0
      });
    } else {
      text = cm.getSelection();
      cm.replaceSelection(start2 + text + end);
      startPoint.ch += start2.length;
      if (startPoint !== endPoint) {
        endPoint.ch += start2.length;
      }
    }
    cm.setSelection(startPoint, endPoint);
    cm.focus();
  }
  function _toggleHeading(cm, direction, size) {
    if (cm.getWrapperElement().lastChild.classList.contains("editor-preview-active"))
      return;
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    for (var i2 = startPoint.line; i2 <= endPoint.line; i2++) {
      (function(i3) {
        var text = cm.getLine(i3);
        var currHeadingLevel = text.search(/[^#]/);
        if (direction !== void 0) {
          if (currHeadingLevel <= 0) {
            if (direction == "bigger") {
              text = "###### " + text;
            } else {
              text = "# " + text;
            }
          } else if (currHeadingLevel == 6 && direction == "smaller") {
            text = text.substr(7);
          } else if (currHeadingLevel == 1 && direction == "bigger") {
            text = text.substr(2);
          } else {
            if (direction == "bigger") {
              text = text.substr(1);
            } else {
              text = "#" + text;
            }
          }
        } else {
          if (currHeadingLevel <= 0) {
            text = "#".repeat(size) + " " + text;
          } else if (currHeadingLevel == size) {
            text = text.substr(currHeadingLevel + 1);
          } else {
            text = "#".repeat(size) + " " + text.substr(currHeadingLevel + 1);
          }
        }
        cm.replaceRange(text, {
          line: i3,
          ch: 0
        }, {
          line: i3,
          ch: 99999999999999
        });
      })(i2);
    }
    cm.focus();
  }
  function _toggleLine(cm, name, liststyle) {
    if (cm.getWrapperElement().lastChild.classList.contains("editor-preview-active"))
      return;
    var listRegexp = /^(\s*)(\*|-|\+|\d*\.)(\s+)/;
    var whitespacesRegexp = /^\s*/;
    var stat = getState(cm);
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    var repl = {
      "quote": /^(\s*)>\s+/,
      "unordered-list": listRegexp,
      "ordered-list": listRegexp
    };
    var _getChar = function(name2, i3) {
      var map2 = {
        "quote": ">",
        "unordered-list": liststyle,
        "ordered-list": "%%i."
      };
      return map2[name2].replace("%%i", i3);
    };
    var _checkChar = function(name2, char) {
      var map2 = {
        "quote": ">",
        "unordered-list": "\\" + liststyle,
        "ordered-list": "\\d+."
      };
      var rt = new RegExp(map2[name2]);
      return char && rt.test(char);
    };
    var _toggle = function(name2, text, untoggleOnly) {
      var arr = listRegexp.exec(text);
      var char = _getChar(name2, line);
      if (arr !== null) {
        if (_checkChar(name2, arr[2])) {
          char = "";
        }
        text = arr[1] + char + arr[3] + text.replace(whitespacesRegexp, "").replace(repl[name2], "$1");
      } else if (untoggleOnly == false) {
        text = char + " " + text;
      }
      return text;
    };
    var line = 1;
    for (var i2 = startPoint.line; i2 <= endPoint.line; i2++) {
      (function(i3) {
        var text = cm.getLine(i3);
        if (stat[name]) {
          text = text.replace(repl[name], "$1");
        } else {
          if (name == "unordered-list") {
            text = _toggle("ordered-list", text, true);
          }
          text = _toggle(name, text, false);
          line += 1;
        }
        cm.replaceRange(text, {
          line: i3,
          ch: 0
        }, {
          line: i3,
          ch: 99999999999999
        });
      })(i2);
    }
    cm.focus();
  }
  function _toggleLink(editor, type2, startEnd, url) {
    if (!editor.codemirror || editor.isPreviewActive()) {
      return;
    }
    var cm = editor.codemirror;
    var stat = getState(cm);
    var active = stat[type2];
    if (!active) {
      _replaceSelection(cm, active, startEnd, url);
      return;
    }
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    var text = cm.getLine(startPoint.line);
    var start2 = text.slice(0, startPoint.ch);
    var end = text.slice(startPoint.ch);
    if (type2 == "link") {
      start2 = start2.replace(/(.*)[^!]\[/, "$1");
    } else if (type2 == "image") {
      start2 = start2.replace(/(.*)!\[$/, "$1");
    }
    end = end.replace(/]\(.*?\)/, "");
    cm.replaceRange(start2 + end, {
      line: startPoint.line,
      ch: 0
    }, {
      line: startPoint.line,
      ch: 99999999999999
    });
    startPoint.ch -= startEnd[0].length;
    if (startPoint !== endPoint) {
      endPoint.ch -= startEnd[0].length;
    }
    cm.setSelection(startPoint, endPoint);
    cm.focus();
  }
  function _toggleBlock(editor, type2, start_chars, end_chars) {
    if (!editor.codemirror || editor.isPreviewActive()) {
      return;
    }
    end_chars = typeof end_chars === "undefined" ? start_chars : end_chars;
    var cm = editor.codemirror;
    var stat = getState(cm);
    var text;
    var start2 = start_chars;
    var end = end_chars;
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    if (stat[type2]) {
      text = cm.getLine(startPoint.line);
      start2 = text.slice(0, startPoint.ch);
      end = text.slice(startPoint.ch);
      if (type2 == "bold") {
        start2 = start2.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");
        end = end.replace(/(\*\*|__)/, "");
      } else if (type2 == "italic") {
        start2 = start2.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");
        end = end.replace(/(\*|_)/, "");
      } else if (type2 == "strikethrough") {
        start2 = start2.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");
        end = end.replace(/(\*\*|~~)/, "");
      }
      cm.replaceRange(start2 + end, {
        line: startPoint.line,
        ch: 0
      }, {
        line: startPoint.line,
        ch: 99999999999999
      });
      if (type2 == "bold" || type2 == "strikethrough") {
        startPoint.ch -= 2;
        if (startPoint !== endPoint) {
          endPoint.ch -= 2;
        }
      } else if (type2 == "italic") {
        startPoint.ch -= 1;
        if (startPoint !== endPoint) {
          endPoint.ch -= 1;
        }
      }
    } else {
      text = cm.getSelection();
      if (type2 == "bold") {
        text = text.split("**").join("");
        text = text.split("__").join("");
      } else if (type2 == "italic") {
        text = text.split("*").join("");
        text = text.split("_").join("");
      } else if (type2 == "strikethrough") {
        text = text.split("~~").join("");
      }
      cm.replaceSelection(start2 + text + end);
      startPoint.ch += start_chars.length;
      endPoint.ch = startPoint.ch + text.length;
    }
    cm.setSelection(startPoint, endPoint);
    cm.focus();
  }
  function _cleanBlock(cm) {
    if (cm.getWrapperElement().lastChild.classList.contains("editor-preview-active"))
      return;
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    var text;
    for (var line = startPoint.line; line <= endPoint.line; line++) {
      text = cm.getLine(line);
      text = text.replace(/^[ ]*([# ]+|\*|-|[> ]+|[0-9]+(.|\)))[ ]*/, "");
      cm.replaceRange(text, {
        line,
        ch: 0
      }, {
        line,
        ch: 99999999999999
      });
    }
  }
  function humanFileSize(bytes, units) {
    if (Math.abs(bytes) < 1024) {
      return "" + bytes + units[0];
    }
    var u2 = 0;
    do {
      bytes /= 1024;
      ++u2;
    } while (Math.abs(bytes) >= 1024 && u2 < units.length);
    return "" + bytes.toFixed(1) + units[u2];
  }
  function _mergeProperties(target, source) {
    for (var property in source) {
      if (Object.prototype.hasOwnProperty.call(source, property)) {
        if (source[property] instanceof Array) {
          target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);
        } else if (source[property] !== null && typeof source[property] === "object" && source[property].constructor === Object) {
          target[property] = _mergeProperties(target[property] || {}, source[property]);
        } else {
          target[property] = source[property];
        }
      }
    }
    return target;
  }
  function extend$2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      target = _mergeProperties(target, arguments[i2]);
    }
    return target;
  }
  function wordCount(data) {
    var pattern = /[a-zA-Z0-9_\u00A0-\u02AF\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;
    var m2 = data.match(pattern);
    var count = 0;
    if (m2 === null) return count;
    for (var i2 = 0; i2 < m2.length; i2++) {
      if (m2[i2].charCodeAt(0) >= 19968) {
        count += m2[i2].length;
      } else {
        count += 1;
      }
    }
    return count;
  }
  var iconClassMap = {
    "bold": "fa fa-bold",
    "italic": "fa fa-italic",
    "strikethrough": "fa fa-strikethrough",
    "heading": "fa fa-header fa-heading",
    "heading-smaller": "fa fa-header fa-heading header-smaller",
    "heading-bigger": "fa fa-header fa-heading header-bigger",
    "heading-1": "fa fa-header fa-heading header-1",
    "heading-2": "fa fa-header fa-heading header-2",
    "heading-3": "fa fa-header fa-heading header-3",
    "code": "fa fa-code",
    "quote": "fa fa-quote-left",
    "ordered-list": "fa fa-list-ol",
    "unordered-list": "fa fa-list-ul",
    "clean-block": "fa fa-eraser",
    "link": "fa fa-link",
    "image": "fa fa-image",
    "upload-image": "fa fa-image",
    "table": "fa fa-table",
    "horizontal-rule": "fa fa-minus",
    "preview": "fa fa-eye",
    "side-by-side": "fa fa-columns",
    "fullscreen": "fa fa-arrows-alt",
    "guide": "fa fa-question-circle",
    "undo": "fa fa-undo",
    "redo": "fa fa-repeat fa-redo"
  };
  var toolbarBuiltInButtons = {
    "bold": {
      name: "bold",
      action: toggleBold,
      className: iconClassMap["bold"],
      title: "Bold",
      default: true
    },
    "italic": {
      name: "italic",
      action: toggleItalic,
      className: iconClassMap["italic"],
      title: "Italic",
      default: true
    },
    "strikethrough": {
      name: "strikethrough",
      action: toggleStrikethrough,
      className: iconClassMap["strikethrough"],
      title: "Strikethrough"
    },
    "heading": {
      name: "heading",
      action: toggleHeadingSmaller,
      className: iconClassMap["heading"],
      title: "Heading",
      default: true
    },
    "heading-smaller": {
      name: "heading-smaller",
      action: toggleHeadingSmaller,
      className: iconClassMap["heading-smaller"],
      title: "Smaller Heading"
    },
    "heading-bigger": {
      name: "heading-bigger",
      action: toggleHeadingBigger,
      className: iconClassMap["heading-bigger"],
      title: "Bigger Heading"
    },
    "heading-1": {
      name: "heading-1",
      action: toggleHeading1,
      className: iconClassMap["heading-1"],
      title: "Big Heading"
    },
    "heading-2": {
      name: "heading-2",
      action: toggleHeading2,
      className: iconClassMap["heading-2"],
      title: "Medium Heading"
    },
    "heading-3": {
      name: "heading-3",
      action: toggleHeading3,
      className: iconClassMap["heading-3"],
      title: "Small Heading"
    },
    "separator-1": {
      name: "separator-1"
    },
    "code": {
      name: "code",
      action: toggleCodeBlock,
      className: iconClassMap["code"],
      title: "Code"
    },
    "quote": {
      name: "quote",
      action: toggleBlockquote,
      className: iconClassMap["quote"],
      title: "Quote",
      default: true
    },
    "unordered-list": {
      name: "unordered-list",
      action: toggleUnorderedList,
      className: iconClassMap["unordered-list"],
      title: "Generic List",
      default: true
    },
    "ordered-list": {
      name: "ordered-list",
      action: toggleOrderedList,
      className: iconClassMap["ordered-list"],
      title: "Numbered List",
      default: true
    },
    "clean-block": {
      name: "clean-block",
      action: cleanBlock,
      className: iconClassMap["clean-block"],
      title: "Clean block"
    },
    "separator-2": {
      name: "separator-2"
    },
    "link": {
      name: "link",
      action: drawLink,
      className: iconClassMap["link"],
      title: "Create Link",
      default: true
    },
    "image": {
      name: "image",
      action: drawImage,
      className: iconClassMap["image"],
      title: "Insert Image",
      default: true
    },
    "upload-image": {
      name: "upload-image",
      action: drawUploadedImage,
      className: iconClassMap["upload-image"],
      title: "Import an image"
    },
    "table": {
      name: "table",
      action: drawTable,
      className: iconClassMap["table"],
      title: "Insert Table"
    },
    "horizontal-rule": {
      name: "horizontal-rule",
      action: drawHorizontalRule,
      className: iconClassMap["horizontal-rule"],
      title: "Insert Horizontal Line"
    },
    "separator-3": {
      name: "separator-3"
    },
    "preview": {
      name: "preview",
      action: togglePreview,
      className: iconClassMap["preview"],
      noDisable: true,
      title: "Toggle Preview",
      default: true
    },
    "side-by-side": {
      name: "side-by-side",
      action: toggleSideBySide,
      className: iconClassMap["side-by-side"],
      noDisable: true,
      noMobile: true,
      title: "Toggle Side by Side",
      default: true
    },
    "fullscreen": {
      name: "fullscreen",
      action: toggleFullScreen,
      className: iconClassMap["fullscreen"],
      noDisable: true,
      noMobile: true,
      title: "Toggle Fullscreen",
      default: true
    },
    "separator-4": {
      name: "separator-4"
    },
    "guide": {
      name: "guide",
      action: "https://www.markdownguide.org/basic-syntax/",
      className: iconClassMap["guide"],
      noDisable: true,
      title: "Markdown Guide",
      default: true
    },
    "separator-5": {
      name: "separator-5"
    },
    "undo": {
      name: "undo",
      action: undo,
      className: iconClassMap["undo"],
      noDisable: true,
      title: "Undo"
    },
    "redo": {
      name: "redo",
      action: redo,
      className: iconClassMap["redo"],
      noDisable: true,
      title: "Redo"
    }
  };
  var insertTexts = {
    link: ["[", "](#url#)"],
    image: ["![", "](#url#)"],
    uploadedImage: ["![](#url#)", ""],
    // uploadedImage: ['![](#url#)\n', ''], // TODO: New line insertion doesn't work here.
    table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],
    horizontalRule: ["", "\n\n-----\n\n"]
  };
  var promptTexts = {
    link: "URL for the link:",
    image: "URL of the image:"
  };
  var timeFormat = {
    locale: "en-US",
    format: {
      hour: "2-digit",
      minute: "2-digit"
    }
  };
  var blockStyles = {
    "bold": "**",
    "code": "```",
    "italic": "*"
  };
  var imageTexts = {
    sbInit: "Attach files by drag and dropping or pasting from clipboard.",
    sbOnDragEnter: "Drop image to upload it.",
    sbOnDrop: "Uploading image #images_names#...",
    sbProgress: "Uploading #file_name#: #progress#%",
    sbOnUploaded: "Uploaded #image_name#",
    sizeUnits: " B, KB, MB"
  };
  var errorMessages = {
    noFileGiven: "You must select a file.",
    typeNotAllowed: "This image type is not allowed.",
    fileTooLarge: "Image #image_name# is too big (#image_size#).\nMaximum file size is #image_max_size#.",
    importError: "Something went wrong when uploading the image #image_name#."
  };
  function EasyMDE(options) {
    options = options || {};
    options.parent = this;
    var autoDownloadFA = true;
    if (options.autoDownloadFontAwesome === false) {
      autoDownloadFA = false;
    }
    if (options.autoDownloadFontAwesome !== true) {
      var styleSheets = document.styleSheets;
      for (var i2 = 0; i2 < styleSheets.length; i2++) {
        if (!styleSheets[i2].href)
          continue;
        if (styleSheets[i2].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") > -1) {
          autoDownloadFA = false;
        }
      }
    }
    if (autoDownloadFA) {
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    }
    if (options.element) {
      this.element = options.element;
    } else if (options.element === null) {
      console.log("EasyMDE: Error. No element was found.");
      return;
    }
    if (options.toolbar === void 0) {
      options.toolbar = [];
      for (var key in toolbarBuiltInButtons) {
        if (Object.prototype.hasOwnProperty.call(toolbarBuiltInButtons, key)) {
          if (key.indexOf("separator-") != -1) {
            options.toolbar.push("|");
          }
          if (toolbarBuiltInButtons[key].default === true || options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1) {
            options.toolbar.push(key);
          }
        }
      }
    }
    if (!Object.prototype.hasOwnProperty.call(options, "previewClass")) {
      options.previewClass = "editor-preview";
    }
    if (!Object.prototype.hasOwnProperty.call(options, "status")) {
      options.status = ["autosave", "lines", "words", "cursor"];
      if (options.uploadImage) {
        options.status.unshift("upload-image");
      }
    }
    if (!options.previewRender) {
      options.previewRender = function(plainText) {
        return this.parent.markdown(plainText);
      };
    }
    options.parsingConfig = extend$2({
      highlightFormatting: true
      // needed for toggleCodeBlock to detect types of code
    }, options.parsingConfig || {});
    options.insertTexts = extend$2({}, insertTexts, options.insertTexts || {});
    options.promptTexts = extend$2({}, promptTexts, options.promptTexts || {});
    options.blockStyles = extend$2({}, blockStyles, options.blockStyles || {});
    if (options.autosave != void 0) {
      options.autosave.timeFormat = extend$2({}, timeFormat, options.autosave.timeFormat || {});
    }
    options.iconClassMap = extend$2({}, iconClassMap, options.iconClassMap || {});
    options.shortcuts = extend$2({}, shortcuts, options.shortcuts || {});
    options.maxHeight = options.maxHeight || void 0;
    options.direction = options.direction || "ltr";
    if (typeof options.maxHeight !== "undefined") {
      options.minHeight = options.maxHeight;
    } else {
      options.minHeight = options.minHeight || "300px";
    }
    options.errorCallback = options.errorCallback || function(errorMessage) {
      alert(errorMessage);
    };
    options.uploadImage = options.uploadImage || false;
    options.imageMaxSize = options.imageMaxSize || 2097152;
    options.imageAccept = options.imageAccept || "image/png, image/jpeg, image/gif, image/avif";
    options.imageTexts = extend$2({}, imageTexts, options.imageTexts || {});
    options.errorMessages = extend$2({}, errorMessages, options.errorMessages || {});
    options.imagePathAbsolute = options.imagePathAbsolute || false;
    options.imageCSRFName = options.imageCSRFName || "csrfmiddlewaretoken";
    options.imageCSRFHeader = options.imageCSRFHeader || false;
    options.imageInputName = options.imageInputName || "image";
    if (options.autosave != void 0 && options.autosave.unique_id != void 0 && options.autosave.unique_id != "")
      options.autosave.uniqueId = options.autosave.unique_id;
    if (options.overlayMode && options.overlayMode.combine === void 0) {
      options.overlayMode.combine = true;
    }
    this.options = options;
    this.render();
    if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {
      this.value(options.initialValue);
    }
    if (options.uploadImage) {
      var self2 = this;
      this.codemirror.on("dragenter", function(cm, event) {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbOnDragEnter);
        event.stopPropagation();
        event.preventDefault();
      });
      this.codemirror.on("dragend", function(cm, event) {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbInit);
        event.stopPropagation();
        event.preventDefault();
      });
      this.codemirror.on("dragleave", function(cm, event) {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbInit);
        event.stopPropagation();
        event.preventDefault();
      });
      this.codemirror.on("dragover", function(cm, event) {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbOnDragEnter);
        event.stopPropagation();
        event.preventDefault();
      });
      this.codemirror.on("drop", function(cm, event) {
        event.stopPropagation();
        event.preventDefault();
        if (options.imageUploadFunction) {
          self2.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.dataTransfer.files);
        } else {
          self2.uploadImages(event.dataTransfer.files);
        }
      });
      this.codemirror.on("paste", function(cm, event) {
        if (options.imageUploadFunction) {
          self2.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.clipboardData.files);
        } else {
          self2.uploadImages(event.clipboardData.files);
        }
      });
    }
  }
  EasyMDE.prototype.uploadImages = function(files, onSuccess, onError) {
    if (files.length === 0) {
      return;
    }
    var names2 = [];
    for (var i2 = 0; i2 < files.length; i2++) {
      names2.push(files[i2].name);
      this.uploadImage(files[i2], onSuccess, onError);
    }
    this.updateStatusBar("upload-image", this.options.imageTexts.sbOnDrop.replace("#images_names#", names2.join(", ")));
  };
  EasyMDE.prototype.uploadImagesUsingCustomFunction = function(imageUploadFunction, files) {
    if (files.length === 0) {
      return;
    }
    var names2 = [];
    for (var i2 = 0; i2 < files.length; i2++) {
      names2.push(files[i2].name);
      this.uploadImageUsingCustomFunction(imageUploadFunction, files[i2]);
    }
    this.updateStatusBar("upload-image", this.options.imageTexts.sbOnDrop.replace("#images_names#", names2.join(", ")));
  };
  EasyMDE.prototype.updateStatusBar = function(itemName, content) {
    if (!this.gui.statusbar) {
      return;
    }
    var matchingClasses = this.gui.statusbar.getElementsByClassName(itemName);
    if (matchingClasses.length === 1) {
      this.gui.statusbar.getElementsByClassName(itemName)[0].textContent = content;
    } else if (matchingClasses.length === 0) {
      console.log("EasyMDE: status bar item " + itemName + " was not found.");
    } else {
      console.log("EasyMDE: Several status bar items named " + itemName + " was found.");
    }
  };
  EasyMDE.prototype.markdown = function(text) {
    if (marked) {
      var markedOptions;
      if (this.options && this.options.renderingConfig && this.options.renderingConfig.markedOptions) {
        markedOptions = this.options.renderingConfig.markedOptions;
      } else {
        markedOptions = {};
      }
      if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {
        markedOptions.breaks = false;
      } else {
        markedOptions.breaks = true;
      }
      if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true) {
        var hljs = this.options.renderingConfig.hljs || window.hljs;
        if (hljs) {
          markedOptions.highlight = function(code, language) {
            if (language && hljs.getLanguage(language)) {
              return hljs.highlight(language, code).value;
            } else {
              return hljs.highlightAuto(code).value;
            }
          };
        }
      }
      marked.use(markedOptions);
      var htmlText = marked.parse(text);
      if (this.options.renderingConfig && typeof this.options.renderingConfig.sanitizerFunction === "function") {
        htmlText = this.options.renderingConfig.sanitizerFunction.call(this, htmlText);
      }
      htmlText = addAnchorTargetBlank(htmlText);
      htmlText = removeListStyleWhenCheckbox(htmlText);
      return htmlText;
    }
  };
  EasyMDE.prototype.render = function(el) {
    if (!el) {
      el = this.element || document.getElementsByTagName("textarea")[0];
    }
    if (this._rendered && this._rendered === el) {
      return;
    }
    this.element = el;
    var options = this.options;
    var self2 = this;
    var keyMaps = {};
    for (var key in options.shortcuts) {
      if (options.shortcuts[key] !== null && bindings[key] !== null) {
        (function(key2) {
          keyMaps[fixShortcut(options.shortcuts[key2])] = function() {
            var action = bindings[key2];
            if (typeof action === "function") {
              action(self2);
            } else if (typeof action === "string") {
              window.open(action, "_blank");
            }
          };
        })(key);
      }
    }
    keyMaps["Enter"] = "newlineAndIndentContinueMarkdownList";
    keyMaps["Tab"] = "tabAndIndentMarkdownList";
    keyMaps["Shift-Tab"] = "shiftTabAndUnindentMarkdownList";
    keyMaps["Esc"] = function(cm2) {
      if (cm2.getOption("fullScreen")) toggleFullScreen(self2);
    };
    this.documentOnKeyDown = function(e2) {
      e2 = e2 || window.event;
      if (e2.keyCode == 27) {
        if (self2.codemirror.getOption("fullScreen")) toggleFullScreen(self2);
      }
    };
    document.addEventListener("keydown", this.documentOnKeyDown, false);
    var mode, backdrop;
    if (options.overlayMode) {
      CodeMirror.defineMode("overlay-mode", function(config) {
        return CodeMirror.overlayMode(CodeMirror.getMode(config, options.spellChecker !== false ? "spell-checker" : "gfm"), options.overlayMode.mode, options.overlayMode.combine);
      });
      mode = "overlay-mode";
      backdrop = options.parsingConfig;
      backdrop.gitHubSpice = false;
    } else {
      mode = options.parsingConfig;
      mode.name = "gfm";
      mode.gitHubSpice = false;
    }
    if (options.spellChecker !== false) {
      mode = "spell-checker";
      backdrop = options.parsingConfig;
      backdrop.name = "gfm";
      backdrop.gitHubSpice = false;
      if (typeof options.spellChecker === "function") {
        options.spellChecker({
          codeMirrorInstance: CodeMirror
        });
      } else {
        CodeMirrorSpellChecker({
          codeMirrorInstance: CodeMirror
        });
      }
    }
    function configureMouse(cm2, repeat2, event) {
      return {
        addNew: false
      };
    }
    this.codemirror = CodeMirror.fromTextArea(el, {
      mode,
      backdrop,
      theme: options.theme != void 0 ? options.theme : "easymde",
      tabSize: options.tabSize != void 0 ? options.tabSize : 2,
      indentUnit: options.tabSize != void 0 ? options.tabSize : 2,
      indentWithTabs: options.indentWithTabs === false ? false : true,
      lineNumbers: options.lineNumbers === true ? true : false,
      autofocus: options.autofocus === true ? true : false,
      extraKeys: keyMaps,
      direction: options.direction,
      lineWrapping: options.lineWrapping === false ? false : true,
      allowDropFileTypes: ["text/plain"],
      placeholder: options.placeholder || el.getAttribute("placeholder") || "",
      styleSelectedText: options.styleSelectedText != void 0 ? options.styleSelectedText : !isMobile(),
      scrollbarStyle: options.scrollbarStyle != void 0 ? options.scrollbarStyle : "native",
      configureMouse,
      inputStyle: options.inputStyle != void 0 ? options.inputStyle : isMobile() ? "contenteditable" : "textarea",
      spellcheck: options.nativeSpellcheck != void 0 ? options.nativeSpellcheck : true,
      autoRefresh: options.autoRefresh != void 0 ? options.autoRefresh : false
    });
    this.codemirror.getScrollerElement().style.minHeight = options.minHeight;
    if (typeof options.maxHeight !== "undefined") {
      this.codemirror.getScrollerElement().style.height = options.maxHeight;
    }
    if (options.forceSync === true) {
      var cm = this.codemirror;
      cm.on("change", function() {
        cm.save();
      });
    }
    this.gui = {};
    var easyMDEContainer = document.createElement("div");
    easyMDEContainer.classList.add("EasyMDEContainer");
    easyMDEContainer.setAttribute("role", "application");
    var cmWrapper = this.codemirror.getWrapperElement();
    cmWrapper.parentNode.insertBefore(easyMDEContainer, cmWrapper);
    easyMDEContainer.appendChild(cmWrapper);
    if (options.toolbar !== false) {
      this.gui.toolbar = this.createToolbar();
    }
    if (options.status !== false) {
      this.gui.statusbar = this.createStatusbar();
    }
    if (options.autosave != void 0 && options.autosave.enabled === true) {
      this.autosave();
      this.codemirror.on("change", function() {
        clearTimeout(self2._autosave_timeout);
        self2._autosave_timeout = setTimeout(function() {
          self2.autosave();
        }, self2.options.autosave.submit_delay || self2.options.autosave.delay || 1e3);
      });
    }
    function calcHeight(naturalWidth, naturalHeight) {
      var height;
      var viewportWidth = window.getComputedStyle(document.querySelector(".CodeMirror-sizer")).width.replace("px", "");
      if (naturalWidth < viewportWidth) {
        height = naturalHeight + "px";
      } else {
        height = naturalHeight / naturalWidth * 100 + "%";
      }
      return height;
    }
    var _vm = this;
    function assignImageBlockAttributes(parentEl, img) {
      var url = new URL(img.url, document.baseURI).href;
      parentEl.setAttribute("data-img-src", url);
      parentEl.setAttribute("style", "--bg-image:url(" + url + ");--width:" + img.naturalWidth + "px;--height:" + calcHeight(img.naturalWidth, img.naturalHeight));
      _vm.codemirror.setSize();
    }
    function handleImages() {
      if (!options.previewImagesInEditor) {
        return;
      }
      easyMDEContainer.querySelectorAll(".cm-image-marker").forEach(function(e2) {
        var parentEl = e2.parentElement;
        if (!parentEl.innerText.match(/^!\[.*?\]\(.*\)/g)) {
          return;
        }
        if (!parentEl.hasAttribute("data-img-src")) {
          var srcAttr = parentEl.innerText.match(/!\[.*?\]\((.*?)\)/);
          if (!window.EMDEimagesCache) {
            window.EMDEimagesCache = {};
          }
          if (srcAttr && srcAttr.length >= 2) {
            var keySrc = srcAttr[1];
            if (options.imagesPreviewHandler) {
              var newSrc = options.imagesPreviewHandler(srcAttr[1]);
              if (typeof newSrc === "string") {
                keySrc = newSrc;
              }
            }
            if (!window.EMDEimagesCache[keySrc]) {
              window.EMDEimagesCache[keySrc] = {};
              var img = document.createElement("img");
              img.onload = function() {
                window.EMDEimagesCache[keySrc] = {
                  naturalWidth: img.naturalWidth,
                  naturalHeight: img.naturalHeight,
                  url: keySrc
                };
                assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);
              };
              img.src = keySrc;
            } else {
              assignImageBlockAttributes(parentEl, window.EMDEimagesCache[keySrc]);
            }
          }
        }
      });
    }
    this.codemirror.on("update", function() {
      handleImages();
    });
    this.gui.sideBySide = this.createSideBySide();
    this._rendered = this.element;
    if (options.autofocus === true || el.autofocus) {
      this.codemirror.focus();
    }
    var temp_cm = this.codemirror;
    setTimeout((function() {
      temp_cm.refresh();
    }).bind(temp_cm), 0);
  };
  EasyMDE.prototype.cleanup = function() {
    document.removeEventListener("keydown", this.documentOnKeyDown);
  };
  function isLocalStorageAvailable() {
    if (typeof localStorage === "object") {
      try {
        localStorage.setItem("smde_localStorage", 1);
        localStorage.removeItem("smde_localStorage");
      } catch (e2) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  EasyMDE.prototype.autosave = function() {
    if (isLocalStorageAvailable()) {
      var easyMDE2 = this;
      if (this.options.autosave.uniqueId == void 0 || this.options.autosave.uniqueId == "") {
        console.log("EasyMDE: You must set a uniqueId to use the autosave feature");
        return;
      }
      if (this.options.autosave.binded !== true) {
        if (easyMDE2.element.form != null && easyMDE2.element.form != void 0) {
          easyMDE2.element.form.addEventListener("submit", function() {
            clearTimeout(easyMDE2.autosaveTimeoutId);
            easyMDE2.autosaveTimeoutId = void 0;
            localStorage.removeItem("smde_" + easyMDE2.options.autosave.uniqueId);
          });
        }
        this.options.autosave.binded = true;
      }
      if (this.options.autosave.loaded !== true) {
        if (typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) == "string" && localStorage.getItem("smde_" + this.options.autosave.uniqueId) != "") {
          this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId));
          this.options.autosave.foundSavedValue = true;
        }
        this.options.autosave.loaded = true;
      }
      var value = easyMDE2.value();
      if (value !== "") {
        localStorage.setItem("smde_" + this.options.autosave.uniqueId, value);
      } else {
        localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
      }
      var el = document.getElementById("autosaved");
      if (el != null && el != void 0 && el != "") {
        var d2 = /* @__PURE__ */ new Date();
        var dd = new Intl.DateTimeFormat([this.options.autosave.timeFormat.locale, "en-US"], this.options.autosave.timeFormat.format).format(d2);
        var save = this.options.autosave.text == void 0 ? "Autosaved: " : this.options.autosave.text;
        el.innerHTML = save + dd;
      }
    } else {
      console.log("EasyMDE: localStorage not available, cannot autosave");
    }
  };
  EasyMDE.prototype.clearAutosavedValue = function() {
    if (isLocalStorageAvailable()) {
      if (this.options.autosave == void 0 || this.options.autosave.uniqueId == void 0 || this.options.autosave.uniqueId == "") {
        console.log("EasyMDE: You must set a uniqueId to clear the autosave value");
        return;
      }
      localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
    } else {
      console.log("EasyMDE: localStorage not available, cannot autosave");
    }
  };
  EasyMDE.prototype.openBrowseFileWindow = function(onSuccess, onError) {
    var self2 = this;
    var imageInput = this.gui.toolbar.getElementsByClassName("imageInput")[0];
    imageInput.click();
    function onChange(event) {
      if (self2.options.imageUploadFunction) {
        self2.uploadImagesUsingCustomFunction(self2.options.imageUploadFunction, event.target.files);
      } else {
        self2.uploadImages(event.target.files, onSuccess, onError);
      }
      imageInput.removeEventListener("change", onChange);
    }
    imageInput.addEventListener("change", onChange);
  };
  EasyMDE.prototype.uploadImage = function(file, onSuccess, onError) {
    var self2 = this;
    onSuccess = onSuccess || function onSuccess2(imageUrl) {
      afterImageUploaded(self2, imageUrl);
    };
    function onErrorSup(errorMessage) {
      self2.updateStatusBar("upload-image", errorMessage);
      setTimeout(function() {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbInit);
      }, 1e4);
      if (onError && typeof onError === "function") {
        onError(errorMessage);
      }
      self2.options.errorCallback(errorMessage);
    }
    function fillErrorMessage(errorMessage) {
      var units = self2.options.imageTexts.sizeUnits.split(",");
      return errorMessage.replace("#image_name#", file.name).replace("#image_size#", humanFileSize(file.size, units)).replace("#image_max_size#", humanFileSize(self2.options.imageMaxSize, units));
    }
    if (file.size > this.options.imageMaxSize) {
      onErrorSup(fillErrorMessage(this.options.errorMessages.fileTooLarge));
      return;
    }
    var formData = new FormData();
    formData.append("image", file);
    if (self2.options.imageCSRFToken && !self2.options.imageCSRFHeader) {
      formData.append(self2.options.imageCSRFName, self2.options.imageCSRFToken);
    }
    var request = new XMLHttpRequest();
    request.upload.onprogress = function(event) {
      if (event.lengthComputable) {
        var progress = "" + Math.round(event.loaded * 100 / event.total);
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbProgress.replace("#file_name#", file.name).replace("#progress#", progress));
      }
    };
    request.open("POST", this.options.imageUploadEndpoint);
    if (self2.options.imageCSRFToken && self2.options.imageCSRFHeader) {
      request.setRequestHeader(self2.options.imageCSRFName, self2.options.imageCSRFToken);
    }
    request.onload = function() {
      try {
        var response = JSON.parse(this.responseText);
      } catch (error) {
        console.error("EasyMDE: The server did not return a valid json.");
        onErrorSup(fillErrorMessage(self2.options.errorMessages.importError));
        return;
      }
      if (this.status === 200 && response && !response.error && response.data && response.data.filePath) {
        onSuccess((self2.options.imagePathAbsolute ? "" : window.location.origin + "/") + response.data.filePath);
      } else {
        if (response.error && response.error in self2.options.errorMessages) {
          onErrorSup(fillErrorMessage(self2.options.errorMessages[response.error]));
        } else if (response.error) {
          onErrorSup(fillErrorMessage(response.error));
        } else {
          console.error("EasyMDE: Received an unexpected response after uploading the image." + this.status + " (" + this.statusText + ")");
          onErrorSup(fillErrorMessage(self2.options.errorMessages.importError));
        }
      }
    };
    request.onerror = function(event) {
      console.error("EasyMDE: An unexpected error occurred when trying to upload the image." + event.target.status + " (" + event.target.statusText + ")");
      onErrorSup(self2.options.errorMessages.importError);
    };
    request.send(formData);
  };
  EasyMDE.prototype.uploadImageUsingCustomFunction = function(imageUploadFunction, file) {
    var self2 = this;
    function onSuccess(imageUrl) {
      afterImageUploaded(self2, imageUrl);
    }
    function onError(errorMessage) {
      var filledErrorMessage = fillErrorMessage(errorMessage);
      self2.updateStatusBar("upload-image", filledErrorMessage);
      setTimeout(function() {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbInit);
      }, 1e4);
      self2.options.errorCallback(filledErrorMessage);
    }
    function fillErrorMessage(errorMessage) {
      var units = self2.options.imageTexts.sizeUnits.split(",");
      return errorMessage.replace("#image_name#", file.name).replace("#image_size#", humanFileSize(file.size, units)).replace("#image_max_size#", humanFileSize(self2.options.imageMaxSize, units));
    }
    imageUploadFunction.apply(this, [file, onSuccess, onError]);
  };
  EasyMDE.prototype.setPreviewMaxHeight = function() {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.nextSibling;
    var paddingTop = parseInt(window.getComputedStyle(wrapper).paddingTop);
    var borderTopWidth = parseInt(window.getComputedStyle(wrapper).borderTopWidth);
    var optionsMaxHeight = parseInt(this.options.maxHeight);
    var wrapperMaxHeight = optionsMaxHeight + paddingTop * 2 + borderTopWidth * 2;
    var previewMaxHeight = wrapperMaxHeight.toString() + "px";
    preview.style.height = previewMaxHeight;
  };
  EasyMDE.prototype.createSideBySide = function() {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.nextSibling;
    if (!preview || !preview.classList.contains("editor-preview-side")) {
      preview = document.createElement("div");
      preview.className = "editor-preview-side";
      if (this.options.previewClass) {
        if (Array.isArray(this.options.previewClass)) {
          for (var i2 = 0; i2 < this.options.previewClass.length; i2++) {
            preview.classList.add(this.options.previewClass[i2]);
          }
        } else if (typeof this.options.previewClass === "string") {
          preview.classList.add(this.options.previewClass);
        }
      }
      wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);
    }
    if (typeof this.options.maxHeight !== "undefined") {
      this.setPreviewMaxHeight();
    }
    if (this.options.syncSideBySidePreviewScroll === false) return preview;
    var cScroll = false;
    var pScroll = false;
    cm.on("scroll", function(v2) {
      if (cScroll) {
        cScroll = false;
        return;
      }
      pScroll = true;
      var height = v2.getScrollInfo().height - v2.getScrollInfo().clientHeight;
      var ratio = parseFloat(v2.getScrollInfo().top) / height;
      var move = (preview.scrollHeight - preview.clientHeight) * ratio;
      preview.scrollTop = move;
    });
    preview.onscroll = function() {
      if (pScroll) {
        pScroll = false;
        return;
      }
      cScroll = true;
      var height = preview.scrollHeight - preview.clientHeight;
      var ratio = parseFloat(preview.scrollTop) / height;
      var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;
      cm.scrollTo(0, move);
    };
    return preview;
  };
  EasyMDE.prototype.createToolbar = function(items) {
    items = items || this.options.toolbar;
    if (!items || items.length === 0) {
      return;
    }
    var i2;
    for (i2 = 0; i2 < items.length; i2++) {
      if (toolbarBuiltInButtons[items[i2]] != void 0) {
        items[i2] = toolbarBuiltInButtons[items[i2]];
      }
    }
    var bar = document.createElement("div");
    bar.className = "editor-toolbar";
    bar.setAttribute("role", "toolbar");
    var self2 = this;
    var toolbarData = {};
    self2.toolbar = items;
    for (i2 = 0; i2 < items.length; i2++) {
      if (items[i2].name == "guide" && self2.options.toolbarGuideIcon === false)
        continue;
      if (self2.options.hideIcons && self2.options.hideIcons.indexOf(items[i2].name) != -1)
        continue;
      if ((items[i2].name == "fullscreen" || items[i2].name == "side-by-side") && isMobile())
        continue;
      if (items[i2] === "|") {
        var nonSeparatorIconsFollow = false;
        for (var x2 = i2 + 1; x2 < items.length; x2++) {
          if (items[x2] !== "|" && (!self2.options.hideIcons || self2.options.hideIcons.indexOf(items[x2].name) == -1)) {
            nonSeparatorIconsFollow = true;
          }
        }
        if (!nonSeparatorIconsFollow)
          continue;
      }
      (function(item) {
        var el;
        if (item === "|") {
          el = createSep();
        } else if (item.children) {
          el = createToolbarDropdown(item, self2.options.toolbarTips, self2.options.shortcuts, self2);
        } else {
          el = createToolbarButton(item, true, self2.options.toolbarTips, self2.options.shortcuts, "button", self2);
        }
        toolbarData[item.name || item] = el;
        bar.appendChild(el);
        if (item.name === "upload-image") {
          var imageInput = document.createElement("input");
          imageInput.className = "imageInput";
          imageInput.type = "file";
          imageInput.multiple = true;
          imageInput.name = self2.options.imageInputName;
          imageInput.accept = self2.options.imageAccept;
          imageInput.style.display = "none";
          imageInput.style.opacity = 0;
          bar.appendChild(imageInput);
        }
      })(items[i2]);
    }
    self2.toolbar_div = bar;
    self2.toolbarElements = toolbarData;
    var cm = this.codemirror;
    cm.on("cursorActivity", function() {
      var stat = getState(cm);
      for (var key in toolbarData) {
        (function(key2) {
          var el = toolbarData[key2];
          if (stat[key2]) {
            el.classList.add("active");
          } else if (key2 != "fullscreen" && key2 != "side-by-side") {
            el.classList.remove("active");
          }
        })(key);
      }
    });
    var cmWrapper = cm.getWrapperElement();
    cmWrapper.parentNode.insertBefore(bar, cmWrapper);
    return bar;
  };
  EasyMDE.prototype.createStatusbar = function(status) {
    status = status || this.options.status;
    var options = this.options;
    var cm = this.codemirror;
    if (!status || status.length === 0) {
      return;
    }
    var items = [];
    var i2, onUpdate, onActivity, defaultValue;
    for (i2 = 0; i2 < status.length; i2++) {
      onUpdate = void 0;
      onActivity = void 0;
      defaultValue = void 0;
      if (typeof status[i2] === "object") {
        items.push({
          className: status[i2].className,
          defaultValue: status[i2].defaultValue,
          onUpdate: status[i2].onUpdate,
          onActivity: status[i2].onActivity
        });
      } else {
        var name = status[i2];
        if (name === "words") {
          defaultValue = function(el2) {
            el2.innerHTML = wordCount(cm.getValue());
          };
          onUpdate = function(el2) {
            el2.innerHTML = wordCount(cm.getValue());
          };
        } else if (name === "lines") {
          defaultValue = function(el2) {
            el2.innerHTML = cm.lineCount();
          };
          onUpdate = function(el2) {
            el2.innerHTML = cm.lineCount();
          };
        } else if (name === "cursor") {
          defaultValue = function(el2) {
            el2.innerHTML = "1:1";
          };
          onActivity = function(el2) {
            var pos = cm.getCursor();
            var posLine = pos.line + 1;
            var posColumn = pos.ch + 1;
            el2.innerHTML = posLine + ":" + posColumn;
          };
        } else if (name === "autosave") {
          defaultValue = function(el2) {
            if (options.autosave != void 0 && options.autosave.enabled === true) {
              el2.setAttribute("id", "autosaved");
            }
          };
        } else if (name === "upload-image") {
          defaultValue = function(el2) {
            el2.innerHTML = options.imageTexts.sbInit;
          };
        }
        items.push({
          className: name,
          defaultValue,
          onUpdate,
          onActivity
        });
      }
    }
    var bar = document.createElement("div");
    bar.className = "editor-statusbar";
    for (i2 = 0; i2 < items.length; i2++) {
      var item = items[i2];
      var el = document.createElement("span");
      el.className = item.className;
      if (typeof item.defaultValue === "function") {
        item.defaultValue(el);
      }
      if (typeof item.onUpdate === "function") {
        this.codemirror.on("update", /* @__PURE__ */ function(el2, item2) {
          return function() {
            item2.onUpdate(el2);
          };
        }(el, item));
      }
      if (typeof item.onActivity === "function") {
        this.codemirror.on("cursorActivity", /* @__PURE__ */ function(el2, item2) {
          return function() {
            item2.onActivity(el2);
          };
        }(el, item));
      }
      bar.appendChild(el);
    }
    var cmWrapper = this.codemirror.getWrapperElement();
    cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);
    return bar;
  };
  EasyMDE.prototype.value = function(val) {
    var cm = this.codemirror;
    if (val === void 0) {
      return cm.getValue();
    } else {
      cm.getDoc().setValue(val);
      if (this.isPreviewActive()) {
        var wrapper = cm.getWrapperElement();
        var preview = wrapper.lastChild;
        var preview_result = this.options.previewRender(val, preview);
        if (preview_result !== null) {
          preview.innerHTML = preview_result;
        }
      }
      return this;
    }
  };
  EasyMDE.toggleBold = toggleBold;
  EasyMDE.toggleItalic = toggleItalic;
  EasyMDE.toggleStrikethrough = toggleStrikethrough;
  EasyMDE.toggleBlockquote = toggleBlockquote;
  EasyMDE.toggleHeadingSmaller = toggleHeadingSmaller;
  EasyMDE.toggleHeadingBigger = toggleHeadingBigger;
  EasyMDE.toggleHeading1 = toggleHeading1;
  EasyMDE.toggleHeading2 = toggleHeading2;
  EasyMDE.toggleHeading3 = toggleHeading3;
  EasyMDE.toggleHeading4 = toggleHeading4;
  EasyMDE.toggleHeading5 = toggleHeading5;
  EasyMDE.toggleHeading6 = toggleHeading6;
  EasyMDE.toggleCodeBlock = toggleCodeBlock;
  EasyMDE.toggleUnorderedList = toggleUnorderedList;
  EasyMDE.toggleOrderedList = toggleOrderedList;
  EasyMDE.cleanBlock = cleanBlock;
  EasyMDE.drawLink = drawLink;
  EasyMDE.drawImage = drawImage;
  EasyMDE.drawUploadedImage = drawUploadedImage;
  EasyMDE.drawTable = drawTable;
  EasyMDE.drawHorizontalRule = drawHorizontalRule;
  EasyMDE.undo = undo;
  EasyMDE.redo = redo;
  EasyMDE.togglePreview = togglePreview;
  EasyMDE.toggleSideBySide = toggleSideBySide;
  EasyMDE.toggleFullScreen = toggleFullScreen;
  EasyMDE.prototype.toggleBold = function() {
    toggleBold(this);
  };
  EasyMDE.prototype.toggleItalic = function() {
    toggleItalic(this);
  };
  EasyMDE.prototype.toggleStrikethrough = function() {
    toggleStrikethrough(this);
  };
  EasyMDE.prototype.toggleBlockquote = function() {
    toggleBlockquote(this);
  };
  EasyMDE.prototype.toggleHeadingSmaller = function() {
    toggleHeadingSmaller(this);
  };
  EasyMDE.prototype.toggleHeadingBigger = function() {
    toggleHeadingBigger(this);
  };
  EasyMDE.prototype.toggleHeading1 = function() {
    toggleHeading1(this);
  };
  EasyMDE.prototype.toggleHeading2 = function() {
    toggleHeading2(this);
  };
  EasyMDE.prototype.toggleHeading3 = function() {
    toggleHeading3(this);
  };
  EasyMDE.prototype.toggleHeading4 = function() {
    toggleHeading4(this);
  };
  EasyMDE.prototype.toggleHeading5 = function() {
    toggleHeading5(this);
  };
  EasyMDE.prototype.toggleHeading6 = function() {
    toggleHeading6(this);
  };
  EasyMDE.prototype.toggleCodeBlock = function() {
    toggleCodeBlock(this);
  };
  EasyMDE.prototype.toggleUnorderedList = function() {
    toggleUnorderedList(this);
  };
  EasyMDE.prototype.toggleOrderedList = function() {
    toggleOrderedList(this);
  };
  EasyMDE.prototype.cleanBlock = function() {
    cleanBlock(this);
  };
  EasyMDE.prototype.drawLink = function() {
    drawLink(this);
  };
  EasyMDE.prototype.drawImage = function() {
    drawImage(this);
  };
  EasyMDE.prototype.drawUploadedImage = function() {
    drawUploadedImage(this);
  };
  EasyMDE.prototype.drawTable = function() {
    drawTable(this);
  };
  EasyMDE.prototype.drawHorizontalRule = function() {
    drawHorizontalRule(this);
  };
  EasyMDE.prototype.undo = function() {
    undo(this);
  };
  EasyMDE.prototype.redo = function() {
    redo(this);
  };
  EasyMDE.prototype.togglePreview = function() {
    togglePreview(this);
  };
  EasyMDE.prototype.toggleSideBySide = function() {
    toggleSideBySide(this);
  };
  EasyMDE.prototype.toggleFullScreen = function() {
    toggleFullScreen(this);
  };
  EasyMDE.prototype.isPreviewActive = function() {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.lastChild;
    return preview.classList.contains("editor-preview-active");
  };
  EasyMDE.prototype.isSideBySideActive = function() {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var preview = wrapper.nextSibling;
    return preview.classList.contains("editor-preview-active-side");
  };
  EasyMDE.prototype.isFullscreenActive = function() {
    var cm = this.codemirror;
    return cm.getOption("fullScreen");
  };
  EasyMDE.prototype.getState = function() {
    var cm = this.codemirror;
    return getState(cm);
  };
  EasyMDE.prototype.toTextArea = function() {
    var cm = this.codemirror;
    var wrapper = cm.getWrapperElement();
    var easyMDEContainer = wrapper.parentNode;
    if (easyMDEContainer) {
      if (this.gui.toolbar) {
        easyMDEContainer.removeChild(this.gui.toolbar);
      }
      if (this.gui.statusbar) {
        easyMDEContainer.removeChild(this.gui.statusbar);
      }
      if (this.gui.sideBySide) {
        easyMDEContainer.removeChild(this.gui.sideBySide);
      }
    }
    easyMDEContainer.parentNode.insertBefore(wrapper, easyMDEContainer);
    easyMDEContainer.remove();
    cm.toTextArea();
    if (this.autosaveTimeoutId) {
      clearTimeout(this.autosaveTimeoutId);
      this.autosaveTimeoutId = void 0;
      this.clearAutosavedValue();
    }
  };
  var easymde = EasyMDE;
  const EasyMDE$1 = /* @__PURE__ */ getDefaultExportFromCjs(easymde);
  let easyMDE$1 = null;
  function initEditor(elementId = "editor") {
    const textarea = document.getElementById(elementId);
    if (!textarea) {
      console.error("Editor textarea not found");
      return null;
    }
    easyMDE$1 = new EasyMDE$1({
      element: textarea,
      spellChecker: false,
      status: false,
      toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "table"],
      autofocus: false,
      placeholder: "Start typing...",
      renderingConfig: {
        singleLineBreaks: false,
        codeSyntaxHighlighting: true
      }
    });
    return easyMDE$1;
  }
  function getEditorContent() {
    return easyMDE$1 ? easyMDE$1.value() : "";
  }
  const folder = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M64 480H448c35.3 0 64-28.7 64-64V160c0-35.3-28.7-64-64-64H288c-10.1 0-19.6-4.7-25.6-12.8L243.2 57.6C231.1 41.5 212.1 32 192 32H64C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64z"/></svg>`;
  const copy = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M384 336H192c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16l140.1 0L400 115.9V320c0 8.8-7.2 16-16 16zM192 384H384c35.3 0 64-28.7 64-64V115.9c0-12.7-5.1-24.9-14.1-33.9L366.1 14.1c-9-9-21.2-14.1-33.9-14.1H192c-35.3 0-64 28.7-64 64V320c0 35.3 28.7 64 64 64zM64 128c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H256c35.3 0 64-28.7 64-64V416H272v32c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V192c0-8.8 7.2-16 16-16H96V128H64z"/></svg>`;
  const check = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg>`;
  const tag = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M0 80V229.5c0 17 6.7 33.3 18.7 45.3l176 176c25 25 65.5 25 90.5 0L418.7 317.3c25-25 25-65.5 0-90.5l-176-176c-12-12-28.3-18.7-45.3-18.7H48C21.5 32 0 53.5 0 80zm112 32a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/></svg>`;
  var xhtml = "http://www.w3.org/1999/xhtml";
  const namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  function namespace(name) {
    var prefix = name += "", i2 = prefix.indexOf(":");
    if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns") name = name.slice(i2 + 1);
    return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
  }
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }
  function none() {
  }
  function selector(selector2) {
    return selector2 == null ? none : function() {
      return this.querySelector(selector2);
    };
  }
  function selection_select(select2) {
    if (typeof select2 !== "function") select2 = selector(select2);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
        if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i2] = subnode;
        }
      }
    }
    return new Selection$1(subgroups, this._parents);
  }
  function array(x2) {
    return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
  }
  function empty() {
    return [];
  }
  function selectorAll(selector2) {
    return selector2 == null ? empty : function() {
      return this.querySelectorAll(selector2);
    };
  }
  function arrayAll(select2) {
    return function() {
      return array(select2.apply(this, arguments));
    };
  }
  function selection_selectAll(select2) {
    if (typeof select2 === "function") select2 = arrayAll(select2);
    else select2 = selectorAll(select2);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          subgroups.push(select2.call(node, node.__data__, i2, group));
          parents.push(node);
        }
      }
    }
    return new Selection$1(subgroups, parents);
  }
  function matcher(selector2) {
    return function() {
      return this.matches(selector2);
    };
  }
  function childMatcher(selector2) {
    return function(node) {
      return node.matches(selector2);
    };
  }
  var find$1 = Array.prototype.find;
  function childFind(match) {
    return function() {
      return find$1.call(this.children, match);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selection_selectChild(match) {
    return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
  }
  var filter = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match) {
    return function() {
      return filter.call(this.children, match);
    };
  }
  function selection_selectChildren(match) {
    return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }
  function selection_filter(match) {
    if (typeof match !== "function") match = matcher(match);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node, i2 = 0; i2 < n2; ++i2) {
        if ((node = group[i2]) && match.call(node, node.__data__, i2, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection$1(subgroups, this._parents);
  }
  function sparse(update) {
    return new Array(update.length);
  }
  function selection_enter() {
    return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector2) {
      return this._parent.querySelector(selector2);
    },
    querySelectorAll: function(selector2) {
      return this._parent.querySelectorAll(selector2);
    }
  };
  function constant$4(x2) {
    return function() {
      return x2;
    };
  }
  function bindIndex(parent, group, enter, update, exit, data) {
    var i2 = 0, node, groupLength = group.length, dataLength = data.length;
    for (; i2 < dataLength; ++i2) {
      if (node = group[i2]) {
        node.__data__ = data[i2];
        update[i2] = node;
      } else {
        enter[i2] = new EnterNode(parent, data[i2]);
      }
    }
    for (; i2 < groupLength; ++i2) {
      if (node = group[i2]) {
        exit[i2] = node;
      }
    }
  }
  function bindKey(parent, group, enter, update, exit, data, key) {
    var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i2 = 0; i2 < groupLength; ++i2) {
      if (node = group[i2]) {
        keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i2] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i2 = 0; i2 < dataLength; ++i2) {
      keyValue = key.call(parent, data[i2], i2, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i2] = node;
        node.__data__ = data[i2];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i2] = new EnterNode(parent, data[i2]);
      }
    }
    for (i2 = 0; i2 < groupLength; ++i2) {
      if ((node = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
        exit[i2] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function selection_data(value, key) {
    if (!arguments.length) return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function") value = constant$4(value);
    for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      var parent = parents[j2], group = groups[j2], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
          previous._next = next || null;
        }
      }
    }
    update = new Selection$1(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }
  function selection_exit() {
    return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
  }
  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter) enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update) update = update.selection();
    }
    if (onexit == null) exit.remove();
    else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }
  function selection_merge(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge2 = merges[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
        if (node = group0[i2] || group1[i2]) {
          merge2[i2] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Selection$1(merges, this._parents);
  }
  function selection_order() {
    for (var groups = this._groups, j2 = -1, m2 = groups.length; ++j2 < m2; ) {
      for (var group = groups[j2], i2 = group.length - 1, next = group[i2], node; --i2 >= 0; ) {
        if (node = group[i2]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }
  function selection_sort(compare) {
    if (!compare) compare = ascending;
    function compareNode(a2, b) {
      return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
    }
    for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, sortgroup = sortgroups[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          sortgroup[i2] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection$1(sortgroups, this._parents).order();
  }
  function ascending(a2, b) {
    return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  }
  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }
  function selection_nodes() {
    return Array.from(this);
  }
  function selection_node() {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group = groups[j2], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
        var node = group[i2];
        if (node) return node;
      }
    }
    return null;
  }
  function selection_size() {
    let size = 0;
    for (const node of this) ++size;
    return size;
  }
  function selection_empty() {
    return !this.node();
  }
  function selection_each(callback) {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group = groups[j2], i2 = 0, n2 = group.length, node; i2 < n2; ++i2) {
        if (node = group[i2]) callback.call(node, node.__data__, i2, group);
      }
    }
    return this;
  }
  function attrRemove$1(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS$1(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant$1(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }
  function attrConstantNS$1(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction$1(name, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.removeAttribute(name);
      else this.setAttribute(name, v2);
    };
  }
  function attrFunctionNS$1(fullname, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v2);
    };
  }
  function selection_attr(name, value) {
    var fullname = namespace(name);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
  }
  function defaultView(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }
  function styleRemove$1(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant$1(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }
  function styleFunction$1(name, value, priority) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v2, priority);
    };
  }
  function selection_style(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  }
  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }
  function propertyFunction(name, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) delete this[name];
      else this[name] = v2;
    };
  }
  function selection_property(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  }
  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name) {
      var i2 = this._names.indexOf(name);
      if (i2 < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i2 = this._names.indexOf(name);
      if (i2 >= 0) {
        this._names.splice(i2, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };
  function classedAdd(node, names2) {
    var list = classList(node), i2 = -1, n2 = names2.length;
    while (++i2 < n2) list.add(names2[i2]);
  }
  function classedRemove(node, names2) {
    var list = classList(node), i2 = -1, n2 = names2.length;
    while (++i2 < n2) list.remove(names2[i2]);
  }
  function classedTrue(names2) {
    return function() {
      classedAdd(this, names2);
    };
  }
  function classedFalse(names2) {
    return function() {
      classedRemove(this, names2);
    };
  }
  function classedFunction(names2, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names2);
    };
  }
  function selection_classed(name, value) {
    var names2 = classArray(name + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i2 = -1, n2 = names2.length;
      while (++i2 < n2) if (!list.contains(names2[i2])) return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names2, value));
  }
  function textRemove() {
    this.textContent = "";
  }
  function textConstant$1(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction$1(value) {
    return function() {
      var v2 = value.apply(this, arguments);
      this.textContent = v2 == null ? "" : v2;
    };
  }
  function selection_text(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
  }
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v2 = value.apply(this, arguments);
      this.innerHTML = v2 == null ? "" : v2;
    };
  }
  function selection_html(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }
  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }
  function selection_raise() {
    return this.each(raise);
  }
  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function selection_lower() {
    return this.each(lower);
  }
  function selection_append(name) {
    var create2 = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }
  function constantNull() {
    return null;
  }
  function selection_insert(name, before) {
    var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
    });
  }
  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  function selection_remove() {
    return this.each(remove);
  }
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }
  function selection_datum(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames$1(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name = "", i2 = t2.indexOf(".");
      if (i2 >= 0) name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
      return { type: t2, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j2 = 0, i2 = -1, m2 = on.length, o2; j2 < m2; ++j2) {
        if (o2 = on[j2], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options);
        } else {
          on[++i2] = o2;
        }
      }
      if (++i2) on.length = i2;
      else delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o2, listener = contextListener(value);
      if (on) for (var j2 = 0, m2 = on.length; j2 < m2; ++j2) {
        if ((o2 = on[j2]).type === typename.type && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options);
          this.addEventListener(o2.type, o2.listener = listener, o2.options = options);
          o2.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, options);
      o2 = { type: typename.type, name: typename.name, value, listener, options };
      if (!on) this.__on = [o2];
      else on.push(o2);
    };
  }
  function selection_on(typename, value, options) {
    var typenames = parseTypenames$1(typename + ""), i2, n2 = typenames.length, t2;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j2 = 0, m2 = on.length, o2; j2 < m2; ++j2) {
        for (i2 = 0, o2 = on[j2]; i2 < n2; ++i2) {
          if ((t2 = typenames[i2]).type === o2.type && t2.name === o2.name) {
            return o2.value;
          }
        }
      }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i2 = 0; i2 < n2; ++i2) this.each(on(typenames[i2], value, options));
    return this;
  }
  function dispatchEvent(node, type2, params) {
    var window2 = defaultView(node), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type2, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params) event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type2, false, false);
    }
    node.dispatchEvent(event);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function selection_dispatch(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }
  function* selection_iterator() {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group = groups[j2], i2 = 0, n2 = group.length, node; i2 < n2; ++i2) {
        if (node = group[i2]) yield node;
      }
    }
  }
  var root$1 = [null];
  function Selection$1(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection$1([[document.documentElement]], root$1);
  }
  function selection_selection() {
    return this;
  }
  Selection$1.prototype = selection.prototype = {
    constructor: Selection$1,
    select: selection_select,
    selectAll: selection_selectAll,
    selectChild: selection_selectChild,
    selectChildren: selection_selectChildren,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    selection: selection_selection,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch,
    [Symbol.iterator]: selection_iterator
  };
  function select(selector2) {
    return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$1);
  }
  function sourceEvent(event) {
    let sourceEvent2;
    while (sourceEvent2 = event.sourceEvent) event = sourceEvent2;
    return event;
  }
  function pointer(event, node) {
    event = sourceEvent(event);
    if (node === void 0) node = event.currentTarget;
    if (node) {
      var svg = node.ownerSVGElement || node;
      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
      }
      if (node.getBoundingClientRect) {
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }
  var noop = { value: () => {
  } };
  function dispatch() {
    for (var i2 = 0, n2 = arguments.length, _2 = {}, t2; i2 < n2; ++i2) {
      if (!(t2 = arguments[i2] + "") || t2 in _2 || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
      _2[t2] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types2) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name = "", i2 = t2.indexOf(".");
      if (i2 >= 0) name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
      if (t2 && !types2.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
      return { type: t2, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T2 = parseTypenames(typename + "", _2), t2, i2 = -1, n2 = T2.length;
      if (arguments.length < 2) {
        while (++i2 < n2) if ((t2 = (typename = T2[i2]).type) && (t2 = get$1(_2[t2], typename.name))) return t2;
        return;
      }
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i2 < n2) {
        if (t2 = (typename = T2[i2]).type) _2[t2] = set$2(_2[t2], typename.name, callback);
        else if (callback == null) for (t2 in _2) _2[t2] = set$2(_2[t2], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy2 = {}, _2 = this._;
      for (var t2 in _2) copy2[t2] = _2[t2].slice();
      return new Dispatch(copy2);
    },
    call: function(type2, that) {
      if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
      if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
      for (t2 = this._[type2], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
    },
    apply: function(type2, that, args) {
      if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
      for (var t2 = this._[type2], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
    }
  };
  function get$1(type2, name) {
    for (var i2 = 0, n2 = type2.length, c2; i2 < n2; ++i2) {
      if ((c2 = type2[i2]).name === name) {
        return c2.value;
      }
    }
  }
  function set$2(type2, name, callback) {
    for (var i2 = 0, n2 = type2.length; i2 < n2; ++i2) {
      if (type2[i2].name === name) {
        type2[i2] = noop, type2 = type2.slice(0, i2).concat(type2.slice(i2 + 1));
        break;
      }
    }
    if (callback != null) type2.push({ name, value: callback });
    return type2;
  }
  const nonpassive = { passive: false };
  const nonpassivecapture = { capture: true, passive: false };
  function nopropagation$1(event) {
    event.stopImmediatePropagation();
  }
  function noevent$1(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function dragDisable(view) {
    var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
    if ("onselectstart" in root2) {
      selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
    } else {
      root2.__noselect = root2.style.MozUserSelect;
      root2.style.MozUserSelect = "none";
    }
  }
  function yesdrag(view, noclick) {
    var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
    if (noclick) {
      selection2.on("click.drag", noevent$1, nonpassivecapture);
      setTimeout(function() {
        selection2.on("click.drag", null);
      }, 0);
    }
    if ("onselectstart" in root2) {
      selection2.on("selectstart.drag", null);
    } else {
      root2.style.MozUserSelect = root2.__noselect;
      delete root2.__noselect;
    }
  }
  const constant$3 = (x2) => () => x2;
  function DragEvent(type2, {
    sourceEvent: sourceEvent2,
    subject,
    target,
    identifier,
    active,
    x: x2,
    y: y2,
    dx,
    dy,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
      subject: { value: subject, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      identifier: { value: identifier, enumerable: true, configurable: true },
      active: { value: active, enumerable: true, configurable: true },
      x: { value: x2, enumerable: true, configurable: true },
      y: { value: y2, enumerable: true, configurable: true },
      dx: { value: dx, enumerable: true, configurable: true },
      dy: { value: dy, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }
  DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };
  function defaultFilter$1(event) {
    return !event.ctrlKey && !event.button;
  }
  function defaultContainer() {
    return this.parentNode;
  }
  function defaultSubject(event, d2) {
    return d2 == null ? { x: event.x, y: event.y } : d2;
  }
  function defaultTouchable$1() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function drag() {
    var filter2 = defaultFilter$1, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$1, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
    function drag2(selection2) {
      selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function mousedowned(event, d2) {
      if (touchending || !filter2.call(this, event, d2)) return;
      var gesture = beforestart(this, container.call(this, event, d2), event, d2, "mouse");
      if (!gesture) return;
      select(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
      dragDisable(event.view);
      nopropagation$1(event);
      mousemoving = false;
      mousedownx = event.clientX;
      mousedowny = event.clientY;
      gesture("start", event);
    }
    function mousemoved(event) {
      noevent$1(event);
      if (!mousemoving) {
        var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag", event);
    }
    function mouseupped(event) {
      select(event.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(event.view, mousemoving);
      noevent$1(event);
      gestures.mouse("end", event);
    }
    function touchstarted(event, d2) {
      if (!filter2.call(this, event, d2)) return;
      var touches = event.changedTouches, c2 = container.call(this, event, d2), n2 = touches.length, i2, gesture;
      for (i2 = 0; i2 < n2; ++i2) {
        if (gesture = beforestart(this, c2, event, d2, touches[i2].identifier, touches[i2])) {
          nopropagation$1(event);
          gesture("start", event, touches[i2]);
        }
      }
    }
    function touchmoved(event) {
      var touches = event.changedTouches, n2 = touches.length, i2, gesture;
      for (i2 = 0; i2 < n2; ++i2) {
        if (gesture = gestures[touches[i2].identifier]) {
          noevent$1(event);
          gesture("drag", event, touches[i2]);
        }
      }
    }
    function touchended(event) {
      var touches = event.changedTouches, n2 = touches.length, i2, gesture;
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, 500);
      for (i2 = 0; i2 < n2; ++i2) {
        if (gesture = gestures[touches[i2].identifier]) {
          nopropagation$1(event);
          gesture("end", event, touches[i2]);
        }
      }
    }
    function beforestart(that, container2, event, d2, identifier, touch) {
      var dispatch2 = listeners.copy(), p2 = pointer(touch || event, container2), dx, dy, s2;
      if ((s2 = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag2,
        identifier,
        active,
        x: p2[0],
        y: p2[1],
        dx: 0,
        dy: 0,
        dispatch: dispatch2
      }), d2)) == null) return;
      dx = s2.x - p2[0] || 0;
      dy = s2.y - p2[1] || 0;
      return function gesture(type2, event2, touch2) {
        var p0 = p2, n2;
        switch (type2) {
          case "start":
            gestures[identifier] = gesture, n2 = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          case "drag":
            p2 = pointer(touch2 || event2, container2), n2 = active;
            break;
        }
        dispatch2.call(
          type2,
          that,
          new DragEvent(type2, {
            sourceEvent: event2,
            subject: s2,
            target: drag2,
            identifier,
            active: n2,
            x: p2[0] + dx,
            y: p2[1] + dy,
            dx: p2[0] - p0[0],
            dy: p2[1] - p0[1],
            dispatch: dispatch2
          }),
          d2
        );
      };
    }
    drag2.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant$3(!!_2), drag2) : filter2;
    };
    drag2.container = function(_2) {
      return arguments.length ? (container = typeof _2 === "function" ? _2 : constant$3(_2), drag2) : container;
    };
    drag2.subject = function(_2) {
      return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant$3(_2), drag2) : subject;
    };
    drag2.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$3(!!_2), drag2) : touchable;
    };
    drag2.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag2 : value;
    };
    drag2.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag2) : Math.sqrt(clickDistance2);
    };
    return drag2;
  }
  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend$1(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format) {
    var m2, l2;
    format = (format + "").trim().toLowerCase();
    return (m2 = reHex.exec(format)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n2) {
    return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
  }
  function rgba(r2, g2, b, a2) {
    if (a2 <= 0) r2 = g2 = b = NaN;
    return new Rgb(r2, g2, b, a2);
  }
  function rgbConvert(o2) {
    if (!(o2 instanceof Color)) o2 = color(o2);
    if (!o2) return new Rgb();
    o2 = o2.rgb();
    return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
  }
  function rgb(r2, g2, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r2, g2, b, opacity) {
    this.r = +r2;
    this.g = +g2;
    this.b = +b;
    this.opacity = +opacity;
  }
  define(Rgb, rgb, extend$1(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s2, l2, a2) {
    if (a2 <= 0) h = s2 = l2 = NaN;
    else if (l2 <= 0 || l2 >= 1) h = s2 = NaN;
    else if (s2 <= 0) h = NaN;
    return new Hsl(h, s2, l2, a2);
  }
  function hslConvert(o2) {
    if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
    if (!(o2 instanceof Color)) o2 = color(o2);
    if (!o2) return new Hsl();
    if (o2 instanceof Hsl) return o2;
    o2 = o2.rgb();
    var r2 = o2.r / 255, g2 = o2.g / 255, b = o2.b / 255, min2 = Math.min(r2, g2, b), max2 = Math.max(r2, g2, b), h = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
    if (s2) {
      if (r2 === max2) h = (g2 - b) / s2 + (g2 < b) * 6;
      else if (g2 === max2) h = (b - r2) / s2 + 2;
      else h = (r2 - g2) / s2 + 4;
      s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s2 = l2 > 0 && l2 < 1 ? 0 : h;
    }
    return new Hsl(h, s2, l2, o2.opacity);
  }
  function hsl(h, s2, l2, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l2, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s2, l2, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define(Hsl, hsl, extend$1(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }
  const constant$2 = (x2) => () => x2;
  function linear(a2, d2) {
    return function(t2) {
      return a2 + t2 * d2;
    };
  }
  function exponential(a2, b, y2) {
    return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t2) {
      return Math.pow(a2 + t2 * b, y2);
    };
  }
  function gamma(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
      return b - a2 ? exponential(a2, b, y2) : constant$2(isNaN(a2) ? b : a2);
    };
  }
  function nogamma(a2, b) {
    var d2 = b - a2;
    return d2 ? linear(a2, d2) : constant$2(isNaN(a2) ? b : a2);
  }
  const interpolateRgb = function rgbGamma(y2) {
    var color2 = gamma(y2);
    function rgb$1(start2, end) {
      var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g2 = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t2) {
        start2.r = r2(t2);
        start2.g = g2(t2);
        start2.b = b(t2);
        start2.opacity = opacity(t2);
        return start2 + "";
      };
    }
    rgb$1.gamma = rgbGamma;
    return rgb$1;
  }(1);
  function interpolateNumber(a2, b) {
    return a2 = +a2, b = +b, function(t2) {
      return a2 * (1 - t2) + b * t2;
    };
  }
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t2) {
      return b(t2) + "";
    };
  }
  function interpolateString(a2, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
    a2 = a2 + "", b = b + "";
    while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s2[i2]) s2[i2] += bs;
        else s2[++i2] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s2[i2]) s2[i2] += bm;
        else s2[++i2] = bm;
      } else {
        s2[++i2] = null;
        q2.push({ i: i2, x: interpolateNumber(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s2[i2]) s2[i2] += bs;
      else s2[++i2] = bs;
    }
    return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b) : (b = q2.length, function(t2) {
      for (var i3 = 0, o2; i3 < b; ++i3) s2[(o2 = q2[i3]).i] = o2.x(t2);
      return s2.join("");
    });
  }
  var degrees = 180 / Math.PI;
  var identity$1 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose(a2, b, c2, d2, e2, f2) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a2 * a2 + b * b)) a2 /= scaleX, b /= scaleX;
    if (skewX = a2 * c2 + b * d2) c2 -= a2 * skewX, d2 -= b * skewX;
    if (scaleY = Math.sqrt(c2 * c2 + d2 * d2)) c2 /= scaleY, d2 /= scaleY, skewX /= scaleY;
    if (a2 * d2 < b * c2) a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e2,
      translateY: f2,
      rotate: Math.atan2(b, a2) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }
  var svgNode;
  function parseCss(value) {
    const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m2.isIdentity ? identity$1 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
  }
  function parseSvg(value) {
    if (value == null) return identity$1;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }
  function interpolateTransform(parse, pxComma, pxParen, degParen) {
    function pop(s2) {
      return s2.length ? s2.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s2, q2) {
      if (xa !== xb || ya !== yb) {
        var i2 = s2.push("translate(", null, pxComma, null, pxParen);
        q2.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
      } else if (xb || yb) {
        s2.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a2, b, s2, q2) {
      if (a2 !== b) {
        if (a2 - b > 180) b += 360;
        else if (b - a2 > 180) a2 += 360;
        q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b) });
      } else if (b) {
        s2.push(pop(s2) + "rotate(" + b + degParen);
      }
    }
    function skewX(a2, b, s2, q2) {
      if (a2 !== b) {
        q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b) });
      } else if (b) {
        s2.push(pop(s2) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s2, q2) {
      if (xa !== xb || ya !== yb) {
        var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
        q2.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a2, b) {
      var s2 = [], q2 = [];
      a2 = parse(a2), b = parse(b);
      translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q2);
      rotate(a2.rotate, b.rotate, s2, q2);
      skewX(a2.skewX, b.skewX, s2, q2);
      scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q2);
      a2 = b = null;
      return function(t2) {
        var i2 = -1, n2 = q2.length, o2;
        while (++i2 < n2) s2[(o2 = q2[i2]).i] = o2.x(t2);
        return s2.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
  var epsilon2 = 1e-12;
  function cosh(x2) {
    return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
  }
  function sinh(x2) {
    return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
  }
  function tanh(x2) {
    return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
  }
  const interpolateZoom = function zoomRho(rho, rho2, rho4) {
    function zoom2(p0, p1) {
      var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S2;
      if (d2 < epsilon2) {
        S2 = Math.log(w1 / w0) / rho;
        i2 = function(t2) {
          return [
            ux0 + t2 * dx,
            uy0 + t2 * dy,
            w0 * Math.exp(rho * t2 * S2)
          ];
        };
      } else {
        var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S2 = (r1 - r0) / rho;
        i2 = function(t2) {
          var s2 = t2 * S2, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
          return [
            ux0 + u2 * dx,
            uy0 + u2 * dy,
            w0 * coshr0 / cosh(rho * s2 + r0)
          ];
        };
      }
      i2.duration = S2 * 1e3 * rho / Math.SQRT2;
      return i2;
    }
    zoom2.rho = function(_2) {
      var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
      return zoomRho(_1, _22, _4);
    };
    return zoom2;
  }(Math.SQRT2, 2, 4);
  var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
    setTimeout(f2, 17);
  };
  function now$2() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now$2() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t2 = new Timer();
    t2.restart(callback, delay, time);
    return t2;
  }
  function timerFlush() {
    now$2();
    ++frame;
    var t2 = taskHead, e2;
    while (t2) {
      if ((e2 = clockNow - t2._time) >= 0) t2._call.call(void 0, e2);
      t2 = t2._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout$1 = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame) return;
    if (timeout$1) timeout$1 = clearTimeout(timeout$1);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }
  function timeout(callback, delay, time) {
    var t2 = new Timer();
    delay = delay == null ? 0 : +delay;
    t2.restart((elapsed) => {
      t2.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t2;
  }
  var emptyOn = dispatch("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule(node, name, id2, index2, group, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {};
    else if (id2 in schedules) return;
    create(node, id2, {
      name,
      index: index2,
      // For context during callback.
      group,
      // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init$1(node, id2) {
    var schedule2 = get(node, id2);
    if (schedule2.state > CREATED) throw new Error("too late; already scheduled");
    return schedule2;
  }
  function set$1(node, id2) {
    var schedule2 = get(node, id2);
    if (schedule2.state > STARTED) throw new Error("too late; already running");
    return schedule2;
  }
  function get(node, id2) {
    var schedule2 = node.__transition;
    if (!schedule2 || !(schedule2 = schedule2[id2])) throw new Error("transition not found");
    return schedule2;
  }
  function create(node, id2, self2) {
    var schedules = node.__transition, tween;
    schedules[id2] = self2;
    self2.timer = timer(schedule2, 0, self2.time);
    function schedule2(elapsed) {
      self2.state = SCHEDULED;
      self2.timer.restart(start2, self2.delay, self2.time);
      if (self2.delay <= elapsed) start2(elapsed - self2.delay);
    }
    function start2(elapsed) {
      var i2, j2, n2, o2;
      if (self2.state !== SCHEDULED) return stop();
      for (i2 in schedules) {
        o2 = schedules[i2];
        if (o2.name !== self2.name) continue;
        if (o2.state === STARTED) return timeout(start2);
        if (o2.state === RUNNING) {
          o2.state = ENDED;
          o2.timer.stop();
          o2.on.call("interrupt", node, node.__data__, o2.index, o2.group);
          delete schedules[i2];
        } else if (+i2 < id2) {
          o2.state = ENDED;
          o2.timer.stop();
          o2.on.call("cancel", node, node.__data__, o2.index, o2.group);
          delete schedules[i2];
        }
      }
      timeout(function() {
        if (self2.state === STARTED) {
          self2.state = RUNNING;
          self2.timer.restart(tick, self2.delay, self2.time);
          tick(elapsed);
        }
      });
      self2.state = STARTING;
      self2.on.call("start", node, node.__data__, self2.index, self2.group);
      if (self2.state !== STARTING) return;
      self2.state = STARTED;
      tween = new Array(n2 = self2.tween.length);
      for (i2 = 0, j2 = -1; i2 < n2; ++i2) {
        if (o2 = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) {
          tween[++j2] = o2;
        }
      }
      tween.length = j2 + 1;
    }
    function tick(elapsed) {
      var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length;
      while (++i2 < n2) {
        tween[i2].call(node, t2);
      }
      if (self2.state === ENDING) {
        self2.on.call("end", node, node.__data__, self2.index, self2.group);
        stop();
      }
    }
    function stop() {
      self2.state = ENDED;
      self2.timer.stop();
      delete schedules[id2];
      for (var i2 in schedules) return;
      delete node.__transition;
    }
  }
  function interrupt(node, name) {
    var schedules = node.__transition, schedule2, active, empty2 = true, i2;
    if (!schedules) return;
    name = name == null ? null : name + "";
    for (i2 in schedules) {
      if ((schedule2 = schedules[i2]).name !== name) {
        empty2 = false;
        continue;
      }
      active = schedule2.state > STARTING && schedule2.state < ENDING;
      schedule2.state = ENDED;
      schedule2.timer.stop();
      schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
      delete schedules[i2];
    }
    if (empty2) delete node.__transition;
  }
  function selection_interrupt(name) {
    return this.each(function() {
      interrupt(this, name);
    });
  }
  function tweenRemove(id2, name) {
    var tween0, tween1;
    return function() {
      var schedule2 = set$1(this, id2), tween = schedule2.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
          if (tween1[i2].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i2, 1);
            break;
          }
        }
      }
      schedule2.tween = tween1;
    };
  }
  function tweenFunction(id2, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error();
    return function() {
      var schedule2 = set$1(this, id2), tween = schedule2.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t2 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
          if (tween1[i2].name === name) {
            tween1[i2] = t2;
            break;
          }
        }
        if (i2 === n2) tween1.push(t2);
      }
      schedule2.tween = tween1;
    };
  }
  function transition_tween(name, value) {
    var id2 = this._id;
    name += "";
    if (arguments.length < 2) {
      var tween = get(this.node(), id2).tween;
      for (var i2 = 0, n2 = tween.length, t2; i2 < n2; ++i2) {
        if ((t2 = tween[i2]).name === name) {
          return t2.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
  }
  function tweenValue(transition, name, value) {
    var id2 = transition._id;
    transition.each(function() {
      var schedule2 = set$1(this, id2);
      (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
    });
    return function(node) {
      return get(node, id2).value[name];
    };
  }
  function interpolate(a2, b) {
    var c2;
    return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c2 = color(b)) ? (b = c2, interpolateRgb) : interpolateString)(a2, b);
  }
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function attrConstantNS(fullname, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function attrFunction(name, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function attrFunctionNS(fullname, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function transition_attr(name, value) {
    var fullname = namespace(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i2, value));
  }
  function attrInterpolate(name, i2) {
    return function(t2) {
      this.setAttribute(name, i2.call(this, t2));
    };
  }
  function attrInterpolateNS(fullname, i2) {
    return function(t2) {
      this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0) t0 = (i0 = i2) && attrInterpolateNS(fullname, i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name, value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0) t0 = (i0 = i2) && attrInterpolate(name, i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function transition_attrTween(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    var fullname = namespace(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }
  function delayFunction(id2, value) {
    return function() {
      init$1(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init$1(this, id2).delay = value;
    };
  }
  function transition_delay(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
  }
  function durationFunction(id2, value) {
    return function() {
      set$1(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set$1(this, id2).duration = value;
    };
  }
  function transition_duration(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
  }
  function easeConstant(id2, value) {
    if (typeof value !== "function") throw new Error();
    return function() {
      set$1(this, id2).ease = value;
    };
  }
  function transition_ease(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
  }
  function easeVarying(id2, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (typeof v2 !== "function") throw new Error();
      set$1(this, id2).ease = v2;
    };
  }
  function transition_easeVarying(value) {
    if (typeof value !== "function") throw new Error();
    return this.each(easeVarying(this._id, value));
  }
  function transition_filter(match) {
    if (typeof match !== "function") match = matcher(match);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node, i2 = 0; i2 < n2; ++i2) {
        if ((node = group[i2]) && match.call(node, node.__data__, i2, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }
  function transition_merge(transition) {
    if (transition._id !== this._id) throw new Error();
    for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge2 = merges[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
        if (node = group0[i2] || group1[i2]) {
          merge2[i2] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }
  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t2) {
      var i2 = t2.indexOf(".");
      if (i2 >= 0) t2 = t2.slice(0, i2);
      return !t2 || t2 === "start";
    });
  }
  function onFunction(id2, name, listener) {
    var on0, on1, sit = start(name) ? init$1 : set$1;
    return function() {
      var schedule2 = sit(this, id2), on = schedule2.on;
      if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
      schedule2.on = on1;
    };
  }
  function transition_on(name, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
  }
  function removeFunction(id2) {
    return function() {
      var parent = this.parentNode;
      for (var i2 in this.__transition) if (+i2 !== id2) return;
      if (parent) parent.removeChild(this);
    };
  }
  function transition_remove() {
    return this.on("end.remove", removeFunction(this._id));
  }
  function transition_select(select2) {
    var name = this._name, id2 = this._id;
    if (typeof select2 !== "function") select2 = selector(select2);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
        if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i2] = subnode;
          schedule(subgroup[i2], name, id2, i2, subgroup, get(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name, id2);
  }
  function transition_selectAll(select2) {
    var name = this._name, id2 = this._id;
    if (typeof select2 !== "function") select2 = selectorAll(select2);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          for (var children2 = select2.call(node, node.__data__, i2, group), child, inherit2 = get(node, id2), k2 = 0, l2 = children2.length; k2 < l2; ++k2) {
            if (child = children2[k2]) {
              schedule(child, name, id2, k2, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name, id2);
  }
  var Selection = selection.prototype.constructor;
  function transition_selection() {
    return new Selection(this._groups, this._parents);
  }
  function styleNull(name, interpolate2) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
    };
  }
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function styleFunction(name, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
      if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
    return function() {
      var schedule2 = set$1(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
      if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
      schedule2.on = on1;
    };
  }
  function transition_style(name, value, priority) {
    var i2 = (name += "") === "transform" ? interpolateTransformCss : interpolate;
    return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i2, value), priority).on("end.style." + name, null);
  }
  function styleInterpolate(name, i2, priority) {
    return function(t2) {
      this.style.setProperty(name, i2.call(this, t2), priority);
    };
  }
  function styleTween(name, value, priority) {
    var t2, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0) t2 = (i0 = i2) && styleInterpolate(name, i2, priority);
      return t2;
    }
    tween._value = value;
    return tween;
  }
  function transition_styleTween(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function transition_text(value) {
    return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
  }
  function textInterpolate(i2) {
    return function(t2) {
      this.textContent = i2.call(this, t2);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0) t0 = (i0 = i2) && textInterpolate(i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function transition_textTween(value) {
    var key = "text";
    if (arguments.length < 1) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, textTween(value));
  }
  function transition_transition() {
    var name = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          var inherit2 = get(node, id0);
          schedule(node, name, id1, i2, group, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name, id1);
  }
  function transition_end() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size === 0) resolve();
      } };
      that.each(function() {
        var schedule2 = set$1(this, id2), on = schedule2.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule2.on = on1;
      });
      if (size === 0) resolve();
    });
  }
  var id = 0;
  function Transition(groups, parents, name, id2) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id2;
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection.prototype;
  Transition.prototype = {
    constructor: Transition,
    select: transition_select,
    selectAll: transition_selectAll,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: transition_filter,
    merge: transition_merge,
    selection: transition_selection,
    transition: transition_transition,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: transition_on,
    attr: transition_attr,
    attrTween: transition_attrTween,
    style: transition_style,
    styleTween: transition_styleTween,
    text: transition_text,
    textTween: transition_textTween,
    remove: transition_remove,
    tween: transition_tween,
    delay: transition_delay,
    duration: transition_duration,
    ease: transition_ease,
    easeVarying: transition_easeVarying,
    end: transition_end,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };
  function cubicInOut(t2) {
    return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
  }
  var defaultTiming = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function selection_transition(name) {
    var id2, timing;
    if (name instanceof Transition) {
      id2 = name._id, name = name._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now$2(), name = name == null ? null : name + "";
    }
    for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2) {
      for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          schedule(node, name, id2, i2, group, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups, this._parents, name, id2);
  }
  selection.prototype.interrupt = selection_interrupt;
  selection.prototype.transition = selection_transition;
  const constant$1 = (x2) => () => x2;
  function ZoomEvent(type2, {
    sourceEvent: sourceEvent2,
    target,
    transform: transform2,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      transform: { value: transform2, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }
  function Transform(k2, x2, y2) {
    this.k = k2;
    this.x = x2;
    this.y = y2;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k2) {
      return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
    },
    translate: function(x2, y2) {
      return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
    },
    apply: function(point) {
      return [point[0] * this.k + this.x, point[1] * this.k + this.y];
    },
    applyX: function(x2) {
      return x2 * this.k + this.x;
    },
    applyY: function(y2) {
      return y2 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x2) {
      return (x2 - this.x) / this.k;
    },
    invertY: function(y2) {
      return (y2 - this.y) / this.k;
    },
    rescaleX: function(x2) {
      return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
    },
    rescaleY: function(y2) {
      return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node) {
    while (!node.__zoom) if (!(node = node.parentNode)) return identity;
    return node.__zoom;
  }
  function nopropagation(event) {
    event.stopImmediatePropagation();
  }
  function noevent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function defaultFilter(event) {
    return (!event.ctrlKey || event.type === "wheel") && !event.button;
  }
  function defaultExtent() {
    var e2 = this;
    if (e2 instanceof SVGElement) {
      e2 = e2.ownerSVGElement || e2;
      if (e2.hasAttribute("viewBox")) {
        e2 = e2.viewBox.baseVal;
        return [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]];
      }
      return [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]];
    }
    return [[0, 0], [e2.clientWidth, e2.clientHeight]];
  }
  function defaultTransform() {
    return this.__zoom || identity;
  }
  function defaultWheelDelta(event) {
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
  }
  function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function defaultConstrain(transform2, extent, translateExtent) {
    var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
    return transform2.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }
  function zoom() {
    var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
    function zoom2(selection2) {
      selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    zoom2.transform = function(collection, transform2, point, event) {
      var selection2 = collection.selection ? collection.selection() : collection;
      selection2.property("__zoom", defaultTransform);
      if (collection !== selection2) {
        schedule2(collection, transform2, point, event);
      } else {
        selection2.interrupt().each(function() {
          gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
        });
      }
    };
    zoom2.scaleBy = function(selection2, k2, p2, event) {
      zoom2.scaleTo(selection2, function() {
        var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return k0 * k1;
      }, p2, event);
    };
    zoom2.scaleTo = function(selection2, k2, p2, event) {
      zoom2.transform(selection2, function() {
        var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return constrain(translate(scale(t0, k1), p0, p1), e2, translateExtent);
      }, p2, event);
    };
    zoom2.translateBy = function(selection2, x2, y2, event) {
      zoom2.transform(selection2, function() {
        return constrain(this.__zoom.translate(
          typeof x2 === "function" ? x2.apply(this, arguments) : x2,
          typeof y2 === "function" ? y2.apply(this, arguments) : y2
        ), extent.apply(this, arguments), translateExtent);
      }, null, event);
    };
    zoom2.translateTo = function(selection2, x2, y2, p2, event) {
      zoom2.transform(selection2, function() {
        var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
        return constrain(identity.translate(p0[0], p0[1]).scale(t2.k).translate(
          typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
          typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
        ), e2, translateExtent);
      }, p2, event);
    };
    function scale(transform2, k2) {
      k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
      return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
    }
    function translate(transform2, p0, p1) {
      var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
      return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
    }
    function centroid(extent2) {
      return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
    }
    function schedule2(transition, transform2, point, event) {
      transition.on("start.zoom", function() {
        gesture(this, arguments).event(event).start();
      }).on("interrupt.zoom end.zoom", function() {
        gesture(this, arguments).event(event).end();
      }).tween("zoom", function() {
        var that = this, args = arguments, g2 = gesture(that, args).event(event), e2 = extent.apply(that, args), p2 = point == null ? centroid(e2) : typeof point === "function" ? point.apply(that, args) : point, w2 = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a2 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i2 = interpolate2(a2.invert(p2).concat(w2 / a2.k), b.invert(p2).concat(w2 / b.k));
        return function(t2) {
          if (t2 === 1) t2 = b;
          else {
            var l2 = i2(t2), k2 = w2 / l2[2];
            t2 = new Transform(k2, p2[0] - l2[0] * k2, p2[1] - l2[1] * k2);
          }
          g2.zoom(null, t2);
        };
      });
    }
    function gesture(that, args, clean) {
      return !clean && that.__zooming || new Gesture(that, args);
    }
    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.active = 0;
      this.sourceEvent = null;
      this.extent = extent.apply(that, args);
      this.taps = 0;
    }
    Gesture.prototype = {
      event: function(event) {
        if (event) this.sourceEvent = event;
        return this;
      },
      start: function() {
        if (++this.active === 1) {
          this.that.__zooming = this;
          this.emit("start");
        }
        return this;
      },
      zoom: function(key, transform2) {
        if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
        if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
        if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
        this.that.__zoom = transform2;
        this.emit("zoom");
        return this;
      },
      end: function() {
        if (--this.active === 0) {
          delete this.that.__zooming;
          this.emit("end");
        }
        return this;
      },
      emit: function(type2) {
        var d2 = select(this.that).datum();
        listeners.call(
          type2,
          this.that,
          new ZoomEvent(type2, {
            sourceEvent: this.sourceEvent,
            target: zoom2,
            transform: this.that.__zoom,
            dispatch: listeners
          }),
          d2
        );
      }
    };
    function wheeled(event, ...args) {
      if (!filter2.apply(this, arguments)) return;
      var g2 = gesture(this, args).event(event), t2 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p2 = pointer(event);
      if (g2.wheel) {
        if (g2.mouse[0][0] !== p2[0] || g2.mouse[0][1] !== p2[1]) {
          g2.mouse[1] = t2.invert(g2.mouse[0] = p2);
        }
        clearTimeout(g2.wheel);
      } else if (t2.k === k2) return;
      else {
        g2.mouse = [p2, t2.invert(p2)];
        interrupt(this);
        g2.start();
      }
      noevent(event);
      g2.wheel = setTimeout(wheelidled, wheelDelay);
      g2.zoom("mouse", constrain(translate(scale(t2, k2), g2.mouse[0], g2.mouse[1]), g2.extent, translateExtent));
      function wheelidled() {
        g2.wheel = null;
        g2.end();
      }
    }
    function mousedowned(event, ...args) {
      if (touchending || !filter2.apply(this, arguments)) return;
      var currentTarget = event.currentTarget, g2 = gesture(this, args, true).event(event), v2 = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p2 = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
      dragDisable(event.view);
      nopropagation(event);
      g2.mouse = [p2, this.__zoom.invert(p2)];
      interrupt(this);
      g2.start();
      function mousemoved(event2) {
        noevent(event2);
        if (!g2.moved) {
          var dx = event2.clientX - x0, dy = event2.clientY - y0;
          g2.moved = dx * dx + dy * dy > clickDistance2;
        }
        g2.event(event2).zoom("mouse", constrain(translate(g2.that.__zoom, g2.mouse[0] = pointer(event2, currentTarget), g2.mouse[1]), g2.extent, translateExtent));
      }
      function mouseupped(event2) {
        v2.on("mousemove.zoom mouseup.zoom", null);
        yesdrag(event2.view, g2.moved);
        noevent(event2);
        g2.event(event2).end();
      }
    }
    function dblclicked(event, ...args) {
      if (!filter2.apply(this, arguments)) return;
      var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
      noevent(event);
      if (duration > 0) select(this).transition().duration(duration).call(schedule2, t1, p0, event);
      else select(this).call(zoom2.transform, t1, p0, event);
    }
    function touchstarted(event, ...args) {
      if (!filter2.apply(this, arguments)) return;
      var touches = event.touches, n2 = touches.length, g2 = gesture(this, args, event.changedTouches.length === n2).event(event), started, i2, t2, p2;
      nopropagation(event);
      for (i2 = 0; i2 < n2; ++i2) {
        t2 = touches[i2], p2 = pointer(t2, this);
        p2 = [p2, this.__zoom.invert(p2), t2.identifier];
        if (!g2.touch0) g2.touch0 = p2, started = true, g2.taps = 1 + !!touchstarting;
        else if (!g2.touch1 && g2.touch0[2] !== p2[2]) g2.touch1 = p2, g2.taps = 0;
      }
      if (touchstarting) touchstarting = clearTimeout(touchstarting);
      if (started) {
        if (g2.taps < 2) touchfirst = p2[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
        interrupt(this);
        g2.start();
      }
    }
    function touchmoved(event, ...args) {
      if (!this.__zooming) return;
      var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2, p2, l2;
      noevent(event);
      for (i2 = 0; i2 < n2; ++i2) {
        t2 = touches[i2], p2 = pointer(t2, this);
        if (g2.touch0 && g2.touch0[2] === t2.identifier) g2.touch0[0] = p2;
        else if (g2.touch1 && g2.touch1[2] === t2.identifier) g2.touch1[0] = p2;
      }
      t2 = g2.that.__zoom;
      if (g2.touch1) {
        var p0 = g2.touch0[0], l0 = g2.touch0[1], p1 = g2.touch1[0], l1 = g2.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t2 = scale(t2, Math.sqrt(dp / dl));
        p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
        l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g2.touch0) p2 = g2.touch0[0], l2 = g2.touch0[1];
      else return;
      g2.zoom("touch", constrain(translate(t2, p2, l2), g2.extent, translateExtent));
    }
    function touchended(event, ...args) {
      if (!this.__zooming) return;
      var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2;
      nopropagation(event);
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay);
      for (i2 = 0; i2 < n2; ++i2) {
        t2 = touches[i2];
        if (g2.touch0 && g2.touch0[2] === t2.identifier) delete g2.touch0;
        else if (g2.touch1 && g2.touch1[2] === t2.identifier) delete g2.touch1;
      }
      if (g2.touch1 && !g2.touch0) g2.touch0 = g2.touch1, delete g2.touch1;
      if (g2.touch0) g2.touch0[1] = this.__zoom.invert(g2.touch0[0]);
      else {
        g2.end();
        if (g2.taps === 2) {
          t2 = pointer(t2, this);
          if (Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance) {
            var p2 = select(this).on("dblclick.zoom");
            if (p2) p2.apply(this, arguments);
          }
        }
      }
    }
    zoom2.wheelDelta = function(_2) {
      return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant$1(+_2), zoom2) : wheelDelta;
    };
    zoom2.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant$1(!!_2), zoom2) : filter2;
    };
    zoom2.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$1(!!_2), zoom2) : touchable;
    };
    zoom2.extent = function(_2) {
      return arguments.length ? (extent = typeof _2 === "function" ? _2 : constant$1([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent;
    };
    zoom2.scaleExtent = function(_2) {
      return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
    };
    zoom2.translateExtent = function(_2) {
      return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };
    zoom2.constrain = function(_2) {
      return arguments.length ? (constrain = _2, zoom2) : constrain;
    };
    zoom2.duration = function(_2) {
      return arguments.length ? (duration = +_2, zoom2) : duration;
    };
    zoom2.interpolate = function(_2) {
      return arguments.length ? (interpolate2 = _2, zoom2) : interpolate2;
    };
    zoom2.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? zoom2 : value;
    };
    zoom2.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
    };
    zoom2.tapDistance = function(_2) {
      return arguments.length ? (tapDistance = +_2, zoom2) : tapDistance;
    };
    return zoom2;
  }
  class InternMap extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  }
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }
  function max$1(values, valueof) {
    let max2;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value;
        }
      }
    }
    return max2;
  }
  function min$1(values, valueof) {
    let min2;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value;
        }
      }
    }
    return min2;
  }
  function sum(values, valueof) {
    let sum2 = 0;
    {
      for (let value of values) {
        if (value = +value) {
          sum2 += value;
        }
      }
    }
    return sum2;
  }
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var Symbol$1 = root.Symbol;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty = objectProto$1.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$1.toString;
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag2 = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag2;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index2 = string.length;
    while (index2-- && reWhitespace.test(string.charAt(index2))) {
    }
    return index2;
  }
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  function isObject$1(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject$1(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject$1(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary2 = reIsBinary.test(value);
    return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var now$1 = function() {
    return root.Date.now();
  };
  var FUNC_ERROR_TEXT$1 = "Expected a function";
  var nativeMax = Math.max, nativeMin = Math.min;
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber(wait) || 0;
    if (isObject$1(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now$1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now$1());
    }
    function debounced() {
      var time = now$1(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  var FUNC_ERROR_TEXT = "Expected a function";
  function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject$1(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  var Easing = Object.freeze({
    Linear: Object.freeze({
      None: function(amount) {
        return amount;
      },
      In: function(amount) {
        return amount;
      },
      Out: function(amount) {
        return amount;
      },
      InOut: function(amount) {
        return amount;
      }
    }),
    Quadratic: Object.freeze({
      In: function(amount) {
        return amount * amount;
      },
      Out: function(amount) {
        return amount * (2 - amount);
      },
      InOut: function(amount) {
        if ((amount *= 2) < 1) {
          return 0.5 * amount * amount;
        }
        return -0.5 * (--amount * (amount - 2) - 1);
      }
    }),
    Cubic: Object.freeze({
      In: function(amount) {
        return amount * amount * amount;
      },
      Out: function(amount) {
        return --amount * amount * amount + 1;
      },
      InOut: function(amount) {
        if ((amount *= 2) < 1) {
          return 0.5 * amount * amount * amount;
        }
        return 0.5 * ((amount -= 2) * amount * amount + 2);
      }
    }),
    Quartic: Object.freeze({
      In: function(amount) {
        return amount * amount * amount * amount;
      },
      Out: function(amount) {
        return 1 - --amount * amount * amount * amount;
      },
      InOut: function(amount) {
        if ((amount *= 2) < 1) {
          return 0.5 * amount * amount * amount * amount;
        }
        return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
      }
    }),
    Quintic: Object.freeze({
      In: function(amount) {
        return amount * amount * amount * amount * amount;
      },
      Out: function(amount) {
        return --amount * amount * amount * amount * amount + 1;
      },
      InOut: function(amount) {
        if ((amount *= 2) < 1) {
          return 0.5 * amount * amount * amount * amount * amount;
        }
        return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
      }
    }),
    Sinusoidal: Object.freeze({
      In: function(amount) {
        return 1 - Math.sin((1 - amount) * Math.PI / 2);
      },
      Out: function(amount) {
        return Math.sin(amount * Math.PI / 2);
      },
      InOut: function(amount) {
        return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));
      }
    }),
    Exponential: Object.freeze({
      In: function(amount) {
        return amount === 0 ? 0 : Math.pow(1024, amount - 1);
      },
      Out: function(amount) {
        return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
      },
      InOut: function(amount) {
        if (amount === 0) {
          return 0;
        }
        if (amount === 1) {
          return 1;
        }
        if ((amount *= 2) < 1) {
          return 0.5 * Math.pow(1024, amount - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
      }
    }),
    Circular: Object.freeze({
      In: function(amount) {
        return 1 - Math.sqrt(1 - amount * amount);
      },
      Out: function(amount) {
        return Math.sqrt(1 - --amount * amount);
      },
      InOut: function(amount) {
        if ((amount *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
      }
    }),
    Elastic: Object.freeze({
      In: function(amount) {
        if (amount === 0) {
          return 0;
        }
        if (amount === 1) {
          return 1;
        }
        return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
      },
      Out: function(amount) {
        if (amount === 0) {
          return 0;
        }
        if (amount === 1) {
          return 1;
        }
        return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
      },
      InOut: function(amount) {
        if (amount === 0) {
          return 0;
        }
        if (amount === 1) {
          return 1;
        }
        amount *= 2;
        if (amount < 1) {
          return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        }
        return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
      }
    }),
    Back: Object.freeze({
      In: function(amount) {
        var s2 = 1.70158;
        return amount === 1 ? 1 : amount * amount * ((s2 + 1) * amount - s2);
      },
      Out: function(amount) {
        var s2 = 1.70158;
        return amount === 0 ? 0 : --amount * amount * ((s2 + 1) * amount + s2) + 1;
      },
      InOut: function(amount) {
        var s2 = 1.70158 * 1.525;
        if ((amount *= 2) < 1) {
          return 0.5 * (amount * amount * ((s2 + 1) * amount - s2));
        }
        return 0.5 * ((amount -= 2) * amount * ((s2 + 1) * amount + s2) + 2);
      }
    }),
    Bounce: Object.freeze({
      In: function(amount) {
        return 1 - Easing.Bounce.Out(1 - amount);
      },
      Out: function(amount) {
        if (amount < 1 / 2.75) {
          return 7.5625 * amount * amount;
        } else if (amount < 2 / 2.75) {
          return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
        } else if (amount < 2.5 / 2.75) {
          return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
        } else {
          return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
        }
      },
      InOut: function(amount) {
        if (amount < 0.5) {
          return Easing.Bounce.In(amount * 2) * 0.5;
        }
        return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
      }
    }),
    generatePow: function(power) {
      if (power === void 0) {
        power = 4;
      }
      power = power < Number.EPSILON ? Number.EPSILON : power;
      power = power > 1e4 ? 1e4 : power;
      return {
        In: function(amount) {
          return Math.pow(amount, power);
        },
        Out: function(amount) {
          return 1 - Math.pow(1 - amount, power);
        },
        InOut: function(amount) {
          if (amount < 0.5) {
            return Math.pow(amount * 2, power) / 2;
          }
          return (1 - Math.pow(2 - amount * 2, power)) / 2 + 0.5;
        }
      };
    }
  });
  var now = function() {
    return performance.now();
  };
  var Group = (
    /** @class */
    function() {
      function Group2() {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          tweens[_i] = arguments[_i];
        }
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
        this.add.apply(this, tweens);
      }
      Group2.prototype.getAll = function() {
        var _this = this;
        return Object.keys(this._tweens).map(function(tweenId) {
          return _this._tweens[tweenId];
        });
      };
      Group2.prototype.removeAll = function() {
        this._tweens = {};
      };
      Group2.prototype.add = function() {
        var _a;
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          tweens[_i] = arguments[_i];
        }
        for (var _b = 0, tweens_1 = tweens; _b < tweens_1.length; _b++) {
          var tween = tweens_1[_b];
          (_a = tween._group) === null || _a === void 0 ? void 0 : _a.remove(tween);
          tween._group = this;
          this._tweens[tween.getId()] = tween;
          this._tweensAddedDuringUpdate[tween.getId()] = tween;
        }
      };
      Group2.prototype.remove = function() {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          tweens[_i] = arguments[_i];
        }
        for (var _a = 0, tweens_2 = tweens; _a < tweens_2.length; _a++) {
          var tween = tweens_2[_a];
          tween._group = void 0;
          delete this._tweens[tween.getId()];
          delete this._tweensAddedDuringUpdate[tween.getId()];
        }
      };
      Group2.prototype.allStopped = function() {
        return this.getAll().every(function(tween) {
          return !tween.isPlaying();
        });
      };
      Group2.prototype.update = function(time, preserve) {
        if (time === void 0) {
          time = now();
        }
        if (preserve === void 0) {
          preserve = true;
        }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0)
          return;
        while (tweenIds.length > 0) {
          this._tweensAddedDuringUpdate = {};
          for (var i2 = 0; i2 < tweenIds.length; i2++) {
            var tween = this._tweens[tweenIds[i2]];
            var autoStart = !preserve;
            if (tween && tween.update(time, autoStart) === false && !preserve)
              this.remove(tween);
          }
          tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
      };
      return Group2;
    }()
  );
  var Interpolation = {
    Linear: function(v2, k2) {
      var m2 = v2.length - 1;
      var f2 = m2 * k2;
      var i2 = Math.floor(f2);
      var fn = Interpolation.Utils.Linear;
      if (k2 < 0) {
        return fn(v2[0], v2[1], f2);
      }
      if (k2 > 1) {
        return fn(v2[m2], v2[m2 - 1], m2 - f2);
      }
      return fn(v2[i2], v2[i2 + 1 > m2 ? m2 : i2 + 1], f2 - i2);
    },
    Utils: {
      Linear: function(p0, p1, t2) {
        return (p1 - p0) * t2 + p0;
      }
    }
  };
  var Sequence = (
    /** @class */
    function() {
      function Sequence2() {
      }
      Sequence2.nextId = function() {
        return Sequence2._nextId++;
      };
      Sequence2._nextId = 0;
      return Sequence2;
    }()
  );
  var mainGroup = new Group();
  var Tween = (
    /** @class */
    function() {
      function Tween2(object, group) {
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1e3;
        this._isDynamic = false;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._onEveryStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._propertiesAreSetUp = false;
        this._goToEnd = false;
        this._object = object;
        if (typeof group === "object") {
          this._group = group;
          group.add(this);
        } else if (group === true) {
          this._group = mainGroup;
          mainGroup.add(this);
        }
      }
      Tween2.prototype.getId = function() {
        return this._id;
      };
      Tween2.prototype.isPlaying = function() {
        return this._isPlaying;
      };
      Tween2.prototype.isPaused = function() {
        return this._isPaused;
      };
      Tween2.prototype.getDuration = function() {
        return this._duration;
      };
      Tween2.prototype.to = function(target, duration) {
        if (duration === void 0) {
          duration = 1e3;
        }
        if (this._isPlaying)
          throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
        this._valuesEnd = target;
        this._propertiesAreSetUp = false;
        this._duration = duration < 0 ? 0 : duration;
        return this;
      };
      Tween2.prototype.duration = function(duration) {
        if (duration === void 0) {
          duration = 1e3;
        }
        this._duration = duration < 0 ? 0 : duration;
        return this;
      };
      Tween2.prototype.dynamic = function(dynamic) {
        if (dynamic === void 0) {
          dynamic = false;
        }
        this._isDynamic = dynamic;
        return this;
      };
      Tween2.prototype.start = function(time, overrideStartingValues) {
        if (time === void 0) {
          time = now();
        }
        if (overrideStartingValues === void 0) {
          overrideStartingValues = false;
        }
        if (this._isPlaying) {
          return this;
        }
        this._repeat = this._initialRepeat;
        if (this._reversed) {
          this._reversed = false;
          for (var property in this._valuesStartRepeat) {
            this._swapEndStartRepeatValues(property);
            this._valuesStart[property] = this._valuesStartRepeat[property];
          }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._onEveryStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time;
        this._startTime += this._delayTime;
        if (!this._propertiesAreSetUp || overrideStartingValues) {
          this._propertiesAreSetUp = true;
          if (!this._isDynamic) {
            var tmp = {};
            for (var prop in this._valuesEnd)
              tmp[prop] = this._valuesEnd[prop];
            this._valuesEnd = tmp;
          }
          this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
        }
        return this;
      };
      Tween2.prototype.startFromCurrentValues = function(time) {
        return this.start(time, true);
      };
      Tween2.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
        for (var property in _valuesEnd) {
          var startValue = _object[property];
          var startValueIsArray = Array.isArray(startValue);
          var propType = startValueIsArray ? "array" : typeof startValue;
          var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
          if (propType === "undefined" || propType === "function") {
            continue;
          }
          if (isInterpolationList) {
            var endValues = _valuesEnd[property];
            if (endValues.length === 0) {
              continue;
            }
            var temp = [startValue];
            for (var i2 = 0, l2 = endValues.length; i2 < l2; i2 += 1) {
              var value = this._handleRelativeValue(startValue, endValues[i2]);
              if (isNaN(value)) {
                isInterpolationList = false;
                console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              temp.push(value);
            }
            if (isInterpolationList) {
              _valuesEnd[property] = temp;
            }
          }
          if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
            _valuesStart[property] = startValueIsArray ? [] : {};
            var nestedObject = startValue;
            for (var prop in nestedObject) {
              _valuesStart[property][prop] = nestedObject[prop];
            }
            _valuesStartRepeat[property] = startValueIsArray ? [] : {};
            var endValues = _valuesEnd[property];
            if (!this._isDynamic) {
              var tmp = {};
              for (var prop in endValues)
                tmp[prop] = endValues[prop];
              _valuesEnd[property] = endValues = tmp;
            }
            this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);
          } else {
            if (typeof _valuesStart[property] === "undefined" || overrideStartingValues) {
              _valuesStart[property] = startValue;
            }
            if (!startValueIsArray) {
              _valuesStart[property] *= 1;
            }
            if (isInterpolationList) {
              _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
            } else {
              _valuesStartRepeat[property] = _valuesStart[property] || 0;
            }
          }
        }
      };
      Tween2.prototype.stop = function() {
        if (!this._isChainStopped) {
          this._isChainStopped = true;
          this.stopChainedTweens();
        }
        if (!this._isPlaying) {
          return this;
        }
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
          this._onStopCallback(this._object);
        }
        return this;
      };
      Tween2.prototype.end = function() {
        this._goToEnd = true;
        this.update(this._startTime + this._duration);
        return this;
      };
      Tween2.prototype.pause = function(time) {
        if (time === void 0) {
          time = now();
        }
        if (this._isPaused || !this._isPlaying) {
          return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        return this;
      };
      Tween2.prototype.resume = function(time) {
        if (time === void 0) {
          time = now();
        }
        if (!this._isPaused || !this._isPlaying) {
          return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        return this;
      };
      Tween2.prototype.stopChainedTweens = function() {
        for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
          this._chainedTweens[i2].stop();
        }
        return this;
      };
      Tween2.prototype.group = function(group) {
        if (!group) {
          console.warn("tween.group() without args has been removed, use group.add(tween) instead.");
          return this;
        }
        group.add(this);
        return this;
      };
      Tween2.prototype.remove = function() {
        var _a;
        (_a = this._group) === null || _a === void 0 ? void 0 : _a.remove(this);
        return this;
      };
      Tween2.prototype.delay = function(amount) {
        if (amount === void 0) {
          amount = 0;
        }
        this._delayTime = amount;
        return this;
      };
      Tween2.prototype.repeat = function(times) {
        if (times === void 0) {
          times = 0;
        }
        this._initialRepeat = times;
        this._repeat = times;
        return this;
      };
      Tween2.prototype.repeatDelay = function(amount) {
        this._repeatDelayTime = amount;
        return this;
      };
      Tween2.prototype.yoyo = function(yoyo) {
        if (yoyo === void 0) {
          yoyo = false;
        }
        this._yoyo = yoyo;
        return this;
      };
      Tween2.prototype.easing = function(easingFunction) {
        if (easingFunction === void 0) {
          easingFunction = Easing.Linear.None;
        }
        this._easingFunction = easingFunction;
        return this;
      };
      Tween2.prototype.interpolation = function(interpolationFunction) {
        if (interpolationFunction === void 0) {
          interpolationFunction = Interpolation.Linear;
        }
        this._interpolationFunction = interpolationFunction;
        return this;
      };
      Tween2.prototype.chain = function() {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
      };
      Tween2.prototype.onStart = function(callback) {
        this._onStartCallback = callback;
        return this;
      };
      Tween2.prototype.onEveryStart = function(callback) {
        this._onEveryStartCallback = callback;
        return this;
      };
      Tween2.prototype.onUpdate = function(callback) {
        this._onUpdateCallback = callback;
        return this;
      };
      Tween2.prototype.onRepeat = function(callback) {
        this._onRepeatCallback = callback;
        return this;
      };
      Tween2.prototype.onComplete = function(callback) {
        this._onCompleteCallback = callback;
        return this;
      };
      Tween2.prototype.onStop = function(callback) {
        this._onStopCallback = callback;
        return this;
      };
      Tween2.prototype.update = function(time, autoStart) {
        var _this = this;
        var _a;
        if (time === void 0) {
          time = now();
        }
        if (autoStart === void 0) {
          autoStart = Tween2.autoStartOnUpdate;
        }
        if (this._isPaused)
          return true;
        var property;
        if (!this._goToEnd && !this._isPlaying) {
          if (autoStart)
            this.start(time, true);
          else
            return false;
        }
        this._goToEnd = false;
        if (time < this._startTime) {
          return true;
        }
        if (this._onStartCallbackFired === false) {
          if (this._onStartCallback) {
            this._onStartCallback(this._object);
          }
          this._onStartCallbackFired = true;
        }
        if (this._onEveryStartCallbackFired === false) {
          if (this._onEveryStartCallback) {
            this._onEveryStartCallback(this._object);
          }
          this._onEveryStartCallbackFired = true;
        }
        var elapsedTime = time - this._startTime;
        var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);
        var totalTime = this._duration + this._repeat * durationAndDelay;
        var calculateElapsedPortion = function() {
          if (_this._duration === 0)
            return 1;
          if (elapsedTime > totalTime) {
            return 1;
          }
          var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);
          var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;
          var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);
          if (portion === 0 && elapsedTime === _this._duration) {
            return 1;
          }
          return portion;
        };
        var elapsed = calculateElapsedPortion();
        var value = this._easingFunction(elapsed);
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (this._onUpdateCallback) {
          this._onUpdateCallback(this._object, elapsed);
        }
        if (this._duration === 0 || elapsedTime >= this._duration) {
          if (this._repeat > 0) {
            var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
            if (isFinite(this._repeat)) {
              this._repeat -= completeCount;
            }
            for (property in this._valuesStartRepeat) {
              if (!this._yoyo && typeof this._valuesEnd[property] === "string") {
                this._valuesStartRepeat[property] = // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
              }
              if (this._yoyo) {
                this._swapEndStartRepeatValues(property);
              }
              this._valuesStart[property] = this._valuesStartRepeat[property];
            }
            if (this._yoyo) {
              this._reversed = !this._reversed;
            }
            this._startTime += durationAndDelay * completeCount;
            if (this._onRepeatCallback) {
              this._onRepeatCallback(this._object);
            }
            this._onEveryStartCallbackFired = false;
            return true;
          } else {
            if (this._onCompleteCallback) {
              this._onCompleteCallback(this._object);
            }
            for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
              this._chainedTweens[i2].start(this._startTime + this._duration, false);
            }
            this._isPlaying = false;
            return false;
          }
        }
        return true;
      };
      Tween2.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
          if (_valuesStart[property] === void 0) {
            continue;
          }
          var start2 = _valuesStart[property] || 0;
          var end = _valuesEnd[property];
          var startIsArray = Array.isArray(_object[property]);
          var endIsArray = Array.isArray(end);
          var isInterpolationList = !startIsArray && endIsArray;
          if (isInterpolationList) {
            _object[property] = this._interpolationFunction(end, value);
          } else if (typeof end === "object" && end) {
            this._updateProperties(_object[property], start2, end, value);
          } else {
            end = this._handleRelativeValue(start2, end);
            if (typeof end === "number") {
              _object[property] = start2 + (end - start2) * value;
            }
          }
        }
      };
      Tween2.prototype._handleRelativeValue = function(start2, end) {
        if (typeof end !== "string") {
          return end;
        }
        if (end.charAt(0) === "+" || end.charAt(0) === "-") {
          return start2 + parseFloat(end);
        }
        return parseFloat(end);
      };
      Tween2.prototype._swapEndStartRepeatValues = function(property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === "string") {
          this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        } else {
          this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
      };
      Tween2.autoStartOnUpdate = false;
      return Tween2;
    }()
  );
  Sequence.nextId;
  var TWEEN = mainGroup;
  TWEEN.getAll.bind(TWEEN);
  TWEEN.removeAll.bind(TWEEN);
  TWEEN.add.bind(TWEEN);
  TWEEN.remove.bind(TWEEN);
  TWEEN.update.bind(TWEEN);
  function _arrayLikeToArray$4(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
    return n2;
  }
  function _arrayWithHoles$3(r2) {
    if (Array.isArray(r2)) return r2;
  }
  function _classCallCheck$1(a2, n2) {
    if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
  }
  function _createClass$1(e2, r2, t2) {
    return Object.defineProperty(e2, "prototype", {
      writable: false
    }), e2;
  }
  function _iterableToArrayLimit$3(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
        else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2)) return;
        } finally {
          if (o2) throw n2;
        }
      }
      return a2;
    }
  }
  function _nonIterableRest$3() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray$3(r2, e2) {
    return _arrayWithHoles$3(r2) || _iterableToArrayLimit$3(r2, e2) || _unsupportedIterableToArray$4(r2, e2) || _nonIterableRest$3();
  }
  function _unsupportedIterableToArray$4(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray$4(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$4(r2, a2) : void 0;
    }
  }
  var Prop = /* @__PURE__ */ _createClass$1(function Prop2(name, _ref) {
    var _ref$default = _ref["default"], defaultVal = _ref$default === void 0 ? null : _ref$default, _ref$triggerUpdate = _ref.triggerUpdate, triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? function(newVal, state) {
    } : _ref$onChange;
    _classCallCheck$1(this, Prop2);
    this.name = name;
    this.defaultVal = defaultVal;
    this.triggerUpdate = triggerUpdate;
    this.onChange = onChange;
  });
  function index$4(_ref2) {
    var _ref2$stateInit = _ref2.stateInit, stateInit = _ref2$stateInit === void 0 ? function() {
      return {};
    } : _ref2$stateInit, _ref2$props = _ref2.props, rawProps = _ref2$props === void 0 ? {} : _ref2$props, _ref2$methods = _ref2.methods, methods = _ref2$methods === void 0 ? {} : _ref2$methods, _ref2$aliases = _ref2.aliases, aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases, _ref2$init = _ref2.init, initFn = _ref2$init === void 0 ? function() {
    } : _ref2$init, _ref2$update = _ref2.update, updateFn = _ref2$update === void 0 ? function() {
    } : _ref2$update;
    var props = Object.keys(rawProps).map(function(propName) {
      return new Prop(propName, rawProps[propName]);
    });
    return function KapsuleComp() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var classMode = !!(this instanceof KapsuleComp ? this.constructor : void 0);
      var nodeElement = classMode ? args.shift() : void 0;
      var _args$ = args[0], options = _args$ === void 0 ? {} : _args$;
      var state = Object.assign(
        {},
        stateInit instanceof Function ? stateInit(options) : stateInit,
        // Support plain objects for backwards compatibility
        {
          initialised: false
        }
      );
      var changedProps = {};
      function comp(nodeElement2) {
        initStatic(nodeElement2, options);
        digest();
        return comp;
      }
      var initStatic = function initStatic2(nodeElement2, options2) {
        initFn.call(comp, nodeElement2, state, options2);
        state.initialised = true;
      };
      var digest = debounce(function() {
        if (!state.initialised) {
          return;
        }
        updateFn.call(comp, state, changedProps);
        changedProps = {};
      }, 1);
      props.forEach(function(prop) {
        comp[prop.name] = getSetProp(prop);
        function getSetProp(_ref3) {
          var prop2 = _ref3.name, _ref3$triggerUpdate = _ref3.triggerUpdate, redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate, _ref3$onChange = _ref3.onChange, onChange = _ref3$onChange === void 0 ? function(newVal, state2) {
          } : _ref3$onChange, _ref3$defaultVal = _ref3.defaultVal, defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
          return function(_2) {
            var curVal = state[prop2];
            if (!arguments.length) {
              return curVal;
            }
            var val = _2 === void 0 ? defaultVal : _2;
            state[prop2] = val;
            onChange.call(comp, val, state, curVal);
            !changedProps.hasOwnProperty(prop2) && (changedProps[prop2] = curVal);
            if (redigest) {
              digest();
            }
            return comp;
          };
        }
      });
      Object.keys(methods).forEach(function(methodName) {
        comp[methodName] = function() {
          var _methods$methodName;
          for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args2[_key2] = arguments[_key2];
          }
          return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args2));
        };
      });
      Object.entries(aliases).forEach(function(_ref4) {
        var _ref5 = _slicedToArray$3(_ref4, 2), alias = _ref5[0], target = _ref5[1];
        return comp[alias] = comp[target];
      });
      comp.resetProps = function() {
        props.forEach(function(prop) {
          comp[prop.name](prop.defaultVal);
        });
        return comp;
      };
      comp.resetProps();
      state._rerender = digest;
      classMode && nodeElement && comp(nodeElement);
      return comp;
    };
  }
  var index$3 = function(p2) {
    return typeof p2 === "function" ? p2 : typeof p2 === "string" ? function(obj) {
      return obj[p2];
    } : function(obj) {
      return p2;
    };
  };
  function _typeof$2(obj) {
    "@babel/helpers - typeof";
    return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof$2(obj);
  }
  var trimLeft = /^\s+/;
  var trimRight = /\s+$/;
  function tinycolor(color2, opts) {
    color2 = color2 ? color2 : "";
    opts = opts || {};
    if (color2 instanceof tinycolor) {
      return color2;
    }
    if (!(this instanceof tinycolor)) {
      return new tinycolor(color2, opts);
    }
    var rgb2 = inputToRGB(color2);
    this._originalInput = color2, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb2.format;
    this._gradientType = opts.gradientType;
    if (this._r < 1) this._r = Math.round(this._r);
    if (this._g < 1) this._g = Math.round(this._g);
    if (this._b < 1) this._b = Math.round(this._b);
    this._ok = rgb2.ok;
  }
  tinycolor.prototype = {
    isDark: function isDark() {
      return this.getBrightness() < 128;
    },
    isLight: function isLight() {
      return !this.isDark();
    },
    isValid: function isValid() {
      return this._ok;
    },
    getOriginalInput: function getOriginalInput() {
      return this._originalInput;
    },
    getFormat: function getFormat() {
      return this._format;
    },
    getAlpha: function getAlpha() {
      return this._a;
    },
    getBrightness: function getBrightness() {
      var rgb2 = this.toRgb();
      return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
    },
    getLuminance: function getLuminance() {
      var rgb2 = this.toRgb();
      var RsRGB, GsRGB, BsRGB, R, G2, B2;
      RsRGB = rgb2.r / 255;
      GsRGB = rgb2.g / 255;
      BsRGB = rgb2.b / 255;
      if (RsRGB <= 0.03928) R = RsRGB / 12.92;
      else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      if (GsRGB <= 0.03928) G2 = GsRGB / 12.92;
      else G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      if (BsRGB <= 0.03928) B2 = BsRGB / 12.92;
      else B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      return 0.2126 * R + 0.7152 * G2 + 0.0722 * B2;
    },
    setAlpha: function setAlpha(value) {
      this._a = boundAlpha(value);
      this._roundA = Math.round(100 * this._a) / 100;
      return this;
    },
    toHsv: function toHsv() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v,
        a: this._a
      };
    },
    toHsvString: function toHsvString() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      var h = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
      return this._a == 1 ? "hsv(" + h + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
    },
    toHsl: function toHsl() {
      var hsl2 = rgbToHsl(this._r, this._g, this._b);
      return {
        h: hsl2.h * 360,
        s: hsl2.s,
        l: hsl2.l,
        a: this._a
      };
    },
    toHslString: function toHslString() {
      var hsl2 = rgbToHsl(this._r, this._g, this._b);
      var h = Math.round(hsl2.h * 360), s2 = Math.round(hsl2.s * 100), l2 = Math.round(hsl2.l * 100);
      return this._a == 1 ? "hsl(" + h + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
    },
    toHex: function toHex(allow3Char) {
      return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function toHexString(allow3Char) {
      return "#" + this.toHex(allow3Char);
    },
    toHex8: function toHex8(allow4Char) {
      return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function toHex8String(allow4Char) {
      return "#" + this.toHex8(allow4Char);
    },
    toRgb: function toRgb() {
      return {
        r: Math.round(this._r),
        g: Math.round(this._g),
        b: Math.round(this._b),
        a: this._a
      };
    },
    toRgbString: function toRgbString() {
      return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function toPercentageRgb() {
      return {
        r: Math.round(bound01(this._r, 255) * 100) + "%",
        g: Math.round(bound01(this._g, 255) * 100) + "%",
        b: Math.round(bound01(this._b, 255) * 100) + "%",
        a: this._a
      };
    },
    toPercentageRgbString: function toPercentageRgbString() {
      return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function toName() {
      if (this._a === 0) {
        return "transparent";
      }
      if (this._a < 1) {
        return false;
      }
      return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function toFilter(secondColor) {
      var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
      var secondHex8String = hex8String;
      var gradientType = this._gradientType ? "GradientType = 1, " : "";
      if (secondColor) {
        var s2 = tinycolor(secondColor);
        secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
      }
      return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
    },
    toString: function toString(format) {
      var formatSet = !!format;
      format = format || this._format;
      var formattedString = false;
      var hasAlpha = this._a < 1 && this._a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
      if (needsAlphaFormat) {
        if (format === "name" && this._a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }
      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format === "name") {
        formattedString = this.toName();
      }
      if (format === "hsl") {
        formattedString = this.toHslString();
      }
      if (format === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    },
    clone: function clone() {
      return tinycolor(this.toString());
    },
    _applyModification: function _applyModification(fn, args) {
      var color2 = fn.apply(null, [this].concat([].slice.call(args)));
      this._r = color2._r;
      this._g = color2._g;
      this._b = color2._b;
      this.setAlpha(color2._a);
      return this;
    },
    lighten: function lighten() {
      return this._applyModification(_lighten, arguments);
    },
    brighten: function brighten() {
      return this._applyModification(_brighten, arguments);
    },
    darken: function darken() {
      return this._applyModification(_darken, arguments);
    },
    desaturate: function desaturate() {
      return this._applyModification(_desaturate, arguments);
    },
    saturate: function saturate() {
      return this._applyModification(_saturate, arguments);
    },
    greyscale: function greyscale() {
      return this._applyModification(_greyscale, arguments);
    },
    spin: function spin() {
      return this._applyModification(_spin, arguments);
    },
    _applyCombination: function _applyCombination(fn, args) {
      return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function analogous() {
      return this._applyCombination(_analogous, arguments);
    },
    complement: function complement() {
      return this._applyCombination(_complement, arguments);
    },
    monochromatic: function monochromatic() {
      return this._applyCombination(_monochromatic, arguments);
    },
    splitcomplement: function splitcomplement() {
      return this._applyCombination(_splitcomplement, arguments);
    },
    // Disabled until https://github.com/bgrins/TinyColor/issues/254
    // polyad: function (number) {
    //   return this._applyCombination(polyad, [number]);
    // },
    triad: function triad() {
      return this._applyCombination(polyad, [3]);
    },
    tetrad: function tetrad() {
      return this._applyCombination(polyad, [4]);
    }
  };
  tinycolor.fromRatio = function(color2, opts) {
    if (_typeof$2(color2) == "object") {
      var newColor = {};
      for (var i2 in color2) {
        if (color2.hasOwnProperty(i2)) {
          if (i2 === "a") {
            newColor[i2] = color2[i2];
          } else {
            newColor[i2] = convertToPercentage(color2[i2]);
          }
        }
      }
      color2 = newColor;
    }
    return tinycolor(color2, opts);
  };
  function inputToRGB(color2) {
    var rgb2 = {
      r: 0,
      g: 0,
      b: 0
    };
    var a2 = 1;
    var s2 = null;
    var v2 = null;
    var l2 = null;
    var ok = false;
    var format = false;
    if (typeof color2 == "string") {
      color2 = stringInputToObject(color2);
    }
    if (_typeof$2(color2) == "object") {
      if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
        rgb2 = rgbToRgb(color2.r, color2.g, color2.b);
        ok = true;
        format = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
        s2 = convertToPercentage(color2.s);
        v2 = convertToPercentage(color2.v);
        rgb2 = hsvToRgb(color2.h, s2, v2);
        ok = true;
        format = "hsv";
      } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
        s2 = convertToPercentage(color2.s);
        l2 = convertToPercentage(color2.l);
        rgb2 = hslToRgb(color2.h, s2, l2);
        ok = true;
        format = "hsl";
      }
      if (color2.hasOwnProperty("a")) {
        a2 = color2.a;
      }
    }
    a2 = boundAlpha(a2);
    return {
      ok,
      format: color2.format || format,
      r: Math.min(255, Math.max(rgb2.r, 0)),
      g: Math.min(255, Math.max(rgb2.g, 0)),
      b: Math.min(255, Math.max(rgb2.b, 0)),
      a: a2
    };
  }
  function rgbToRgb(r2, g2, b) {
    return {
      r: bound01(r2, 255) * 255,
      g: bound01(g2, 255) * 255,
      b: bound01(b, 255) * 255
    };
  }
  function rgbToHsl(r2, g2, b) {
    r2 = bound01(r2, 255);
    g2 = bound01(g2, 255);
    b = bound01(b, 255);
    var max2 = Math.max(r2, g2, b), min2 = Math.min(r2, g2, b);
    var h, s2, l2 = (max2 + min2) / 2;
    if (max2 == min2) {
      h = s2 = 0;
    } else {
      var d2 = max2 - min2;
      s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
      switch (max2) {
        case r2:
          h = (g2 - b) / d2 + (g2 < b ? 6 : 0);
          break;
        case g2:
          h = (b - r2) / d2 + 2;
          break;
        case b:
          h = (r2 - g2) / d2 + 4;
          break;
      }
      h /= 6;
    }
    return {
      h,
      s: s2,
      l: l2
    };
  }
  function hslToRgb(h, s2, l2) {
    var r2, g2, b;
    h = bound01(h, 360);
    s2 = bound01(s2, 100);
    l2 = bound01(l2, 100);
    function hue2rgb(p3, q3, t2) {
      if (t2 < 0) t2 += 1;
      if (t2 > 1) t2 -= 1;
      if (t2 < 1 / 6) return p3 + (q3 - p3) * 6 * t2;
      if (t2 < 1 / 2) return q3;
      if (t2 < 2 / 3) return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
      return p3;
    }
    if (s2 === 0) {
      r2 = g2 = b = l2;
    } else {
      var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      var p2 = 2 * l2 - q2;
      r2 = hue2rgb(p2, q2, h + 1 / 3);
      g2 = hue2rgb(p2, q2, h);
      b = hue2rgb(p2, q2, h - 1 / 3);
    }
    return {
      r: r2 * 255,
      g: g2 * 255,
      b: b * 255
    };
  }
  function rgbToHsv(r2, g2, b) {
    r2 = bound01(r2, 255);
    g2 = bound01(g2, 255);
    b = bound01(b, 255);
    var max2 = Math.max(r2, g2, b), min2 = Math.min(r2, g2, b);
    var h, s2, v2 = max2;
    var d2 = max2 - min2;
    s2 = max2 === 0 ? 0 : d2 / max2;
    if (max2 == min2) {
      h = 0;
    } else {
      switch (max2) {
        case r2:
          h = (g2 - b) / d2 + (g2 < b ? 6 : 0);
          break;
        case g2:
          h = (b - r2) / d2 + 2;
          break;
        case b:
          h = (r2 - g2) / d2 + 4;
          break;
      }
      h /= 6;
    }
    return {
      h,
      s: s2,
      v: v2
    };
  }
  function hsvToRgb(h, s2, v2) {
    h = bound01(h, 360) * 6;
    s2 = bound01(s2, 100);
    v2 = bound01(v2, 100);
    var i2 = Math.floor(h), f2 = h - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod], g2 = [t2, v2, v2, q2, p2, p2][mod], b = [p2, p2, t2, v2, v2, q2][mod];
    return {
      r: r2 * 255,
      g: g2 * 255,
      b: b * 255
    };
  }
  function rgbToHex(r2, g2, b, allow3Char) {
    var hex2 = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b).toString(16))];
    if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
      return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
    }
    return hex2.join("");
  }
  function rgbaToHex(r2, g2, b, a2, allow4Char) {
    var hex2 = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a2))];
    if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
      return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
    }
    return hex2.join("");
  }
  function rgbaToArgbHex(r2, g2, b, a2) {
    var hex2 = [pad2(convertDecimalToHex(a2)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b).toString(16))];
    return hex2.join("");
  }
  tinycolor.equals = function(color1, color2) {
    if (!color1 || !color2) return false;
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
  };
  tinycolor.random = function() {
    return tinycolor.fromRatio({
      r: Math.random(),
      g: Math.random(),
      b: Math.random()
    });
  };
  function _desaturate(color2, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl2 = tinycolor(color2).toHsl();
    hsl2.s -= amount / 100;
    hsl2.s = clamp01(hsl2.s);
    return tinycolor(hsl2);
  }
  function _saturate(color2, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl2 = tinycolor(color2).toHsl();
    hsl2.s += amount / 100;
    hsl2.s = clamp01(hsl2.s);
    return tinycolor(hsl2);
  }
  function _greyscale(color2) {
    return tinycolor(color2).desaturate(100);
  }
  function _lighten(color2, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl2 = tinycolor(color2).toHsl();
    hsl2.l += amount / 100;
    hsl2.l = clamp01(hsl2.l);
    return tinycolor(hsl2);
  }
  function _brighten(color2, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var rgb2 = tinycolor(color2).toRgb();
    rgb2.r = Math.max(0, Math.min(255, rgb2.r - Math.round(255 * -(amount / 100))));
    rgb2.g = Math.max(0, Math.min(255, rgb2.g - Math.round(255 * -(amount / 100))));
    rgb2.b = Math.max(0, Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));
    return tinycolor(rgb2);
  }
  function _darken(color2, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl2 = tinycolor(color2).toHsl();
    hsl2.l -= amount / 100;
    hsl2.l = clamp01(hsl2.l);
    return tinycolor(hsl2);
  }
  function _spin(color2, amount) {
    var hsl2 = tinycolor(color2).toHsl();
    var hue = (hsl2.h + amount) % 360;
    hsl2.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl2);
  }
  function _complement(color2) {
    var hsl2 = tinycolor(color2).toHsl();
    hsl2.h = (hsl2.h + 180) % 360;
    return tinycolor(hsl2);
  }
  function polyad(color2, number) {
    if (isNaN(number) || number <= 0) {
      throw new Error("Argument to polyad must be a positive number");
    }
    var hsl2 = tinycolor(color2).toHsl();
    var result = [tinycolor(color2)];
    var step = 360 / number;
    for (var i2 = 1; i2 < number; i2++) {
      result.push(tinycolor({
        h: (hsl2.h + i2 * step) % 360,
        s: hsl2.s,
        l: hsl2.l
      }));
    }
    return result;
  }
  function _splitcomplement(color2) {
    var hsl2 = tinycolor(color2).toHsl();
    var h = hsl2.h;
    return [tinycolor(color2), tinycolor({
      h: (h + 72) % 360,
      s: hsl2.s,
      l: hsl2.l
    }), tinycolor({
      h: (h + 216) % 360,
      s: hsl2.s,
      l: hsl2.l
    })];
  }
  function _analogous(color2, results, slices) {
    results = results || 6;
    slices = slices || 30;
    var hsl2 = tinycolor(color2).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color2)];
    for (hsl2.h = (hsl2.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl2.h = (hsl2.h + part) % 360;
      ret.push(tinycolor(hsl2));
    }
    return ret;
  }
  function _monochromatic(color2, results) {
    results = results || 6;
    var hsv = tinycolor(color2).toHsv();
    var h = hsv.h, s2 = hsv.s, v2 = hsv.v;
    var ret = [];
    var modification = 1 / results;
    while (results--) {
      ret.push(tinycolor({
        h,
        s: s2,
        v: v2
      }));
      v2 = (v2 + modification) % 1;
    }
    return ret;
  }
  tinycolor.mix = function(color1, color2, amount) {
    amount = amount === 0 ? 0 : amount || 50;
    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();
    var p2 = amount / 100;
    var rgba2 = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return tinycolor(rgba2);
  };
  tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
  };
  tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;
    out = false;
    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
      case "AAsmall":
      case "AAAlarge":
        out = readability >= 4.5;
        break;
      case "AAlarge":
        out = readability >= 3;
        break;
      case "AAAsmall":
        out = readability >= 7;
        break;
    }
    return out;
  };
  tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors;
    level = args.level;
    size = args.size;
    for (var i2 = 0; i2 < colorList.length; i2++) {
      readability = tinycolor.readability(baseColor, colorList[i2]);
      if (readability > bestScore) {
        bestScore = readability;
        bestColor = tinycolor(colorList[i2]);
      }
    }
    if (tinycolor.isReadable(baseColor, bestColor, {
      level,
      size
    }) || !includeFallbackColors) {
      return bestColor;
    } else {
      args.includeFallbackColors = false;
      return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
    }
  };
  var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  };
  var hexNames = tinycolor.hexNames = flip(names);
  function flip(o2) {
    var flipped = {};
    for (var i2 in o2) {
      if (o2.hasOwnProperty(i2)) {
        flipped[o2[i2]] = i2;
      }
    }
    return flipped;
  }
  function boundAlpha(a2) {
    a2 = parseFloat(a2);
    if (isNaN(a2) || a2 < 0 || a2 > 1) {
      a2 = 1;
    }
    return a2;
  }
  function bound01(n2, max2) {
    if (isOnePointZero(n2)) n2 = "100%";
    var processPercent = isPercentage(n2);
    n2 = Math.min(max2, Math.max(0, parseFloat(n2)));
    if (processPercent) {
      n2 = parseInt(n2 * max2, 10) / 100;
    }
    if (Math.abs(n2 - max2) < 1e-6) {
      return 1;
    }
    return n2 % max2 / parseFloat(max2);
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function isOnePointZero(n2) {
    return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
  }
  function isPercentage(n2) {
    return typeof n2 === "string" && n2.indexOf("%") != -1;
  }
  function pad2(c2) {
    return c2.length == 1 ? "0" + c2 : "" + c2;
  }
  function convertToPercentage(n2) {
    if (n2 <= 1) {
      n2 = n2 * 100 + "%";
    }
    return n2;
  }
  function convertDecimalToHex(d2) {
    return Math.round(parseFloat(d2) * 255).toString(16);
  }
  function convertHexToDecimal(h) {
    return parseIntFromHex(h) / 255;
  }
  var matchers = function() {
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    return {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
  }();
  function isValidCSSUnit(color2) {
    return !!matchers.CSS_UNIT.exec(color2);
  }
  function stringInputToObject(color2) {
    color2 = color2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
    var named2 = false;
    if (names[color2]) {
      color2 = names[color2];
      named2 = true;
    } else if (color2 == "transparent") {
      return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
      };
    }
    var match;
    if (match = matchers.rgb.exec(color2)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3]
      };
    }
    if (match = matchers.rgba.exec(color2)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hsl.exec(color2)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3]
      };
    }
    if (match = matchers.hsla.exec(color2)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hsv.exec(color2)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3]
      };
    }
    if (match = matchers.hsva.exec(color2)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hex8.exec(color2)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        a: convertHexToDecimal(match[4]),
        format: named2 ? "name" : "hex8"
      };
    }
    if (match = matchers.hex6.exec(color2)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        format: named2 ? "name" : "hex"
      };
    }
    if (match = matchers.hex4.exec(color2)) {
      return {
        r: parseIntFromHex(match[1] + "" + match[1]),
        g: parseIntFromHex(match[2] + "" + match[2]),
        b: parseIntFromHex(match[3] + "" + match[3]),
        a: convertHexToDecimal(match[4] + "" + match[4]),
        format: named2 ? "name" : "hex8"
      };
    }
    if (match = matchers.hex3.exec(color2)) {
      return {
        r: parseIntFromHex(match[1] + "" + match[1]),
        g: parseIntFromHex(match[2] + "" + match[2]),
        b: parseIntFromHex(match[3] + "" + match[3]),
        format: named2 ? "name" : "hex"
      };
    }
    return false;
  }
  function validateWCAG2Parms(parms) {
    var level, size;
    parms = parms || {
      level: "AA",
      size: "small"
    };
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
      level = "AA";
    }
    if (size !== "small" && size !== "large") {
      size = "small";
    }
    return {
      level,
      size
    };
  }
  function _arrayLikeToArray$3(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
    return n2;
  }
  function _arrayWithoutHoles$2(r2) {
    if (Array.isArray(r2)) return _arrayLikeToArray$3(r2);
  }
  function _assertClassBrand(e2, t2, n2) {
    if ("function" == typeof e2 ? e2 === t2 : e2.has(t2)) return arguments.length < 3 ? t2 : n2;
    throw new TypeError("Private element is not present on this object");
  }
  function _checkPrivateRedeclaration(e2, t2) {
    if (t2.has(e2)) throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
  function _classCallCheck(a2, n2) {
    if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
  }
  function _classPrivateFieldGet2(s2, a2) {
    return s2.get(_assertClassBrand(s2, a2));
  }
  function _classPrivateFieldInitSpec(e2, t2, a2) {
    _checkPrivateRedeclaration(e2, t2), t2.set(e2, a2);
  }
  function _classPrivateFieldSet2(s2, a2, r2) {
    return s2.set(_assertClassBrand(s2, a2), r2), r2;
  }
  function _defineProperties(e2, r2) {
    for (var t2 = 0; t2 < r2.length; t2++) {
      var o2 = r2[t2];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey$3(o2.key), o2);
    }
  }
  function _createClass(e2, r2, t2) {
    return r2 && _defineProperties(e2.prototype, r2), Object.defineProperty(e2, "prototype", {
      writable: false
    }), e2;
  }
  function _iterableToArray$2(r2) {
    if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
  }
  function _nonIterableSpread$2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray$2(r2) {
    return _arrayWithoutHoles$2(r2) || _iterableToArray$2(r2) || _unsupportedIterableToArray$3(r2) || _nonIterableSpread$2();
  }
  function _toPrimitive$3(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(t2);
  }
  function _toPropertyKey$3(t2) {
    var i2 = _toPrimitive$3(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _unsupportedIterableToArray$3(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray$3(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$3(r2, a2) : void 0;
    }
  }
  var ENTROPY = 123;
  var int2HexColor = function int2HexColor2(num) {
    return "#".concat(Math.min(num, Math.pow(2, 24)).toString(16).padStart(6, "0"));
  };
  var rgb2Int = function rgb2Int2(r2, g2, b) {
    return (r2 << 16) + (g2 << 8) + b;
  };
  var colorStr2Int = function colorStr2Int2(str2) {
    var _tinyColor$toRgb = tinycolor(str2).toRgb(), r2 = _tinyColor$toRgb.r, g2 = _tinyColor$toRgb.g, b = _tinyColor$toRgb.b;
    return rgb2Int(r2, g2, b);
  };
  var checksum = function checksum2(n2, csBits) {
    return n2 * ENTROPY % Math.pow(2, csBits);
  };
  var _registry = /* @__PURE__ */ new WeakMap();
  var _csBits = /* @__PURE__ */ new WeakMap();
  var _default$1 = /* @__PURE__ */ function() {
    function _default2() {
      var csBits = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6;
      _classCallCheck(this, _default2);
      _classPrivateFieldInitSpec(this, _registry, void 0);
      _classPrivateFieldInitSpec(this, _csBits, void 0);
      _classPrivateFieldSet2(_csBits, this, csBits);
      this.reset();
    }
    return _createClass(_default2, [{
      key: "reset",
      value: function reset() {
        _classPrivateFieldSet2(_registry, this, ["__reserved for background__"]);
      }
    }, {
      key: "register",
      value: function register(obj) {
        if (_classPrivateFieldGet2(_registry, this).length >= Math.pow(2, 24 - _classPrivateFieldGet2(_csBits, this))) {
          return null;
        }
        var idx = _classPrivateFieldGet2(_registry, this).length;
        var cs = checksum(idx, _classPrivateFieldGet2(_csBits, this));
        var color2 = int2HexColor(idx + (cs << 24 - _classPrivateFieldGet2(_csBits, this)));
        _classPrivateFieldGet2(_registry, this).push(obj);
        return color2;
      }
    }, {
      key: "lookup",
      value: function lookup(color2) {
        if (!color2) return null;
        var n2 = typeof color2 === "string" ? colorStr2Int(color2) : rgb2Int.apply(void 0, _toConsumableArray$2(color2));
        if (!n2) return null;
        var idx = n2 & Math.pow(2, 24 - _classPrivateFieldGet2(_csBits, this)) - 1;
        var cs = n2 >> 24 - _classPrivateFieldGet2(_csBits, this) & Math.pow(2, _classPrivateFieldGet2(_csBits, this)) - 1;
        if (checksum(idx, _classPrivateFieldGet2(_csBits, this)) !== cs || idx >= _classPrivateFieldGet2(_registry, this).length) return null;
        return _classPrivateFieldGet2(_registry, this)[idx];
      }
      // How many bits to reserve for checksum. Will eat away into the usable size of the registry.
    }]);
  }();
  var n, l, u, t$1, i$1, r, o, e, f, c$1, s, a$1, p = {}, v = [], y$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, w = Array.isArray;
  function d(n2, l2) {
    for (var u2 in l2) n2[u2] = l2[u2];
    return n2;
  }
  function g(n2) {
    n2 && n2.parentNode && n2.parentNode.removeChild(n2);
  }
  function _(l2, u2, t2) {
    var i2, r2, o2, e2 = {};
    for (o2 in u2) "key" == o2 ? i2 = u2[o2] : "ref" == o2 ? r2 = u2[o2] : e2[o2] = u2[o2];
    if (arguments.length > 2 && (e2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps) for (o2 in l2.defaultProps) void 0 === e2[o2] && (e2[o2] = l2.defaultProps[o2]);
    return m$1(l2, e2, i2, r2, null);
  }
  function m$1(n2, t2, i2, r2, o2) {
    var e2 = { type: n2, props: t2, key: i2, ref: r2, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o2 ? ++u : o2, __i: -1, __u: 0 };
    return null == o2 && null != l.vnode && l.vnode(e2), e2;
  }
  function k(n2) {
    return n2.children;
  }
  function x$1(n2, l2) {
    this.props = n2, this.context = l2;
  }
  function S(n2, l2) {
    if (null == l2) return n2.__ ? S(n2.__, n2.__i + 1) : null;
    for (var u2; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) return u2.__e;
    return "function" == typeof n2.type ? S(n2) : null;
  }
  function C(n2) {
    var l2, u2;
    if (null != (n2 = n2.__) && null != n2.__c) {
      for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
      return C(n2);
    }
  }
  function M(n2) {
    (!n2.__d && (n2.__d = true) && i$1.push(n2) && !$.__r++ || r != l.debounceRendering) && ((r = l.debounceRendering) || o)($);
  }
  function $() {
    for (var n2, u2, t2, r2, o2, f2, c2, s2 = 1; i$1.length; ) i$1.length > s2 && i$1.sort(e), n2 = i$1.shift(), s2 = i$1.length, n2.__d && (t2 = void 0, r2 = void 0, o2 = (r2 = (u2 = n2).__v).__e, f2 = [], c2 = [], u2.__P && ((t2 = d({}, r2)).__v = r2.__v + 1, l.vnode && l.vnode(t2), O(u2.__P, t2, r2, u2.__n, u2.__P.namespaceURI, 32 & r2.__u ? [o2] : null, f2, null == o2 ? S(r2) : o2, !!(32 & r2.__u), c2), t2.__v = r2.__v, t2.__.__k[t2.__i] = t2, N(f2, t2, c2), r2.__e = r2.__ = null, t2.__e != o2 && C(t2)));
    $.__r = 0;
  }
  function I(n2, l2, u2, t2, i2, r2, o2, e2, f2, c2, s2) {
    var a2, h, y2, w2, d2, g2, _2, m2 = t2 && t2.__k || v, b = l2.length;
    for (f2 = P(u2, l2, m2, f2, b), a2 = 0; a2 < b; a2++) null != (y2 = u2.__k[a2]) && (h = -1 == y2.__i ? p : m2[y2.__i] || p, y2.__i = a2, g2 = O(n2, y2, h, i2, r2, o2, e2, f2, c2, s2), w2 = y2.__e, y2.ref && h.ref != y2.ref && (h.ref && B(h.ref, null, y2), s2.push(y2.ref, y2.__c || w2, y2)), null == d2 && null != w2 && (d2 = w2), (_2 = !!(4 & y2.__u)) || h.__k === y2.__k ? f2 = A(y2, f2, n2, _2) : "function" == typeof y2.type && void 0 !== g2 ? f2 = g2 : w2 && (f2 = w2.nextSibling), y2.__u &= -7);
    return u2.__e = d2, f2;
  }
  function P(n2, l2, u2, t2, i2) {
    var r2, o2, e2, f2, c2, s2 = u2.length, a2 = s2, h = 0;
    for (n2.__k = new Array(i2), r2 = 0; r2 < i2; r2++) null != (o2 = l2[r2]) && "boolean" != typeof o2 && "function" != typeof o2 ? (f2 = r2 + h, (o2 = n2.__k[r2] = "string" == typeof o2 || "number" == typeof o2 || "bigint" == typeof o2 || o2.constructor == String ? m$1(null, o2, null, null, null) : w(o2) ? m$1(k, { children: o2 }, null, null, null) : null == o2.constructor && o2.__b > 0 ? m$1(o2.type, o2.props, o2.key, o2.ref ? o2.ref : null, o2.__v) : o2).__ = n2, o2.__b = n2.__b + 1, e2 = null, -1 != (c2 = o2.__i = L(o2, u2, f2, a2)) && (a2--, (e2 = u2[c2]) && (e2.__u |= 2)), null == e2 || null == e2.__v ? (-1 == c2 && (i2 > s2 ? h-- : i2 < s2 && h++), "function" != typeof o2.type && (o2.__u |= 4)) : c2 != f2 && (c2 == f2 - 1 ? h-- : c2 == f2 + 1 ? h++ : (c2 > f2 ? h-- : h++, o2.__u |= 4))) : n2.__k[r2] = null;
    if (a2) for (r2 = 0; r2 < s2; r2++) null != (e2 = u2[r2]) && 0 == (2 & e2.__u) && (e2.__e == t2 && (t2 = S(e2)), D(e2, e2));
    return t2;
  }
  function A(n2, l2, u2, t2) {
    var i2, r2;
    if ("function" == typeof n2.type) {
      for (i2 = n2.__k, r2 = 0; i2 && r2 < i2.length; r2++) i2[r2] && (i2[r2].__ = n2, l2 = A(i2[r2], l2, u2, t2));
      return l2;
    }
    n2.__e != l2 && (t2 && (l2 && n2.type && !l2.parentNode && (l2 = S(n2)), u2.insertBefore(n2.__e, l2 || null)), l2 = n2.__e);
    do {
      l2 = l2 && l2.nextSibling;
    } while (null != l2 && 8 == l2.nodeType);
    return l2;
  }
  function L(n2, l2, u2, t2) {
    var i2, r2, o2, e2 = n2.key, f2 = n2.type, c2 = l2[u2], s2 = null != c2 && 0 == (2 & c2.__u);
    if (null === c2 && null == n2.key || s2 && e2 == c2.key && f2 == c2.type) return u2;
    if (t2 > (s2 ? 1 : 0)) {
      for (i2 = u2 - 1, r2 = u2 + 1; i2 >= 0 || r2 < l2.length; ) if (null != (c2 = l2[o2 = i2 >= 0 ? i2-- : r2++]) && 0 == (2 & c2.__u) && e2 == c2.key && f2 == c2.type) return o2;
    }
    return -1;
  }
  function T(n2, l2, u2) {
    "-" == l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || y$1.test(l2) ? u2 : u2 + "px";
  }
  function j(n2, l2, u2, t2, i2) {
    var r2, o2;
    n: if ("style" == l2) if ("string" == typeof u2) n2.style.cssText = u2;
    else {
      if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2) for (l2 in t2) u2 && l2 in u2 || T(n2.style, l2, "");
      if (u2) for (l2 in u2) t2 && u2[l2] == t2[l2] || T(n2.style, l2, u2[l2]);
    }
    else if ("o" == l2[0] && "n" == l2[1]) r2 = l2 != (l2 = l2.replace(f, "$1")), o2 = l2.toLowerCase(), l2 = o2 in n2 || "onFocusOut" == l2 || "onFocusIn" == l2 ? o2.slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + r2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = c$1, n2.addEventListener(l2, r2 ? a$1 : s, r2)) : n2.removeEventListener(l2, r2 ? a$1 : s, r2);
    else {
      if ("http://www.w3.org/2000/svg" == i2) l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" != l2 && "height" != l2 && "href" != l2 && "list" != l2 && "form" != l2 && "tabIndex" != l2 && "download" != l2 && "rowSpan" != l2 && "colSpan" != l2 && "role" != l2 && "popover" != l2 && l2 in n2) try {
        n2[l2] = null == u2 ? "" : u2;
        break n;
      } catch (n3) {
      }
      "function" == typeof u2 || (null == u2 || false === u2 && "-" != l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, "popover" == l2 && 1 == u2 ? "" : u2));
    }
  }
  function F(n2) {
    return function(u2) {
      if (this.l) {
        var t2 = this.l[u2.type + n2];
        if (null == u2.t) u2.t = c$1++;
        else if (u2.t < t2.u) return;
        return t2(l.event ? l.event(u2) : u2);
      }
    };
  }
  function O(n2, u2, t2, i2, r2, o2, e2, f2, c2, s2) {
    var a2, h, p2, v2, y2, _2, m2, b, S2, C2, M2, $2, P2, A2, H, L2, T2, j2 = u2.type;
    if (null != u2.constructor) return null;
    128 & t2.__u && (c2 = !!(32 & t2.__u), o2 = [f2 = u2.__e = t2.__e]), (a2 = l.__b) && a2(u2);
    n: if ("function" == typeof j2) try {
      if (b = u2.props, S2 = "prototype" in j2 && j2.prototype.render, C2 = (a2 = j2.contextType) && i2[a2.__c], M2 = a2 ? C2 ? C2.props.value : a2.__ : i2, t2.__c ? m2 = (h = u2.__c = t2.__c).__ = h.__E : (S2 ? u2.__c = h = new j2(b, M2) : (u2.__c = h = new x$1(b, M2), h.constructor = j2, h.render = E), C2 && C2.sub(h), h.props = b, h.state || (h.state = {}), h.context = M2, h.__n = i2, p2 = h.__d = true, h.__h = [], h._sb = []), S2 && null == h.__s && (h.__s = h.state), S2 && null != j2.getDerivedStateFromProps && (h.__s == h.state && (h.__s = d({}, h.__s)), d(h.__s, j2.getDerivedStateFromProps(b, h.__s))), v2 = h.props, y2 = h.state, h.__v = u2, p2) S2 && null == j2.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), S2 && null != h.componentDidMount && h.__h.push(h.componentDidMount);
      else {
        if (S2 && null == j2.getDerivedStateFromProps && b !== v2 && null != h.componentWillReceiveProps && h.componentWillReceiveProps(b, M2), !h.__e && null != h.shouldComponentUpdate && false === h.shouldComponentUpdate(b, h.__s, M2) || u2.__v == t2.__v) {
          for (u2.__v != t2.__v && (h.props = b, h.state = h.__s, h.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.some(function(n3) {
            n3 && (n3.__ = u2);
          }), $2 = 0; $2 < h._sb.length; $2++) h.__h.push(h._sb[$2]);
          h._sb = [], h.__h.length && e2.push(h);
          break n;
        }
        null != h.componentWillUpdate && h.componentWillUpdate(b, h.__s, M2), S2 && null != h.componentDidUpdate && h.__h.push(function() {
          h.componentDidUpdate(v2, y2, _2);
        });
      }
      if (h.context = M2, h.props = b, h.__P = n2, h.__e = false, P2 = l.__r, A2 = 0, S2) {
        for (h.state = h.__s, h.__d = false, P2 && P2(u2), a2 = h.render(h.props, h.state, h.context), H = 0; H < h._sb.length; H++) h.__h.push(h._sb[H]);
        h._sb = [];
      } else do {
        h.__d = false, P2 && P2(u2), a2 = h.render(h.props, h.state, h.context), h.state = h.__s;
      } while (h.__d && ++A2 < 25);
      h.state = h.__s, null != h.getChildContext && (i2 = d(d({}, i2), h.getChildContext())), S2 && !p2 && null != h.getSnapshotBeforeUpdate && (_2 = h.getSnapshotBeforeUpdate(v2, y2)), L2 = a2, null != a2 && a2.type === k && null == a2.key && (L2 = V(a2.props.children)), f2 = I(n2, w(L2) ? L2 : [L2], u2, t2, i2, r2, o2, e2, f2, c2, s2), h.base = u2.__e, u2.__u &= -161, h.__h.length && e2.push(h), m2 && (h.__E = h.__ = null);
    } catch (n3) {
      if (u2.__v = null, c2 || null != o2) if (n3.then) {
        for (u2.__u |= c2 ? 160 : 128; f2 && 8 == f2.nodeType && f2.nextSibling; ) f2 = f2.nextSibling;
        o2[o2.indexOf(f2)] = null, u2.__e = f2;
      } else {
        for (T2 = o2.length; T2--; ) g(o2[T2]);
        z$1(u2);
      }
      else u2.__e = t2.__e, u2.__k = t2.__k, n3.then || z$1(u2);
      l.__e(n3, u2, t2);
    }
    else null == o2 && u2.__v == t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : f2 = u2.__e = q(t2.__e, u2, t2, i2, r2, o2, e2, c2, s2);
    return (a2 = l.diffed) && a2(u2), 128 & u2.__u ? void 0 : f2;
  }
  function z$1(n2) {
    n2 && n2.__c && (n2.__c.__e = true), n2 && n2.__k && n2.__k.forEach(z$1);
  }
  function N(n2, u2, t2) {
    for (var i2 = 0; i2 < t2.length; i2++) B(t2[i2], t2[++i2], t2[++i2]);
    l.__c && l.__c(u2, n2), n2.some(function(u3) {
      try {
        n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
          n3.call(u3);
        });
      } catch (n3) {
        l.__e(n3, u3.__v);
      }
    });
  }
  function V(n2) {
    return "object" != typeof n2 || null == n2 || n2.__b && n2.__b > 0 ? n2 : w(n2) ? n2.map(V) : d({}, n2);
  }
  function q(u2, t2, i2, r2, o2, e2, f2, c2, s2) {
    var a2, h, v2, y2, d2, _2, m2, b = i2.props, k2 = t2.props, x2 = t2.type;
    if ("svg" == x2 ? o2 = "http://www.w3.org/2000/svg" : "math" == x2 ? o2 = "http://www.w3.org/1998/Math/MathML" : o2 || (o2 = "http://www.w3.org/1999/xhtml"), null != e2) {
      for (a2 = 0; a2 < e2.length; a2++) if ((d2 = e2[a2]) && "setAttribute" in d2 == !!x2 && (x2 ? d2.localName == x2 : 3 == d2.nodeType)) {
        u2 = d2, e2[a2] = null;
        break;
      }
    }
    if (null == u2) {
      if (null == x2) return document.createTextNode(k2);
      u2 = document.createElementNS(o2, x2, k2.is && k2), c2 && (l.__m && l.__m(t2, e2), c2 = false), e2 = null;
    }
    if (null == x2) b === k2 || c2 && u2.data == k2 || (u2.data = k2);
    else {
      if (e2 = e2 && n.call(u2.childNodes), b = i2.props || p, !c2 && null != e2) for (b = {}, a2 = 0; a2 < u2.attributes.length; a2++) b[(d2 = u2.attributes[a2]).name] = d2.value;
      for (a2 in b) if (d2 = b[a2], "children" == a2) ;
      else if ("dangerouslySetInnerHTML" == a2) v2 = d2;
      else if (!(a2 in k2)) {
        if ("value" == a2 && "defaultValue" in k2 || "checked" == a2 && "defaultChecked" in k2) continue;
        j(u2, a2, null, d2, o2);
      }
      for (a2 in k2) d2 = k2[a2], "children" == a2 ? y2 = d2 : "dangerouslySetInnerHTML" == a2 ? h = d2 : "value" == a2 ? _2 = d2 : "checked" == a2 ? m2 = d2 : c2 && "function" != typeof d2 || b[a2] === d2 || j(u2, a2, d2, b[a2], o2);
      if (h) c2 || v2 && (h.__html == v2.__html || h.__html == u2.innerHTML) || (u2.innerHTML = h.__html), t2.__k = [];
      else if (v2 && (u2.innerHTML = ""), I("template" == t2.type ? u2.content : u2, w(y2) ? y2 : [y2], t2, i2, r2, "foreignObject" == x2 ? "http://www.w3.org/1999/xhtml" : o2, e2, f2, e2 ? e2[0] : i2.__k && S(i2, 0), c2, s2), null != e2) for (a2 = e2.length; a2--; ) g(e2[a2]);
      c2 || (a2 = "value", "progress" == x2 && null == _2 ? u2.removeAttribute("value") : null != _2 && (_2 !== u2[a2] || "progress" == x2 && !_2 || "option" == x2 && _2 != b[a2]) && j(u2, a2, _2, b[a2], o2), a2 = "checked", null != m2 && m2 != u2[a2] && j(u2, a2, m2, b[a2], o2));
    }
    return u2;
  }
  function B(n2, u2, t2) {
    try {
      if ("function" == typeof n2) {
        var i2 = "function" == typeof n2.__u;
        i2 && n2.__u(), i2 && null == u2 || (n2.__u = n2(u2));
      } else n2.current = u2;
    } catch (n3) {
      l.__e(n3, t2);
    }
  }
  function D(n2, u2, t2) {
    var i2, r2;
    if (l.unmount && l.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current != n2.__e || B(i2, null, u2)), null != (i2 = n2.__c)) {
      if (i2.componentWillUnmount) try {
        i2.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u2);
      }
      i2.base = i2.__P = null;
    }
    if (i2 = n2.__k) for (r2 = 0; r2 < i2.length; r2++) i2[r2] && D(i2[r2], u2, t2 || "function" != typeof n2.type);
    t2 || g(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
  }
  function E(n2, l2, u2) {
    return this.constructor(n2, u2);
  }
  function G(u2, t2, i2) {
    var r2, o2, e2, f2;
    t2 == document && (t2 = document.documentElement), l.__ && l.__(u2, t2), o2 = (r2 = false) ? null : t2.__k, e2 = [], f2 = [], O(t2, u2 = t2.__k = _(k, null, [u2]), o2 || p, p, t2.namespaceURI, o2 ? null : t2.firstChild ? n.call(t2.childNodes) : null, e2, o2 ? o2.__e : t2.firstChild, r2, f2), N(e2, u2, f2);
  }
  function K(l2, u2, t2) {
    var i2, r2, o2, e2, f2 = d({}, l2.props);
    for (o2 in l2.type && l2.type.defaultProps && (e2 = l2.type.defaultProps), u2) "key" == o2 ? i2 = u2[o2] : "ref" == o2 ? r2 = u2[o2] : f2[o2] = void 0 === u2[o2] && null != e2 ? e2[o2] : u2[o2];
    return arguments.length > 2 && (f2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), m$1(l2.type, f2, i2 || l2.key, r2 || l2.ref, null);
  }
  n = v.slice, l = { __e: function(n2, l2, u2, t2) {
    for (var i2, r2, o2; l2 = l2.__; ) if ((i2 = l2.__c) && !i2.__) try {
      if ((r2 = i2.constructor) && null != r2.getDerivedStateFromError && (i2.setState(r2.getDerivedStateFromError(n2)), o2 = i2.__d), null != i2.componentDidCatch && (i2.componentDidCatch(n2, t2 || {}), o2 = i2.__d), o2) return i2.__E = i2;
    } catch (l3) {
      n2 = l3;
    }
    throw n2;
  } }, u = 0, t$1 = function(n2) {
    return null != n2 && null == n2.constructor;
  }, x$1.prototype.setState = function(n2, l2) {
    var u2;
    u2 = null != this.__s && this.__s != this.state ? this.__s : this.__s = d({}, this.state), "function" == typeof n2 && (n2 = n2(d({}, u2), this.props)), n2 && d(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), M(this));
  }, x$1.prototype.forceUpdate = function(n2) {
    this.__v && (this.__e = true, n2 && this.__h.push(n2), M(this));
  }, x$1.prototype.render = k, i$1 = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n2, l2) {
    return n2.__v.__b - l2.__v.__b;
  }, $.__r = 0, f = /(PointerCapture)$|Capture$/i, c$1 = 0, s = F(false), a$1 = F(true);
  function _arrayLikeToArray$2(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
    return n2;
  }
  function _arrayWithHoles$2(r2) {
    if (Array.isArray(r2)) return r2;
  }
  function _defineProperty$1(e2, r2, t2) {
    return (r2 = _toPropertyKey$2(r2)) in e2 ? Object.defineProperty(e2, r2, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e2[r2] = t2, e2;
  }
  function _iterableToArrayLimit$2(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
        else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2)) return;
        } finally {
          if (o2) throw n2;
        }
      }
      return a2;
    }
  }
  function _nonIterableRest$2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys$1(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread2$1(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
        _defineProperty$1(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  function _slicedToArray$2(r2, e2) {
    return _arrayWithHoles$2(r2) || _iterableToArrayLimit$2(r2, e2) || _unsupportedIterableToArray$2(r2, e2) || _nonIterableRest$2();
  }
  function _toPrimitive$2(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function _toPropertyKey$2(t2) {
    var i2 = _toPrimitive$2(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _typeof$1(o2) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof$1(o2);
  }
  function _unsupportedIterableToArray$2(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray$2(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$2(r2, a2) : void 0;
    }
  }
  var _reactElement2VNode = function reactElement2VNode(el) {
    if (!(_typeof$1(el) === "object")) return el;
    var res = K(el);
    if (res.props) {
      var _res$props;
      res.props = _objectSpread2$1({}, res.props);
      if (res !== null && res !== void 0 && (_res$props = res.props) !== null && _res$props !== void 0 && _res$props.children) {
        res.props.children = Array.isArray(res.props.children) ? res.props.children.map(_reactElement2VNode) : _reactElement2VNode(res.props.children);
      }
    }
    return res;
  };
  var isReactRenderable = function isReactRenderable2(o2) {
    return t$1(K(o2));
  };
  var render = function render2(jsx, domEl) {
    delete domEl.__k;
    G(_reactElement2VNode(jsx), domEl);
  };
  function styleInject$1(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;
    if (typeof document === "undefined") {
      return;
    }
    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";
    if (insertAt === "top") {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }
    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }
  var css_248z$1 = ".float-tooltip-kap {\n  position: absolute;\n  width: max-content; /* prevent shrinking near right edge */\n  max-width: max(50%, 150px);\n  padding: 3px 5px;\n  border-radius: 3px;\n  font: 12px sans-serif;\n  color: #eee;\n  background: rgba(0,0,0,0.6);\n  pointer-events: none;\n}\n";
  styleInject$1(css_248z$1);
  var index$2 = index$4({
    props: {
      content: {
        "default": false
      },
      offsetX: {
        triggerUpdate: false
      },
      // null or number
      offsetY: {
        triggerUpdate: false
      }
      // null or number
    },
    init: function init2(domNode, state) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style;
      var isD3Selection = !!domNode && _typeof$1(domNode) === "object" && !!domNode.node && typeof domNode.node === "function";
      var el = select(isD3Selection ? domNode.node() : domNode);
      el.style("position") === "static" && el.style("position", "relative");
      state.tooltipEl = el.append("div").attr("class", "float-tooltip-kap");
      Object.entries(style).forEach(function(_ref2) {
        var _ref3 = _slicedToArray$2(_ref2, 2), k2 = _ref3[0], v2 = _ref3[1];
        return state.tooltipEl.style(k2, v2);
      });
      state.tooltipEl.style("left", "-10000px").style("display", "none");
      var evSuffix = "tooltip-".concat(Math.round(Math.random() * 1e12));
      state.mouseInside = false;
      el.on("mousemove.".concat(evSuffix), function(ev) {
        state.mouseInside = true;
        var mousePos = pointer(ev);
        var domNode2 = el.node();
        var canvasWidth = domNode2.offsetWidth;
        var canvasHeight = domNode2.offsetHeight;
        var translate = [state.offsetX === null || state.offsetX === void 0 ? "-".concat(mousePos[0] / canvasWidth * 100, "%") : typeof state.offsetX === "number" ? "calc(-50% + ".concat(state.offsetX, "px)") : state.offsetX, state.offsetY === null || state.offsetY === void 0 ? canvasHeight > 130 && canvasHeight - mousePos[1] < 100 ? "calc(-100% - 6px)" : "21px" : typeof state.offsetY === "number" ? state.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(state.offsetY), "px)") : "".concat(state.offsetY, "px") : state.offsetY];
        state.tooltipEl.style("left", mousePos[0] + "px").style("top", mousePos[1] + "px").style("transform", "translate(".concat(translate.join(","), ")"));
        state.content && state.tooltipEl.style("display", "inline");
      });
      el.on("mouseover.".concat(evSuffix), function() {
        state.mouseInside = true;
        state.content && state.tooltipEl.style("display", "inline");
      });
      el.on("mouseout.".concat(evSuffix), function() {
        state.mouseInside = false;
        state.tooltipEl.style("display", "none");
      });
    },
    update: function update(state) {
      state.tooltipEl.style("display", !!state.content && state.mouseInside ? "inline" : "none");
      if (!state.content) {
        state.tooltipEl.text("");
      } else if (state.content instanceof HTMLElement) {
        state.tooltipEl.text("");
        state.tooltipEl.append(function() {
          return state.content;
        });
      } else if (typeof state.content === "string") {
        state.tooltipEl.html(state.content);
      } else if (isReactRenderable(state.content)) {
        state.tooltipEl.text("");
        render(state.content, state.tooltipEl.node());
      } else {
        state.tooltipEl.style("display", "none");
        console.warn("Tooltip content is invalid, skipping.", state.content, state.content.toString());
      }
    }
  });
  function forceCenter(x2, y2, z2) {
    var nodes, strength = 1;
    if (x2 == null) x2 = 0;
    if (y2 == null) y2 = 0;
    if (z2 == null) z2 = 0;
    function force() {
      var i2, n2 = nodes.length, node, sx = 0, sy = 0, sz = 0;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2], sx += node.x || 0, sy += node.y || 0, sz += node.z || 0;
      }
      for (sx = (sx / n2 - x2) * strength, sy = (sy / n2 - y2) * strength, sz = (sz / n2 - z2) * strength, i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (sx) {
          node.x -= sx;
        }
        if (sy) {
          node.y -= sy;
        }
        if (sz) {
          node.z -= sz;
        }
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
    };
    force.x = function(_2) {
      return arguments.length ? (x2 = +_2, force) : x2;
    };
    force.y = function(_2) {
      return arguments.length ? (y2 = +_2, force) : y2;
    };
    force.z = function(_2) {
      return arguments.length ? (z2 = +_2, force) : z2;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = +_2, force) : strength;
    };
    return force;
  }
  function tree_add$2(d2) {
    const x2 = +this._x.call(null, d2);
    return add$2(this.cover(x2), x2, d2);
  }
  function add$2(tree, x2, d2) {
    if (isNaN(x2)) return tree;
    var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, x1 = tree._x1, xm, xp, right, i2, j2;
    if (!node) return tree._root = leaf, tree;
    while (node.length) {
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (parent = node, !(node = node[i2 = +right])) return parent[i2] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    if (x2 === xp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i2] = new Array(2) : tree._root = new Array(2);
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
    } while ((i2 = +right) === (j2 = +(xp >= xm)));
    return parent[j2] = node, parent[i2] = leaf, tree;
  }
  function addAll$2(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    const n2 = data.length;
    const xz = new Float64Array(n2);
    let x0 = Infinity, x1 = -Infinity;
    for (let i2 = 0, x2; i2 < n2; ++i2) {
      if (isNaN(x2 = +this._x.call(null, data[i2]))) continue;
      xz[i2] = x2;
      if (x2 < x0) x0 = x2;
      if (x2 > x1) x1 = x2;
    }
    if (x0 > x1) return this;
    this.cover(x0).cover(x1);
    for (let i2 = 0; i2 < n2; ++i2) {
      add$2(this, xz[i2], data[i2]);
    }
    return this;
  }
  function tree_cover$2(x2) {
    if (isNaN(x2 = +x2)) return this;
    var x0 = this._x0, x1 = this._x1;
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x2)) + 1;
    } else {
      var z2 = x1 - x0 || 1, node = this._root, parent, i2;
      while (x0 > x2 || x2 >= x1) {
        i2 = +(x2 < x0);
        parent = new Array(2), parent[i2] = node, node = parent, z2 *= 2;
        switch (i2) {
          case 0:
            x1 = x0 + z2;
            break;
          case 1:
            x0 = x1 - z2;
            break;
        }
      }
      if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x0;
    this._x1 = x1;
    return this;
  }
  function tree_data$2() {
    var data = [];
    this.visit(function(node) {
      if (!node.length) do
        data.push(node.data);
      while (node = node.next);
    });
    return data;
  }
  function tree_extent$2(_2) {
    return arguments.length ? this.cover(+_2[0][0]).cover(+_2[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
  }
  function Half(node, x0, x1) {
    this.node = node;
    this.x0 = x0;
    this.x1 = x1;
  }
  function tree_find$2(x2, radius) {
    var data, x0 = this._x0, x1, x22, x3 = this._x1, halves = [], node = this._root, q2, i2;
    if (node) halves.push(new Half(node, x0, x3));
    if (radius == null) radius = Infinity;
    else {
      x0 = x2 - radius;
      x3 = x2 + radius;
    }
    while (q2 = halves.pop()) {
      if (!(node = q2.node) || (x1 = q2.x0) > x3 || (x22 = q2.x1) < x0) continue;
      if (node.length) {
        var xm = (x1 + x22) / 2;
        halves.push(
          new Half(node[1], xm, x22),
          new Half(node[0], x1, xm)
        );
        if (i2 = +(x2 >= xm)) {
          q2 = halves[halves.length - 1];
          halves[halves.length - 1] = halves[halves.length - 1 - i2];
          halves[halves.length - 1 - i2] = q2;
        }
      } else {
        var d2 = Math.abs(x2 - +this._x.call(null, node.data));
        if (d2 < radius) {
          radius = d2;
          x0 = x2 - d2;
          x3 = x2 + d2;
          data = node.data;
        }
      }
    }
    return data;
  }
  function tree_remove$2(d2) {
    if (isNaN(x2 = +this._x.call(null, d2))) return this;
    var parent, node = this._root, retainer, previous, next, x0 = this._x0, x1 = this._x1, x2, xm, right, i2, j2;
    if (!node) return this;
    if (node.length) while (true) {
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (!(parent = node, node = node[i2 = +right])) return this;
      if (!node.length) break;
      if (parent[i2 + 1 & 1]) retainer = parent, j2 = i2;
    }
    while (node.data !== d2) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;
    if (previous) return next ? previous.next = next : delete previous.next, this;
    if (!parent) return this._root = next, this;
    next ? parent[i2] = next : delete parent[i2];
    if ((node = parent[0] || parent[1]) && node === (parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j2] = node;
      else this._root = node;
    }
    return this;
  }
  function removeAll$2(data) {
    for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
    return this;
  }
  function tree_root$2() {
    return this._root;
  }
  function tree_size$2() {
    var size = 0;
    this.visit(function(node) {
      if (!node.length) do
        ++size;
      while (node = node.next);
    });
    return size;
  }
  function tree_visit$2(callback) {
    var halves = [], q2, node = this._root, child, x0, x1;
    if (node) halves.push(new Half(node, this._x0, this._x1));
    while (q2 = halves.pop()) {
      if (!callback(node = q2.node, x0 = q2.x0, x1 = q2.x1) && node.length) {
        var xm = (x0 + x1) / 2;
        if (child = node[1]) halves.push(new Half(child, xm, x1));
        if (child = node[0]) halves.push(new Half(child, x0, xm));
      }
    }
    return this;
  }
  function tree_visitAfter$2(callback) {
    var halves = [], next = [], q2;
    if (this._root) halves.push(new Half(this._root, this._x0, this._x1));
    while (q2 = halves.pop()) {
      var node = q2.node;
      if (node.length) {
        var child, x0 = q2.x0, x1 = q2.x1, xm = (x0 + x1) / 2;
        if (child = node[0]) halves.push(new Half(child, x0, xm));
        if (child = node[1]) halves.push(new Half(child, xm, x1));
      }
      next.push(q2);
    }
    while (q2 = next.pop()) {
      callback(q2.node, q2.x0, q2.x1);
    }
    return this;
  }
  function defaultX$2(d2) {
    return d2[0];
  }
  function tree_x$2(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }
  function binarytree(nodes, x2) {
    var tree = new Binarytree(x2 == null ? defaultX$2 : x2, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Binarytree(x2, x0, x1) {
    this._x = x2;
    this._x0 = x0;
    this._x1 = x1;
    this._root = void 0;
  }
  function leaf_copy$2(leaf) {
    var copy2 = { data: leaf.data }, next = copy2;
    while (leaf = leaf.next) next = next.next = { data: leaf.data };
    return copy2;
  }
  var treeProto$2 = binarytree.prototype = Binarytree.prototype;
  treeProto$2.copy = function() {
    var copy2 = new Binarytree(this._x, this._x0, this._x1), node = this._root, nodes, child;
    if (!node) return copy2;
    if (!node.length) return copy2._root = leaf_copy$2(node), copy2;
    nodes = [{ source: node, target: copy2._root = new Array(2) }];
    while (node = nodes.pop()) {
      for (var i2 = 0; i2 < 2; ++i2) {
        if (child = node.source[i2]) {
          if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(2) });
          else node.target[i2] = leaf_copy$2(child);
        }
      }
    }
    return copy2;
  };
  treeProto$2.add = tree_add$2;
  treeProto$2.addAll = addAll$2;
  treeProto$2.cover = tree_cover$2;
  treeProto$2.data = tree_data$2;
  treeProto$2.extent = tree_extent$2;
  treeProto$2.find = tree_find$2;
  treeProto$2.remove = tree_remove$2;
  treeProto$2.removeAll = removeAll$2;
  treeProto$2.root = tree_root$2;
  treeProto$2.size = tree_size$2;
  treeProto$2.visit = tree_visit$2;
  treeProto$2.visitAfter = tree_visitAfter$2;
  treeProto$2.x = tree_x$2;
  function tree_add$1(d2) {
    const x2 = +this._x.call(null, d2), y2 = +this._y.call(null, d2);
    return add$1(this.cover(x2, y2), x2, y2, d2);
  }
  function add$1(tree, x2, y2, d2) {
    if (isNaN(x2) || isNaN(y2)) return tree;
    var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j2;
    if (!node) return tree._root = leaf, tree;
    while (node.length) {
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (parent = node, !(node = node[i2 = bottom << 1 | right])) return parent[i2] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x2 === xp && y2 === yp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
    } while ((i2 = bottom << 1 | right) === (j2 = (yp >= ym) << 1 | xp >= xm));
    return parent[j2] = node, parent[i2] = leaf, tree;
  }
  function addAll$1(data) {
    var d2, i2, n2 = data.length, x2, y2, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
    for (i2 = 0; i2 < n2; ++i2) {
      if (isNaN(x2 = +this._x.call(null, d2 = data[i2])) || isNaN(y2 = +this._y.call(null, d2))) continue;
      xz[i2] = x2;
      yz[i2] = y2;
      if (x2 < x0) x0 = x2;
      if (x2 > x1) x1 = x2;
      if (y2 < y0) y0 = y2;
      if (y2 > y1) y1 = y2;
    }
    if (x0 > x1 || y0 > y1) return this;
    this.cover(x0, y0).cover(x1, y1);
    for (i2 = 0; i2 < n2; ++i2) {
      add$1(this, xz[i2], yz[i2], data[i2]);
    }
    return this;
  }
  function tree_cover$1(x2, y2) {
    if (isNaN(x2 = +x2) || isNaN(y2 = +y2)) return this;
    var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x2)) + 1;
      y1 = (y0 = Math.floor(y2)) + 1;
    } else {
      var z2 = x1 - x0 || 1, node = this._root, parent, i2;
      while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1) {
        i2 = (y2 < y0) << 1 | x2 < x0;
        parent = new Array(4), parent[i2] = node, node = parent, z2 *= 2;
        switch (i2) {
          case 0:
            x1 = x0 + z2, y1 = y0 + z2;
            break;
          case 1:
            x0 = x1 - z2, y1 = y0 + z2;
            break;
          case 2:
            x1 = x0 + z2, y0 = y1 - z2;
            break;
          case 3:
            x0 = x1 - z2, y0 = y1 - z2;
            break;
        }
      }
      if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
  }
  function tree_data$1() {
    var data = [];
    this.visit(function(node) {
      if (!node.length) do
        data.push(node.data);
      while (node = node.next);
    });
    return data;
  }
  function tree_extent$1(_2) {
    return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }
  function Quad(node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
  }
  function tree_find$1(x2, y2, radius) {
    var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q2, i2;
    if (node) quads.push(new Quad(node, x0, y0, x3, y3));
    if (radius == null) radius = Infinity;
    else {
      x0 = x2 - radius, y0 = y2 - radius;
      x3 = x2 + radius, y3 = y2 + radius;
      radius *= radius;
    }
    while (q2 = quads.pop()) {
      if (!(node = q2.node) || (x1 = q2.x0) > x3 || (y1 = q2.y0) > y3 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0) continue;
      if (node.length) {
        var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
        quads.push(
          new Quad(node[3], xm, ym, x22, y22),
          new Quad(node[2], x1, ym, xm, y22),
          new Quad(node[1], xm, y1, x22, ym),
          new Quad(node[0], x1, y1, xm, ym)
        );
        if (i2 = (y2 >= ym) << 1 | x2 >= xm) {
          q2 = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i2];
          quads[quads.length - 1 - i2] = q2;
        }
      } else {
        var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d3 = Math.sqrt(radius = d2);
          x0 = x2 - d3, y0 = y2 - d3;
          x3 = x2 + d3, y3 = y2 + d3;
          data = node.data;
        }
      }
    }
    return data;
  }
  function tree_remove$1(d2) {
    if (isNaN(x2 = +this._x.call(null, d2)) || isNaN(y2 = +this._y.call(null, d2))) return this;
    var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x2, y2, xm, ym, right, bottom, i2, j2;
    if (!node) return this;
    if (node.length) while (true) {
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (!(parent = node, node = node[i2 = bottom << 1 | right])) return this;
      if (!node.length) break;
      if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3]) retainer = parent, j2 = i2;
    }
    while (node.data !== d2) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;
    if (previous) return next ? previous.next = next : delete previous.next, this;
    if (!parent) return this._root = next, this;
    next ? parent[i2] = next : delete parent[i2];
    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j2] = node;
      else this._root = node;
    }
    return this;
  }
  function removeAll$1(data) {
    for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
    return this;
  }
  function tree_root$1() {
    return this._root;
  }
  function tree_size$1() {
    var size = 0;
    this.visit(function(node) {
      if (!node.length) do
        ++size;
      while (node = node.next);
    });
    return size;
  }
  function tree_visit$1(callback) {
    var quads = [], q2, node = this._root, child, x0, y0, x1, y1;
    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
    while (q2 = quads.pop()) {
      if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      }
    }
    return this;
  }
  function tree_visitAfter$1(callback) {
    var quads = [], next = [], q2;
    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q2 = quads.pop()) {
      var node = q2.node;
      if (node.length) {
        var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      }
      next.push(q2);
    }
    while (q2 = next.pop()) {
      callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
    }
    return this;
  }
  function defaultX$1(d2) {
    return d2[0];
  }
  function tree_x$1(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }
  function defaultY$1(d2) {
    return d2[1];
  }
  function tree_y$1(_2) {
    return arguments.length ? (this._y = _2, this) : this._y;
  }
  function quadtree(nodes, x2, y2) {
    var tree = new Quadtree(x2 == null ? defaultX$1 : x2, y2 == null ? defaultY$1 : y2, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Quadtree(x2, y2, x0, y0, x1, y1) {
    this._x = x2;
    this._y = y2;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = void 0;
  }
  function leaf_copy$1(leaf) {
    var copy2 = { data: leaf.data }, next = copy2;
    while (leaf = leaf.next) next = next.next = { data: leaf.data };
    return copy2;
  }
  var treeProto$1 = quadtree.prototype = Quadtree.prototype;
  treeProto$1.copy = function() {
    var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
    if (!node) return copy2;
    if (!node.length) return copy2._root = leaf_copy$1(node), copy2;
    nodes = [{ source: node, target: copy2._root = new Array(4) }];
    while (node = nodes.pop()) {
      for (var i2 = 0; i2 < 4; ++i2) {
        if (child = node.source[i2]) {
          if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(4) });
          else node.target[i2] = leaf_copy$1(child);
        }
      }
    }
    return copy2;
  };
  treeProto$1.add = tree_add$1;
  treeProto$1.addAll = addAll$1;
  treeProto$1.cover = tree_cover$1;
  treeProto$1.data = tree_data$1;
  treeProto$1.extent = tree_extent$1;
  treeProto$1.find = tree_find$1;
  treeProto$1.remove = tree_remove$1;
  treeProto$1.removeAll = removeAll$1;
  treeProto$1.root = tree_root$1;
  treeProto$1.size = tree_size$1;
  treeProto$1.visit = tree_visit$1;
  treeProto$1.visitAfter = tree_visitAfter$1;
  treeProto$1.x = tree_x$1;
  treeProto$1.y = tree_y$1;
  function tree_add(d2) {
    const x2 = +this._x.call(null, d2), y2 = +this._y.call(null, d2), z2 = +this._z.call(null, d2);
    return add(this.cover(x2, y2, z2), x2, y2, z2, d2);
  }
  function add(tree, x2, y2, z2, d2) {
    if (isNaN(x2) || isNaN(y2) || isNaN(z2)) return tree;
    var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, z0 = tree._z0, x1 = tree._x1, y1 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, yp, zp, right, bottom, deep, i2, j2;
    if (!node) return tree._root = leaf, tree;
    while (node.length) {
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (deep = z2 >= (zm = (z0 + z1) / 2)) z0 = zm;
      else z1 = zm;
      if (parent = node, !(node = node[i2 = deep << 2 | bottom << 1 | right])) return parent[i2] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    zp = +tree._z.call(null, node.data);
    if (x2 === xp && y2 === yp && z2 === zp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i2] = new Array(8) : tree._root = new Array(8);
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (deep = z2 >= (zm = (z0 + z1) / 2)) z0 = zm;
      else z1 = zm;
    } while ((i2 = deep << 2 | bottom << 1 | right) === (j2 = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));
    return parent[j2] = node, parent[i2] = leaf, tree;
  }
  function addAll(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    const n2 = data.length;
    const xz = new Float64Array(n2);
    const yz = new Float64Array(n2);
    const zz = new Float64Array(n2);
    let x0 = Infinity, y0 = Infinity, z0 = Infinity, x1 = -Infinity, y1 = -Infinity, z1 = -Infinity;
    for (let i2 = 0, d2, x2, y2, z2; i2 < n2; ++i2) {
      if (isNaN(x2 = +this._x.call(null, d2 = data[i2])) || isNaN(y2 = +this._y.call(null, d2)) || isNaN(z2 = +this._z.call(null, d2))) continue;
      xz[i2] = x2;
      yz[i2] = y2;
      zz[i2] = z2;
      if (x2 < x0) x0 = x2;
      if (x2 > x1) x1 = x2;
      if (y2 < y0) y0 = y2;
      if (y2 > y1) y1 = y2;
      if (z2 < z0) z0 = z2;
      if (z2 > z1) z1 = z2;
    }
    if (x0 > x1 || y0 > y1 || z0 > z1) return this;
    this.cover(x0, y0, z0).cover(x1, y1, z1);
    for (let i2 = 0; i2 < n2; ++i2) {
      add(this, xz[i2], yz[i2], zz[i2], data[i2]);
    }
    return this;
  }
  function tree_cover(x2, y2, z2) {
    if (isNaN(x2 = +x2) || isNaN(y2 = +y2) || isNaN(z2 = +z2)) return this;
    var x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1;
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x2)) + 1;
      y1 = (y0 = Math.floor(y2)) + 1;
      z1 = (z0 = Math.floor(z2)) + 1;
    } else {
      var t2 = x1 - x0 || 1, node = this._root, parent, i2;
      while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1 || z0 > z2 || z2 >= z1) {
        i2 = (z2 < z0) << 2 | (y2 < y0) << 1 | x2 < x0;
        parent = new Array(8), parent[i2] = node, node = parent, t2 *= 2;
        switch (i2) {
          case 0:
            x1 = x0 + t2, y1 = y0 + t2, z1 = z0 + t2;
            break;
          case 1:
            x0 = x1 - t2, y1 = y0 + t2, z1 = z0 + t2;
            break;
          case 2:
            x1 = x0 + t2, y0 = y1 - t2, z1 = z0 + t2;
            break;
          case 3:
            x0 = x1 - t2, y0 = y1 - t2, z1 = z0 + t2;
            break;
          case 4:
            x1 = x0 + t2, y1 = y0 + t2, z0 = z1 - t2;
            break;
          case 5:
            x0 = x1 - t2, y1 = y0 + t2, z0 = z1 - t2;
            break;
          case 6:
            x1 = x0 + t2, y0 = y1 - t2, z0 = z1 - t2;
            break;
          case 7:
            x0 = x1 - t2, y0 = y1 - t2, z0 = z1 - t2;
            break;
        }
      }
      if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x0;
    this._y0 = y0;
    this._z0 = z0;
    this._x1 = x1;
    this._y1 = y1;
    this._z1 = z1;
    return this;
  }
  function tree_data() {
    var data = [];
    this.visit(function(node) {
      if (!node.length) do
        data.push(node.data);
      while (node = node.next);
    });
    return data;
  }
  function tree_extent(_2) {
    return arguments.length ? this.cover(+_2[0][0], +_2[0][1], +_2[0][2]).cover(+_2[1][0], +_2[1][1], +_2[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
  }
  function Octant(node, x0, y0, z0, x1, y1, z1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.z0 = z0;
    this.x1 = x1;
    this.y1 = y1;
    this.z1 = z1;
  }
  function tree_find(x2, y2, z2, radius) {
    var data, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1, y1, z1, x22, y22, z22, x3 = this._x1, y3 = this._y1, z3 = this._z1, octs = [], node = this._root, q2, i2;
    if (node) octs.push(new Octant(node, x0, y0, z0, x3, y3, z3));
    if (radius == null) radius = Infinity;
    else {
      x0 = x2 - radius, y0 = y2 - radius, z0 = z2 - radius;
      x3 = x2 + radius, y3 = y2 + radius, z3 = z2 + radius;
      radius *= radius;
    }
    while (q2 = octs.pop()) {
      if (!(node = q2.node) || (x1 = q2.x0) > x3 || (y1 = q2.y0) > y3 || (z1 = q2.z0) > z3 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0 || (z22 = q2.z1) < z0) continue;
      if (node.length) {
        var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2, zm = (z1 + z22) / 2;
        octs.push(
          new Octant(node[7], xm, ym, zm, x22, y22, z22),
          new Octant(node[6], x1, ym, zm, xm, y22, z22),
          new Octant(node[5], xm, y1, zm, x22, ym, z22),
          new Octant(node[4], x1, y1, zm, xm, ym, z22),
          new Octant(node[3], xm, ym, z1, x22, y22, zm),
          new Octant(node[2], x1, ym, z1, xm, y22, zm),
          new Octant(node[1], xm, y1, z1, x22, ym, zm),
          new Octant(node[0], x1, y1, z1, xm, ym, zm)
        );
        if (i2 = (z2 >= zm) << 2 | (y2 >= ym) << 1 | x2 >= xm) {
          q2 = octs[octs.length - 1];
          octs[octs.length - 1] = octs[octs.length - 1 - i2];
          octs[octs.length - 1 - i2] = q2;
        }
      } else {
        var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), dz = z2 - +this._z.call(null, node.data), d2 = dx * dx + dy * dy + dz * dz;
        if (d2 < radius) {
          var d3 = Math.sqrt(radius = d2);
          x0 = x2 - d3, y0 = y2 - d3, z0 = z2 - d3;
          x3 = x2 + d3, y3 = y2 + d3, z3 = z2 + d3;
          data = node.data;
        }
      }
    }
    return data;
  }
  const distance = (x1, y1, z1, x2, y2, z2) => Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2);
  function findAllWithinRadius(x2, y2, z2, radius) {
    const result = [];
    const xMin = x2 - radius;
    const yMin = y2 - radius;
    const zMin = z2 - radius;
    const xMax = x2 + radius;
    const yMax = y2 + radius;
    const zMax = z2 + radius;
    this.visit((node, x1, y1, z1, x22, y22, z22) => {
      if (!node.length) {
        do {
          const d2 = node.data;
          if (distance(x2, y2, z2, this._x(d2), this._y(d2), this._z(d2)) <= radius) {
            result.push(d2);
          }
        } while (node = node.next);
      }
      return x1 > xMax || y1 > yMax || z1 > zMax || x22 < xMin || y22 < yMin || z22 < zMin;
    });
    return result;
  }
  function tree_remove(d2) {
    if (isNaN(x2 = +this._x.call(null, d2)) || isNaN(y2 = +this._y.call(null, d2)) || isNaN(z2 = +this._z.call(null, d2))) return this;
    var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1, x2, y2, z2, xm, ym, zm, right, bottom, deep, i2, j2;
    if (!node) return this;
    if (node.length) while (true) {
      if (right = x2 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y2 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (deep = z2 >= (zm = (z0 + z1) / 2)) z0 = zm;
      else z1 = zm;
      if (!(parent = node, node = node[i2 = deep << 2 | bottom << 1 | right])) return this;
      if (!node.length) break;
      if (parent[i2 + 1 & 7] || parent[i2 + 2 & 7] || parent[i2 + 3 & 7] || parent[i2 + 4 & 7] || parent[i2 + 5 & 7] || parent[i2 + 6 & 7] || parent[i2 + 7 & 7]) retainer = parent, j2 = i2;
    }
    while (node.data !== d2) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;
    if (previous) return next ? previous.next = next : delete previous.next, this;
    if (!parent) return this._root = next, this;
    next ? parent[i2] = next : delete parent[i2];
    if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7]) && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j2] = node;
      else this._root = node;
    }
    return this;
  }
  function removeAll(data) {
    for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
    return this;
  }
  function tree_root() {
    return this._root;
  }
  function tree_size() {
    var size = 0;
    this.visit(function(node) {
      if (!node.length) do
        ++size;
      while (node = node.next);
    });
    return size;
  }
  function tree_visit(callback) {
    var octs = [], q2, node = this._root, child, x0, y0, z0, x1, y1, z1;
    if (node) octs.push(new Octant(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
    while (q2 = octs.pop()) {
      if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, z0 = q2.z0, x1 = q2.x1, y1 = q2.y1, z1 = q2.z1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
        if (child = node[7]) octs.push(new Octant(child, xm, ym, zm, x1, y1, z1));
        if (child = node[6]) octs.push(new Octant(child, x0, ym, zm, xm, y1, z1));
        if (child = node[5]) octs.push(new Octant(child, xm, y0, zm, x1, ym, z1));
        if (child = node[4]) octs.push(new Octant(child, x0, y0, zm, xm, ym, z1));
        if (child = node[3]) octs.push(new Octant(child, xm, ym, z0, x1, y1, zm));
        if (child = node[2]) octs.push(new Octant(child, x0, ym, z0, xm, y1, zm));
        if (child = node[1]) octs.push(new Octant(child, xm, y0, z0, x1, ym, zm));
        if (child = node[0]) octs.push(new Octant(child, x0, y0, z0, xm, ym, zm));
      }
    }
    return this;
  }
  function tree_visitAfter(callback) {
    var octs = [], next = [], q2;
    if (this._root) octs.push(new Octant(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
    while (q2 = octs.pop()) {
      var node = q2.node;
      if (node.length) {
        var child, x0 = q2.x0, y0 = q2.y0, z0 = q2.z0, x1 = q2.x1, y1 = q2.y1, z1 = q2.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
        if (child = node[0]) octs.push(new Octant(child, x0, y0, z0, xm, ym, zm));
        if (child = node[1]) octs.push(new Octant(child, xm, y0, z0, x1, ym, zm));
        if (child = node[2]) octs.push(new Octant(child, x0, ym, z0, xm, y1, zm));
        if (child = node[3]) octs.push(new Octant(child, xm, ym, z0, x1, y1, zm));
        if (child = node[4]) octs.push(new Octant(child, x0, y0, zm, xm, ym, z1));
        if (child = node[5]) octs.push(new Octant(child, xm, y0, zm, x1, ym, z1));
        if (child = node[6]) octs.push(new Octant(child, x0, ym, zm, xm, y1, z1));
        if (child = node[7]) octs.push(new Octant(child, xm, ym, zm, x1, y1, z1));
      }
      next.push(q2);
    }
    while (q2 = next.pop()) {
      callback(q2.node, q2.x0, q2.y0, q2.z0, q2.x1, q2.y1, q2.z1);
    }
    return this;
  }
  function defaultX(d2) {
    return d2[0];
  }
  function tree_x(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }
  function defaultY(d2) {
    return d2[1];
  }
  function tree_y(_2) {
    return arguments.length ? (this._y = _2, this) : this._y;
  }
  function defaultZ(d2) {
    return d2[2];
  }
  function tree_z(_2) {
    return arguments.length ? (this._z = _2, this) : this._z;
  }
  function octree(nodes, x2, y2, z2) {
    var tree = new Octree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, z2 == null ? defaultZ : z2, NaN, NaN, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Octree(x2, y2, z2, x0, y0, z0, x1, y1, z1) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._x0 = x0;
    this._y0 = y0;
    this._z0 = z0;
    this._x1 = x1;
    this._y1 = y1;
    this._z1 = z1;
    this._root = void 0;
  }
  function leaf_copy(leaf) {
    var copy2 = { data: leaf.data }, next = copy2;
    while (leaf = leaf.next) next = next.next = { data: leaf.data };
    return copy2;
  }
  var treeProto = octree.prototype = Octree.prototype;
  treeProto.copy = function() {
    var copy2 = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), node = this._root, nodes, child;
    if (!node) return copy2;
    if (!node.length) return copy2._root = leaf_copy(node), copy2;
    nodes = [{ source: node, target: copy2._root = new Array(8) }];
    while (node = nodes.pop()) {
      for (var i2 = 0; i2 < 8; ++i2) {
        if (child = node.source[i2]) {
          if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(8) });
          else node.target[i2] = leaf_copy(child);
        }
      }
    }
    return copy2;
  };
  treeProto.add = tree_add;
  treeProto.addAll = addAll;
  treeProto.cover = tree_cover;
  treeProto.data = tree_data;
  treeProto.extent = tree_extent;
  treeProto.find = tree_find;
  treeProto.findAllWithinRadius = findAllWithinRadius;
  treeProto.remove = tree_remove;
  treeProto.removeAll = removeAll;
  treeProto.root = tree_root;
  treeProto.size = tree_size;
  treeProto.visit = tree_visit;
  treeProto.visitAfter = tree_visitAfter;
  treeProto.x = tree_x;
  treeProto.y = tree_y;
  treeProto.z = tree_z;
  function constant(x2) {
    return function() {
      return x2;
    };
  }
  function jiggle(random) {
    return (random() - 0.5) * 1e-6;
  }
  function index$1(d2) {
    return d2.index;
  }
  function find(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("node not found: " + nodeId);
    return node;
  }
  function forceLink(links) {
    var id2 = index$1, strength = defaultStrength, strengths, distance2 = constant(30), distances, nodes, nDim, count, bias, random, iterations = 1;
    if (links == null) links = [];
    function defaultStrength(link) {
      return 1 / Math.min(count[link.source.index], count[link.target.index]);
    }
    function force(alpha) {
      for (var k2 = 0, n2 = links.length; k2 < iterations; ++k2) {
        for (var i2 = 0, link, source, target, x2 = 0, y2 = 0, z2 = 0, l2, b; i2 < n2; ++i2) {
          link = links[i2], source = link.source, target = link.target;
          x2 = target.x + target.vx - source.x - source.vx || jiggle(random);
          if (nDim > 1) {
            y2 = target.y + target.vy - source.y - source.vy || jiggle(random);
          }
          if (nDim > 2) {
            z2 = target.z + target.vz - source.z - source.vz || jiggle(random);
          }
          l2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
          l2 = (l2 - distances[i2]) / l2 * alpha * strengths[i2];
          x2 *= l2, y2 *= l2, z2 *= l2;
          target.vx -= x2 * (b = bias[i2]);
          if (nDim > 1) {
            target.vy -= y2 * b;
          }
          if (nDim > 2) {
            target.vz -= z2 * b;
          }
          source.vx += x2 * (b = 1 - b);
          if (nDim > 1) {
            source.vy += y2 * b;
          }
          if (nDim > 2) {
            source.vz += z2 * b;
          }
        }
      }
    }
    function initialize() {
      if (!nodes) return;
      var i2, n2 = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d2, i3) => [id2(d2, i3, nodes), d2])), link;
      for (i2 = 0, count = new Array(n2); i2 < m2; ++i2) {
        link = links[i2], link.index = i2;
        if (typeof link.source !== "object") link.source = find(nodeById, link.source);
        if (typeof link.target !== "object") link.target = find(nodeById, link.target);
        count[link.source.index] = (count[link.source.index] || 0) + 1;
        count[link.target.index] = (count[link.target.index] || 0) + 1;
      }
      for (i2 = 0, bias = new Array(m2); i2 < m2; ++i2) {
        link = links[i2], bias[i2] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
      }
      strengths = new Array(m2), initializeStrength();
      distances = new Array(m2), initializeDistance();
    }
    function initializeStrength() {
      if (!nodes) return;
      for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
        strengths[i2] = +strength(links[i2], i2, links);
      }
    }
    function initializeDistance() {
      if (!nodes) return;
      for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
        distances[i2] = +distance2(links[i2], i2, links);
      }
    }
    force.initialize = function(_nodes, ...args) {
      nodes = _nodes;
      random = args.find((arg) => typeof arg === "function") || Math.random;
      nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
      initialize();
    };
    force.links = function(_2) {
      return arguments.length ? (links = _2, initialize(), force) : links;
    };
    force.id = function(_2) {
      return arguments.length ? (id2 = _2, force) : id2;
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations = +_2, force) : iterations;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initializeStrength(), force) : strength;
    };
    force.distance = function(_2) {
      return arguments.length ? (distance2 = typeof _2 === "function" ? _2 : constant(+_2), initializeDistance(), force) : distance2;
    };
    return force;
  }
  const a = 1664525;
  const c = 1013904223;
  const m = 4294967296;
  function lcg() {
    let s2 = 1;
    return () => (s2 = (a * s2 + c) % m) / m;
  }
  var MAX_DIMENSIONS = 3;
  function x(d2) {
    return d2.x;
  }
  function y(d2) {
    return d2.y;
  }
  function z(d2) {
    return d2.z;
  }
  var initialRadius = 10, initialAngleRoll = Math.PI * (3 - Math.sqrt(5)), initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221));
  function forceSimulation(nodes, numDimensions) {
    numDimensions = numDimensions || 2;
    var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))), simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch("tick", "end"), random = lcg();
    if (nodes == null) nodes = [];
    function step() {
      tick();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }
    function tick(iterations) {
      var i2, n2 = nodes.length, node;
      if (iterations === void 0) iterations = 1;
      for (var k2 = 0; k2 < iterations; ++k2) {
        alpha += (alphaTarget - alpha) * alphaDecay;
        forces.forEach(function(force) {
          force(alpha);
        });
        for (i2 = 0; i2 < n2; ++i2) {
          node = nodes[i2];
          if (node.fx == null) node.x += node.vx *= velocityDecay;
          else node.x = node.fx, node.vx = 0;
          if (nDim > 1) {
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
          if (nDim > 2) {
            if (node.fz == null) node.z += node.vz *= velocityDecay;
            else node.z = node.fz, node.vz = 0;
          }
        }
      }
      return simulation;
    }
    function initializeNodes() {
      for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
        node = nodes[i2], node.index = i2;
        if (node.fx != null) node.x = node.fx;
        if (node.fy != null) node.y = node.fy;
        if (node.fz != null) node.z = node.fz;
        if (isNaN(node.x) || nDim > 1 && isNaN(node.y) || nDim > 2 && isNaN(node.z)) {
          var radius = initialRadius * (nDim > 2 ? Math.cbrt(0.5 + i2) : nDim > 1 ? Math.sqrt(0.5 + i2) : i2), rollAngle = i2 * initialAngleRoll, yawAngle = i2 * initialAngleYaw;
          if (nDim === 1) {
            node.x = radius;
          } else if (nDim === 2) {
            node.x = radius * Math.cos(rollAngle);
            node.y = radius * Math.sin(rollAngle);
          } else {
            node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);
            node.y = radius * Math.cos(rollAngle);
            node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);
          }
        }
        if (isNaN(node.vx) || nDim > 1 && isNaN(node.vy) || nDim > 2 && isNaN(node.vz)) {
          node.vx = 0;
          if (nDim > 1) {
            node.vy = 0;
          }
          if (nDim > 2) {
            node.vz = 0;
          }
        }
      }
    }
    function initializeForce(force) {
      if (force.initialize) force.initialize(nodes, random, nDim);
      return force;
    }
    initializeNodes();
    return simulation = {
      tick,
      restart: function() {
        return stepper.restart(step), simulation;
      },
      stop: function() {
        return stepper.stop(), simulation;
      },
      numDimensions: function(_2) {
        return arguments.length ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_2))), forces.forEach(initializeForce), simulation) : nDim;
      },
      nodes: function(_2) {
        return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
      },
      alpha: function(_2) {
        return arguments.length ? (alpha = +_2, simulation) : alpha;
      },
      alphaMin: function(_2) {
        return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
      },
      alphaDecay: function(_2) {
        return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
      },
      alphaTarget: function(_2) {
        return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
      },
      velocityDecay: function(_2) {
        return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
      },
      randomSource: function(_2) {
        return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
      },
      force: function(name, _2) {
        return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
      },
      find: function() {
        var args = Array.prototype.slice.call(arguments);
        var x2 = args.shift() || 0, y2 = (nDim > 1 ? args.shift() : null) || 0, z2 = (nDim > 2 ? args.shift() : null) || 0, radius = args.shift() || Infinity;
        var i2 = 0, n2 = nodes.length, dx, dy, dz, d2, node, closest;
        radius *= radius;
        for (i2 = 0; i2 < n2; ++i2) {
          node = nodes[i2];
          dx = x2 - node.x;
          dy = y2 - (node.y || 0);
          dz = z2 - (node.z || 0);
          d2 = dx * dx + dy * dy + dz * dz;
          if (d2 < radius) closest = node, radius = d2;
        }
        return closest;
      },
      on: function(name, _2) {
        return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
      }
    };
  }
  function forceManyBody() {
    var nodes, nDim, node, random, alpha, strength = constant(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
    function force(_2) {
      var i2, n2 = nodes.length, tree = (nDim === 1 ? binarytree(nodes, x) : nDim === 2 ? quadtree(nodes, x, y) : nDim === 3 ? octree(nodes, x, y, z) : null).visitAfter(accumulate);
      for (alpha = _2, i2 = 0; i2 < n2; ++i2) node = nodes[i2], tree.visit(apply);
    }
    function initialize() {
      if (!nodes) return;
      var i2, n2 = nodes.length, node2;
      strengths = new Array(n2);
      for (i2 = 0; i2 < n2; ++i2) node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
    }
    function accumulate(treeNode) {
      var strength2 = 0, q2, c2, weight = 0, x2, y2, z2, i2;
      var numChildren = treeNode.length;
      if (numChildren) {
        for (x2 = y2 = z2 = i2 = 0; i2 < numChildren; ++i2) {
          if ((q2 = treeNode[i2]) && (c2 = Math.abs(q2.value))) {
            strength2 += q2.value, weight += c2, x2 += c2 * (q2.x || 0), y2 += c2 * (q2.y || 0), z2 += c2 * (q2.z || 0);
          }
        }
        strength2 *= Math.sqrt(4 / numChildren);
        treeNode.x = x2 / weight;
        if (nDim > 1) {
          treeNode.y = y2 / weight;
        }
        if (nDim > 2) {
          treeNode.z = z2 / weight;
        }
      } else {
        q2 = treeNode;
        q2.x = q2.data.x;
        if (nDim > 1) {
          q2.y = q2.data.y;
        }
        if (nDim > 2) {
          q2.z = q2.data.z;
        }
        do
          strength2 += strengths[q2.data.index];
        while (q2 = q2.next);
      }
      treeNode.value = strength2;
    }
    function apply(treeNode, x1, arg1, arg2, arg3) {
      if (!treeNode.value) return true;
      var x2 = [arg1, arg2, arg3][nDim - 1];
      var x3 = treeNode.x - node.x, y2 = nDim > 1 ? treeNode.y - node.y : 0, z2 = nDim > 2 ? treeNode.z - node.z : 0, w2 = x2 - x1, l2 = x3 * x3 + y2 * y2 + z2 * z2;
      if (w2 * w2 / theta2 < l2) {
        if (l2 < distanceMax2) {
          if (x3 === 0) x3 = jiggle(random), l2 += x3 * x3;
          if (nDim > 1 && y2 === 0) y2 = jiggle(random), l2 += y2 * y2;
          if (nDim > 2 && z2 === 0) z2 = jiggle(random), l2 += z2 * z2;
          if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
          node.vx += x3 * treeNode.value * alpha / l2;
          if (nDim > 1) {
            node.vy += y2 * treeNode.value * alpha / l2;
          }
          if (nDim > 2) {
            node.vz += z2 * treeNode.value * alpha / l2;
          }
        }
        return true;
      } else if (treeNode.length || l2 >= distanceMax2) return;
      if (treeNode.data !== node || treeNode.next) {
        if (x3 === 0) x3 = jiggle(random), l2 += x3 * x3;
        if (nDim > 1 && y2 === 0) y2 = jiggle(random), l2 += y2 * y2;
        if (nDim > 2 && z2 === 0) z2 = jiggle(random), l2 += z2 * z2;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
      }
      do
        if (treeNode.data !== node) {
          w2 = strengths[treeNode.data.index] * alpha / l2;
          node.vx += x3 * w2;
          if (nDim > 1) {
            node.vy += y2 * w2;
          }
          if (nDim > 2) {
            node.vz += z2 * w2;
          }
        }
      while (treeNode = treeNode.next);
    }
    force.initialize = function(_nodes, ...args) {
      nodes = _nodes;
      random = args.find((arg) => typeof arg === "function") || Math.random;
      nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : strength;
    };
    force.distanceMin = function(_2) {
      return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_2) {
      return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_2) {
      return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
    };
    return force;
  }
  function forceRadial(radius, x2, y2, z2) {
    var nodes, nDim, strength = constant(0.1), strengths, radiuses;
    if (typeof radius !== "function") radius = constant(+radius);
    if (x2 == null) x2 = 0;
    if (y2 == null) y2 = 0;
    if (z2 == null) z2 = 0;
    function force(alpha) {
      for (var i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
        var node = nodes[i2], dx = node.x - x2 || 1e-6, dy = (node.y || 0) - y2 || 1e-6, dz = (node.z || 0) - z2 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy + dz * dz), k2 = (radiuses[i2] - r2) * strengths[i2] * alpha / r2;
        node.vx += dx * k2;
        if (nDim > 1) {
          node.vy += dy * k2;
        }
        if (nDim > 2) {
          node.vz += dz * k2;
        }
      }
    }
    function initialize() {
      if (!nodes) return;
      var i2, n2 = nodes.length;
      strengths = new Array(n2);
      radiuses = new Array(n2);
      for (i2 = 0; i2 < n2; ++i2) {
        radiuses[i2] = +radius(nodes[i2], i2, nodes);
        strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
      }
    }
    force.initialize = function(initNodes, ...args) {
      nodes = initNodes;
      nDim = args.find((arg) => [1, 2, 3].includes(arg)) || 2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : strength;
    };
    force.radius = function(_2) {
      return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant(+_2), initialize(), force) : radius;
    };
    force.x = function(_2) {
      return arguments.length ? (x2 = +_2, force) : x2;
    };
    force.y = function(_2) {
      return arguments.length ? (y2 = +_2, force) : y2;
    };
    force.z = function(_2) {
      return arguments.length ? (z2 = +_2, force) : z2;
    };
    return force;
  }
  const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
  function crt(v2) {
    return v2 < 0 ? -pow(-v2, 1 / 3) : pow(v2, 1 / 3);
  }
  const pi$1 = Math.PI, tau = 2 * pi$1, quart = pi$1 / 2, epsilon = 1e-6, nMax = Number.MAX_SAFE_INTEGER || 9007199254740991, nMin = Number.MIN_SAFE_INTEGER || -9007199254740991, ZERO = { x: 0, y: 0, z: 0 };
  const utils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.06405689286260563,
      0.06405689286260563,
      -0.1911188674736163,
      0.1911188674736163,
      -0.3150426796961634,
      0.3150426796961634,
      -0.4337935076260451,
      0.4337935076260451,
      -0.5454214713888396,
      0.5454214713888396,
      -0.6480936519369755,
      0.6480936519369755,
      -0.7401241915785544,
      0.7401241915785544,
      -0.820001985973903,
      0.820001985973903,
      -0.8864155270044011,
      0.8864155270044011,
      -0.9382745520027328,
      0.9382745520027328,
      -0.9747285559713095,
      0.9747285559713095,
      -0.9951872199970213,
      0.9951872199970213
    ],
    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.12793819534675216,
      0.12793819534675216,
      0.1258374563468283,
      0.1258374563468283,
      0.12167047292780339,
      0.12167047292780339,
      0.1155056680537256,
      0.1155056680537256,
      0.10744427011596563,
      0.10744427011596563,
      0.09761865210411388,
      0.09761865210411388,
      0.08619016153195327,
      0.08619016153195327,
      0.0733464814110803,
      0.0733464814110803,
      0.05929858491543678,
      0.05929858491543678,
      0.04427743881741981,
      0.04427743881741981,
      0.028531388628933663,
      0.028531388628933663,
      0.0123412297999872,
      0.0123412297999872
    ],
    arcfn: function(t2, derivativeFn) {
      const d2 = derivativeFn(t2);
      let l2 = d2.x * d2.x + d2.y * d2.y;
      if (typeof d2.z !== "undefined") {
        l2 += d2.z * d2.z;
      }
      return sqrt$1(l2);
    },
    compute: function(t2, points, _3d) {
      if (t2 === 0) {
        points[0].t = 0;
        return points[0];
      }
      const order = points.length - 1;
      if (t2 === 1) {
        points[order].t = 1;
        return points[order];
      }
      const mt = 1 - t2;
      let p2 = points;
      if (order === 0) {
        points[0].t = t2;
        return points[0];
      }
      if (order === 1) {
        const ret = {
          x: mt * p2[0].x + t2 * p2[1].x,
          y: mt * p2[0].y + t2 * p2[1].y,
          t: t2
        };
        if (_3d) {
          ret.z = mt * p2[0].z + t2 * p2[1].z;
        }
        return ret;
      }
      if (order < 4) {
        let mt2 = mt * mt, t22 = t2 * t2, a2, b, c2, d2 = 0;
        if (order === 2) {
          p2 = [p2[0], p2[1], p2[2], ZERO];
          a2 = mt2;
          b = mt * t2 * 2;
          c2 = t22;
        } else if (order === 3) {
          a2 = mt2 * mt;
          b = mt2 * t2 * 3;
          c2 = mt * t22 * 3;
          d2 = t2 * t22;
        }
        const ret = {
          x: a2 * p2[0].x + b * p2[1].x + c2 * p2[2].x + d2 * p2[3].x,
          y: a2 * p2[0].y + b * p2[1].y + c2 * p2[2].y + d2 * p2[3].y,
          t: t2
        };
        if (_3d) {
          ret.z = a2 * p2[0].z + b * p2[1].z + c2 * p2[2].z + d2 * p2[3].z;
        }
        return ret;
      }
      const dCpts = JSON.parse(JSON.stringify(points));
      while (dCpts.length > 1) {
        for (let i2 = 0; i2 < dCpts.length - 1; i2++) {
          dCpts[i2] = {
            x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t2,
            y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t2
          };
          if (typeof dCpts[i2].z !== "undefined") {
            dCpts[i2].z = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t2;
          }
        }
        dCpts.splice(dCpts.length - 1, 1);
      }
      dCpts[0].t = t2;
      return dCpts[0];
    },
    computeWithRatios: function(t2, points, ratios, _3d) {
      const mt = 1 - t2, r2 = ratios, p2 = points;
      let f1 = r2[0], f2 = r2[1], f3 = r2[2], f4 = r2[3], d2;
      f1 *= mt;
      f2 *= t2;
      if (p2.length === 2) {
        d2 = f1 + f2;
        return {
          x: (f1 * p2[0].x + f2 * p2[1].x) / d2,
          y: (f1 * p2[0].y + f2 * p2[1].y) / d2,
          z: !_3d ? false : (f1 * p2[0].z + f2 * p2[1].z) / d2,
          t: t2
        };
      }
      f1 *= mt;
      f2 *= 2 * mt;
      f3 *= t2 * t2;
      if (p2.length === 3) {
        d2 = f1 + f2 + f3;
        return {
          x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x) / d2,
          y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y) / d2,
          z: !_3d ? false : (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z) / d2,
          t: t2
        };
      }
      f1 *= mt;
      f2 *= 1.5 * mt;
      f3 *= 3 * mt;
      f4 *= t2 * t2 * t2;
      if (p2.length === 4) {
        d2 = f1 + f2 + f3 + f4;
        return {
          x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x + f4 * p2[3].x) / d2,
          y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y + f4 * p2[3].y) / d2,
          z: !_3d ? false : (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z + f4 * p2[3].z) / d2,
          t: t2
        };
      }
    },
    derive: function(points, _3d) {
      const dpoints = [];
      for (let p2 = points, d2 = p2.length, c2 = d2 - 1; d2 > 1; d2--, c2--) {
        const list = [];
        for (let j2 = 0, dpt; j2 < c2; j2++) {
          dpt = {
            x: c2 * (p2[j2 + 1].x - p2[j2].x),
            y: c2 * (p2[j2 + 1].y - p2[j2].y)
          };
          if (_3d) {
            dpt.z = c2 * (p2[j2 + 1].z - p2[j2].z);
          }
          list.push(dpt);
        }
        dpoints.push(list);
        p2 = list;
      }
      return dpoints;
    },
    between: function(v2, m2, M2) {
      return m2 <= v2 && v2 <= M2 || utils.approximately(v2, m2) || utils.approximately(v2, M2);
    },
    approximately: function(a2, b, precision) {
      return abs$1(a2 - b) <= (precision || epsilon);
    },
    length: function(derivativeFn) {
      const z2 = 0.5, len = utils.Tvalues.length;
      let sum2 = 0;
      for (let i2 = 0, t2; i2 < len; i2++) {
        t2 = z2 * utils.Tvalues[i2] + z2;
        sum2 += utils.Cvalues[i2] * utils.arcfn(t2, derivativeFn);
      }
      return z2 * sum2;
    },
    map: function(v2, ds, de, ts, te) {
      const d1 = de - ds, d2 = te - ts, v22 = v2 - ds, r2 = v22 / d1;
      return ts + d2 * r2;
    },
    lerp: function(r2, v1, v2) {
      const ret = {
        x: v1.x + r2 * (v2.x - v1.x),
        y: v1.y + r2 * (v2.y - v1.y)
      };
      if (v1.z !== void 0 && v2.z !== void 0) {
        ret.z = v1.z + r2 * (v2.z - v1.z);
      }
      return ret;
    },
    pointToString: function(p2) {
      let s2 = p2.x + "/" + p2.y;
      if (typeof p2.z !== "undefined") {
        s2 += "/" + p2.z;
      }
      return s2;
    },
    pointsToString: function(points) {
      return "[" + points.map(utils.pointToString).join(", ") + "]";
    },
    copy: function(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    angle: function(o2, v1, v2) {
      const dx1 = v1.x - o2.x, dy1 = v1.y - o2.y, dx2 = v2.x - o2.x, dy2 = v2.y - o2.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
      return atan2(cross, dot);
    },
    // round as string, to avoid rounding errors
    round: function(v2, d2) {
      const s2 = "" + v2;
      const pos = s2.indexOf(".");
      return parseFloat(s2.substring(0, pos + 1 + d2));
    },
    dist: function(p1, p2) {
      const dx = p1.x - p2.x, dy = p1.y - p2.y;
      return sqrt$1(dx * dx + dy * dy);
    },
    closest: function(LUT, point) {
      let mdist = pow(2, 63), mpos, d2;
      LUT.forEach(function(p2, idx) {
        d2 = utils.dist(point, p2);
        if (d2 < mdist) {
          mdist = d2;
          mpos = idx;
        }
      });
      return { mdist, mpos };
    },
    abcratio: function(t2, n2) {
      if (n2 !== 2 && n2 !== 3) {
        return false;
      }
      if (typeof t2 === "undefined") {
        t2 = 0.5;
      } else if (t2 === 0 || t2 === 1) {
        return t2;
      }
      const bottom = pow(t2, n2) + pow(1 - t2, n2), top = bottom - 1;
      return abs$1(top / bottom);
    },
    projectionratio: function(t2, n2) {
      if (n2 !== 2 && n2 !== 3) {
        return false;
      }
      if (typeof t2 === "undefined") {
        t2 = 0.5;
      } else if (t2 === 0 || t2 === 1) {
        return t2;
      }
      const top = pow(1 - t2, n2), bottom = pow(t2, n2) + top;
      return top / bottom;
    },
    lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
      const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d2 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (d2 == 0) {
        return false;
      }
      return { x: nx / d2, y: ny / d2 };
    },
    lli4: function(p1, p2, p3, p4) {
      const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
      return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
    },
    lli: function(v1, v2) {
      return utils.lli4(v1, v1.c, v2, v2.c);
    },
    makeline: function(p1, p2) {
      return new Bezier(
        p1.x,
        p1.y,
        (p1.x + p2.x) / 2,
        (p1.y + p2.y) / 2,
        p2.x,
        p2.y
      );
    },
    findbbox: function(sections) {
      let mx = nMax, my = nMax, MX = nMin, MY = nMin;
      sections.forEach(function(s2) {
        const bbox = s2.bbox();
        if (mx > bbox.x.min) mx = bbox.x.min;
        if (my > bbox.y.min) my = bbox.y.min;
        if (MX < bbox.x.max) MX = bbox.x.max;
        if (MY < bbox.y.max) MY = bbox.y.max;
      });
      return {
        x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
        y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
      };
    },
    shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
      if (!utils.bboxoverlap(bbox1, bbox2)) return [];
      const intersections = [];
      const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
      const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
      a1.forEach(function(l1) {
        if (l1.virtual) return;
        a2.forEach(function(l2) {
          if (l2.virtual) return;
          const iss = l1.intersects(l2, curveIntersectionThreshold);
          if (iss.length > 0) {
            iss.c1 = l1;
            iss.c2 = l2;
            iss.s1 = s1;
            iss.s2 = s2;
            intersections.push(iss);
          }
        });
      });
      return intersections;
    },
    makeshape: function(forward, back, curveIntersectionThreshold) {
      const bpl = back.points.length;
      const fpl = forward.points.length;
      const start2 = utils.makeline(back.points[bpl - 1], forward.points[0]);
      const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
      const shape = {
        startcap: start2,
        forward,
        back,
        endcap: end,
        bbox: utils.findbbox([start2, forward, back, end])
      };
      shape.intersections = function(s2) {
        return utils.shapeintersections(
          shape,
          shape.bbox,
          s2,
          s2.bbox,
          curveIntersectionThreshold
        );
      };
      return shape;
    },
    getminmax: function(curve, d2, list) {
      if (!list) return { min: 0, max: 0 };
      let min2 = nMax, max2 = nMin, t2, c2;
      if (list.indexOf(0) === -1) {
        list = [0].concat(list);
      }
      if (list.indexOf(1) === -1) {
        list.push(1);
      }
      for (let i2 = 0, len = list.length; i2 < len; i2++) {
        t2 = list[i2];
        c2 = curve.get(t2);
        if (c2[d2] < min2) {
          min2 = c2[d2];
        }
        if (c2[d2] > max2) {
          max2 = c2[d2];
        }
      }
      return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
    },
    align: function(points, line) {
      const tx = line.p1.x, ty = line.p1.y, a2 = -atan2(line.p2.y - ty, line.p2.x - tx), d2 = function(v2) {
        return {
          x: (v2.x - tx) * cos$1(a2) - (v2.y - ty) * sin$1(a2),
          y: (v2.x - tx) * sin$1(a2) + (v2.y - ty) * cos$1(a2)
        };
      };
      return points.map(d2);
    },
    roots: function(points, line) {
      line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
      const order = points.length - 1;
      const aligned = utils.align(points, line);
      const reduce = function(t2) {
        return 0 <= t2 && t2 <= 1;
      };
      if (order === 2) {
        const a3 = aligned[0].y, b2 = aligned[1].y, c3 = aligned[2].y, d3 = a3 - 2 * b2 + c3;
        if (d3 !== 0) {
          const m1 = -sqrt$1(b2 * b2 - a3 * c3), m2 = -a3 + b2, v12 = -(m1 + m2) / d3, v2 = -(-m1 + m2) / d3;
          return [v12, v2].filter(reduce);
        } else if (b2 !== c3 && d3 === 0) {
          return [(2 * b2 - c3) / (2 * b2 - 2 * c3)].filter(reduce);
        }
        return [];
      }
      const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
      let d2 = -pa + 3 * pb - 3 * pc + pd, a2 = 3 * pa - 6 * pb + 3 * pc, b = -3 * pa + 3 * pb, c2 = pa;
      if (utils.approximately(d2, 0)) {
        if (utils.approximately(a2, 0)) {
          if (utils.approximately(b, 0)) {
            return [];
          }
          return [-c2 / b].filter(reduce);
        }
        const q3 = sqrt$1(b * b - 4 * a2 * c2), a22 = 2 * a2;
        return [(q3 - b) / a22, (-b - q3) / a22].filter(reduce);
      }
      a2 /= d2;
      b /= d2;
      c2 /= d2;
      const p2 = (3 * b - a2 * a2) / 3, p3 = p2 / 3, q2 = (2 * a2 * a2 * a2 - 9 * a2 * b + 27 * c2) / 27, q22 = q2 / 2, discriminant = q22 * q22 + p3 * p3 * p3;
      let u1, v1, x1, x2, x3;
      if (discriminant < 0) {
        const mp3 = -p2 / 3, mp33 = mp3 * mp3 * mp3, r2 = sqrt$1(mp33), t2 = -q2 / (2 * r2), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos$1(cosphi), crtr = crt(r2), t1 = 2 * crtr;
        x1 = t1 * cos$1(phi / 3) - a2 / 3;
        x2 = t1 * cos$1((phi + tau) / 3) - a2 / 3;
        x3 = t1 * cos$1((phi + 2 * tau) / 3) - a2 / 3;
        return [x1, x2, x3].filter(reduce);
      } else if (discriminant === 0) {
        u1 = q22 < 0 ? crt(-q22) : -crt(q22);
        x1 = 2 * u1 - a2 / 3;
        x2 = -u1 - a2 / 3;
        return [x1, x2].filter(reduce);
      } else {
        const sd = sqrt$1(discriminant);
        u1 = crt(-q22 + sd);
        v1 = crt(q22 + sd);
        return [u1 - v1 - a2 / 3].filter(reduce);
      }
    },
    droots: function(p2) {
      if (p2.length === 3) {
        const a2 = p2[0], b = p2[1], c2 = p2[2], d2 = a2 - 2 * b + c2;
        if (d2 !== 0) {
          const m1 = -sqrt$1(b * b - a2 * c2), m2 = -a2 + b, v1 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
          return [v1, v2];
        } else if (b !== c2 && d2 === 0) {
          return [(2 * b - c2) / (2 * (b - c2))];
        }
        return [];
      }
      if (p2.length === 2) {
        const a2 = p2[0], b = p2[1];
        if (a2 !== b) {
          return [a2 / (a2 - b)];
        }
        return [];
      }
      return [];
    },
    curvature: function(t2, d1, d2, _3d, kOnly) {
      let num, dnm, adk, dk, k2 = 0, r2 = 0;
      const d3 = utils.compute(t2, d1);
      const dd = utils.compute(t2, d2);
      const qdsum = d3.x * d3.x + d3.y * d3.y;
      if (_3d) {
        num = sqrt$1(
          pow(d3.y * dd.z - dd.y * d3.z, 2) + pow(d3.z * dd.x - dd.z * d3.x, 2) + pow(d3.x * dd.y - dd.x * d3.y, 2)
        );
        dnm = pow(qdsum + d3.z * d3.z, 3 / 2);
      } else {
        num = d3.x * dd.y - d3.y * dd.x;
        dnm = pow(qdsum, 3 / 2);
      }
      if (num === 0 || dnm === 0) {
        return { k: 0, r: 0 };
      }
      k2 = num / dnm;
      r2 = dnm / num;
      if (!kOnly) {
        const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, true).k;
        const nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, true).k;
        dk = (nk - k2 + (k2 - pk)) / 2;
        adk = (abs$1(nk - k2) + abs$1(k2 - pk)) / 2;
      }
      return { k: k2, r: r2, dk, adk };
    },
    inflections: function(points) {
      if (points.length < 4) return [];
      const p2 = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a2 = p2[2].x * p2[1].y, b = p2[3].x * p2[1].y, c2 = p2[1].x * p2[2].y, d2 = p2[3].x * p2[2].y, v1 = 18 * (-3 * a2 + 2 * b + 3 * c2 - d2), v2 = 18 * (3 * a2 - b - 3 * c2), v3 = 18 * (c2 - a2);
      if (utils.approximately(v1, 0)) {
        if (!utils.approximately(v2, 0)) {
          let t2 = -v3 / v2;
          if (0 <= t2 && t2 <= 1) return [t2];
        }
        return [];
      }
      const d22 = 2 * v1;
      if (utils.approximately(d22, 0)) return [];
      const trm = v2 * v2 - 4 * v1 * v3;
      if (trm < 0) return [];
      const sq = Math.sqrt(trm);
      return [(sq - v2) / d22, -(v2 + sq) / d22].filter(function(r2) {
        return 0 <= r2 && r2 <= 1;
      });
    },
    bboxoverlap: function(b1, b2) {
      const dims = ["x", "y"], len = dims.length;
      for (let i2 = 0, dim, l2, t2, d2; i2 < len; i2++) {
        dim = dims[i2];
        l2 = b1[dim].mid;
        t2 = b2[dim].mid;
        d2 = (b1[dim].size + b2[dim].size) / 2;
        if (abs$1(l2 - t2) >= d2) return false;
      }
      return true;
    },
    expandbox: function(bbox, _bbox) {
      if (_bbox.x.min < bbox.x.min) {
        bbox.x.min = _bbox.x.min;
      }
      if (_bbox.y.min < bbox.y.min) {
        bbox.y.min = _bbox.y.min;
      }
      if (_bbox.z && _bbox.z.min < bbox.z.min) {
        bbox.z.min = _bbox.z.min;
      }
      if (_bbox.x.max > bbox.x.max) {
        bbox.x.max = _bbox.x.max;
      }
      if (_bbox.y.max > bbox.y.max) {
        bbox.y.max = _bbox.y.max;
      }
      if (_bbox.z && _bbox.z.max > bbox.z.max) {
        bbox.z.max = _bbox.z.max;
      }
      bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
      bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
      if (bbox.z) {
        bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
      }
      bbox.x.size = bbox.x.max - bbox.x.min;
      bbox.y.size = bbox.y.max - bbox.y.min;
      if (bbox.z) {
        bbox.z.size = bbox.z.max - bbox.z.min;
      }
    },
    pairiteration: function(c1, c2, curveIntersectionThreshold) {
      const c1b = c1.bbox(), c2b = c2.bbox(), r2 = 1e5, threshold = curveIntersectionThreshold || 0.5;
      if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
        return [
          (r2 * (c1._t1 + c1._t2) / 2 | 0) / r2 + "/" + (r2 * (c2._t1 + c2._t2) / 2 | 0) / r2
        ];
      }
      let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs2 = [
        { left: cc1.left, right: cc2.left },
        { left: cc1.left, right: cc2.right },
        { left: cc1.right, right: cc2.right },
        { left: cc1.right, right: cc2.left }
      ];
      pairs2 = pairs2.filter(function(pair) {
        return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
      });
      let results = [];
      if (pairs2.length === 0) return results;
      pairs2.forEach(function(pair) {
        results = results.concat(
          utils.pairiteration(pair.left, pair.right, threshold)
        );
      });
      results = results.filter(function(v2, i2) {
        return results.indexOf(v2) === i2;
      });
      return results;
    },
    getccenter: function(p1, p2, p3) {
      const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r2 = utils.dist(arc, p1);
      let s2 = atan2(p1.y - arc.y, p1.x - arc.x), m2 = atan2(p2.y - arc.y, p2.x - arc.x), e2 = atan2(p3.y - arc.y, p3.x - arc.x), _2;
      if (s2 < e2) {
        if (s2 > m2 || m2 > e2) {
          s2 += tau;
        }
        if (s2 > e2) {
          _2 = e2;
          e2 = s2;
          s2 = _2;
        }
      } else {
        if (e2 < m2 && m2 < s2) {
          _2 = e2;
          e2 = s2;
          s2 = _2;
        } else {
          e2 += tau;
        }
      }
      arc.s = s2;
      arc.e = e2;
      arc.r = r2;
      return arc;
    },
    numberSort: function(a2, b) {
      return a2 - b;
    }
  };
  class PolyBezier {
    constructor(curves) {
      this.curves = [];
      this._3d = false;
      if (!!curves) {
        this.curves = curves;
        this._3d = this.curves[0]._3d;
      }
    }
    valueOf() {
      return this.toString();
    }
    toString() {
      return "[" + this.curves.map(function(curve) {
        return utils.pointsToString(curve.points);
      }).join(", ") + "]";
    }
    addCurve(curve) {
      this.curves.push(curve);
      this._3d = this._3d || curve._3d;
    }
    length() {
      return this.curves.map(function(v2) {
        return v2.length();
      }).reduce(function(a2, b) {
        return a2 + b;
      });
    }
    curve(idx) {
      return this.curves[idx];
    }
    bbox() {
      const c2 = this.curves;
      var bbox = c2[0].bbox();
      for (var i2 = 1; i2 < c2.length; i2++) {
        utils.expandbox(bbox, c2[i2].bbox());
      }
      return bbox;
    }
    offset(d2) {
      const offset = [];
      this.curves.forEach(function(v2) {
        offset.push(...v2.offset(d2));
      });
      return new PolyBezier(offset);
    }
  }
  const { abs, min, max, cos, sin, acos, sqrt } = Math;
  const pi = Math.PI;
  class Bezier {
    constructor(coords) {
      let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
      let coordlen = false;
      if (typeof args[0] === "object") {
        coordlen = args.length;
        const newargs = [];
        args.forEach(function(point2) {
          ["x", "y", "z"].forEach(function(d2) {
            if (typeof point2[d2] !== "undefined") {
              newargs.push(point2[d2]);
            }
          });
        });
        args = newargs;
      }
      let higher = false;
      const len = args.length;
      if (coordlen) {
        if (coordlen > 4) {
          if (arguments.length !== 1) {
            throw new Error(
              "Only new Bezier(point[]) is accepted for 4th and higher order curves"
            );
          }
          higher = true;
        }
      } else {
        if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
          if (arguments.length !== 1) {
            throw new Error(
              "Only new Bezier(point[]) is accepted for 4th and higher order curves"
            );
          }
        }
      }
      const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
      const points = this.points = [];
      for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
        var point = {
          x: args[idx],
          y: args[idx + 1]
        };
        if (_3d) {
          point.z = args[idx + 2];
        }
        points.push(point);
      }
      const order = this.order = points.length - 1;
      const dims = this.dims = ["x", "y"];
      if (_3d) dims.push("z");
      this.dimlen = dims.length;
      const aligned = utils.align(points, { p1: points[0], p2: points[order] });
      const baselength = utils.dist(points[0], points[order]);
      this._linear = aligned.reduce((t2, p2) => t2 + abs(p2.y), 0) < baselength / 50;
      this._lut = [];
      this._t1 = 0;
      this._t2 = 1;
      this.update();
    }
    static quadraticFromPoints(p1, p2, p3, t2) {
      if (typeof t2 === "undefined") {
        t2 = 0.5;
      }
      if (t2 === 0) {
        return new Bezier(p2, p2, p3);
      }
      if (t2 === 1) {
        return new Bezier(p1, p2, p2);
      }
      const abc = Bezier.getABC(2, p1, p2, p3, t2);
      return new Bezier(p1, abc.A, p3);
    }
    static cubicFromPoints(S2, B2, E2, t2, d1) {
      if (typeof t2 === "undefined") {
        t2 = 0.5;
      }
      const abc = Bezier.getABC(3, S2, B2, E2, t2);
      if (typeof d1 === "undefined") {
        d1 = utils.dist(B2, abc.C);
      }
      const d2 = d1 * (1 - t2) / t2;
      const selen = utils.dist(S2, E2), lx = (E2.x - S2.x) / selen, ly = (E2.y - S2.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly;
      const e1 = { x: B2.x - bx1, y: B2.y - by1 }, e2 = { x: B2.x + bx2, y: B2.y + by2 }, A2 = abc.A, v1 = { x: A2.x + (e1.x - A2.x) / (1 - t2), y: A2.y + (e1.y - A2.y) / (1 - t2) }, v2 = { x: A2.x + (e2.x - A2.x) / t2, y: A2.y + (e2.y - A2.y) / t2 }, nc1 = { x: S2.x + (v1.x - S2.x) / t2, y: S2.y + (v1.y - S2.y) / t2 }, nc2 = {
        x: E2.x + (v2.x - E2.x) / (1 - t2),
        y: E2.y + (v2.y - E2.y) / (1 - t2)
      };
      return new Bezier(S2, nc1, nc2, E2);
    }
    static getUtils() {
      return utils;
    }
    getUtils() {
      return Bezier.getUtils();
    }
    static get PolyBezier() {
      return PolyBezier;
    }
    valueOf() {
      return this.toString();
    }
    toString() {
      return utils.pointsToString(this.points);
    }
    toSVG() {
      if (this._3d) return false;
      const p2 = this.points, x2 = p2[0].x, y2 = p2[0].y, s2 = ["M", x2, y2, this.order === 2 ? "Q" : "C"];
      for (let i2 = 1, last = p2.length; i2 < last; i2++) {
        s2.push(p2[i2].x);
        s2.push(p2[i2].y);
      }
      return s2.join(" ");
    }
    setRatios(ratios) {
      if (ratios.length !== this.points.length) {
        throw new Error("incorrect number of ratio values");
      }
      this.ratios = ratios;
      this._lut = [];
    }
    verify() {
      const print = this.coordDigest();
      if (print !== this._print) {
        this._print = print;
        this.update();
      }
    }
    coordDigest() {
      return this.points.map(function(c2, pos) {
        return "" + pos + c2.x + c2.y + (c2.z ? c2.z : 0);
      }).join("");
    }
    update() {
      this._lut = [];
      this.dpoints = utils.derive(this.points, this._3d);
      this.computedirection();
    }
    computedirection() {
      const points = this.points;
      const angle = utils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    }
    length() {
      return utils.length(this.derivative.bind(this));
    }
    static getABC(order = 2, S2, B2, E2, t2 = 0.5) {
      const u2 = utils.projectionratio(t2, order), um = 1 - u2, C2 = {
        x: u2 * S2.x + um * E2.x,
        y: u2 * S2.y + um * E2.y
      }, s2 = utils.abcratio(t2, order), A2 = {
        x: B2.x + (B2.x - C2.x) / s2,
        y: B2.y + (B2.y - C2.y) / s2
      };
      return { A: A2, B: B2, C: C2, S: S2, E: E2 };
    }
    getABC(t2, B2) {
      B2 = B2 || this.get(t2);
      let S2 = this.points[0];
      let E2 = this.points[this.order];
      return Bezier.getABC(this.order, S2, B2, E2, t2);
    }
    getLUT(steps) {
      this.verify();
      steps = steps || 100;
      if (this._lut.length === steps + 1) {
        return this._lut;
      }
      this._lut = [];
      steps++;
      this._lut = [];
      for (let i2 = 0, p2, t2; i2 < steps; i2++) {
        t2 = i2 / (steps - 1);
        p2 = this.compute(t2);
        p2.t = t2;
        this._lut.push(p2);
      }
      return this._lut;
    }
    on(point, error) {
      error = error || 5;
      const lut = this.getLUT(), hits = [];
      for (let i2 = 0, c2, t2 = 0; i2 < lut.length; i2++) {
        c2 = lut[i2];
        if (utils.dist(c2, point) < error) {
          hits.push(c2);
          t2 += i2 / lut.length;
        }
      }
      if (!hits.length) return false;
      return t /= hits.length;
    }
    project(point) {
      const LUT = this.getLUT(), l2 = LUT.length - 1, closest = utils.closest(LUT, point), mpos = closest.mpos, t1 = (mpos - 1) / l2, t2 = (mpos + 1) / l2, step = 0.1 / l2;
      let mdist = closest.mdist, t3 = t1, ft = t3, p2;
      mdist += 1;
      for (let d2; t3 < t2 + step; t3 += step) {
        p2 = this.compute(t3);
        d2 = utils.dist(point, p2);
        if (d2 < mdist) {
          mdist = d2;
          ft = t3;
        }
      }
      ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
      p2 = this.compute(ft);
      p2.t = ft;
      p2.d = mdist;
      return p2;
    }
    get(t2) {
      return this.compute(t2);
    }
    point(idx) {
      return this.points[idx];
    }
    compute(t2) {
      if (this.ratios) {
        return utils.computeWithRatios(t2, this.points, this.ratios, this._3d);
      }
      return utils.compute(t2, this.points, this._3d, this.ratios);
    }
    raise() {
      const p2 = this.points, np = [p2[0]], k2 = p2.length;
      for (let i2 = 1, pi2, pim; i2 < k2; i2++) {
        pi2 = p2[i2];
        pim = p2[i2 - 1];
        np[i2] = {
          x: (k2 - i2) / k2 * pi2.x + i2 / k2 * pim.x,
          y: (k2 - i2) / k2 * pi2.y + i2 / k2 * pim.y
        };
      }
      np[k2] = p2[k2 - 1];
      return new Bezier(np);
    }
    derivative(t2) {
      return utils.compute(t2, this.dpoints[0], this._3d);
    }
    dderivative(t2) {
      return utils.compute(t2, this.dpoints[1], this._3d);
    }
    align() {
      let p2 = this.points;
      return new Bezier(utils.align(p2, { p1: p2[0], p2: p2[p2.length - 1] }));
    }
    curvature(t2) {
      return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
    }
    inflections() {
      return utils.inflections(this.points);
    }
    normal(t2) {
      return this._3d ? this.__normal3(t2) : this.__normal2(t2);
    }
    __normal2(t2) {
      const d2 = this.derivative(t2);
      const q2 = sqrt(d2.x * d2.x + d2.y * d2.y);
      return { t: t2, x: -d2.y / q2, y: d2.x / q2 };
    }
    __normal3(t2) {
      const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
      r1.x /= q1;
      r1.y /= q1;
      r1.z /= q1;
      r2.x /= q2;
      r2.y /= q2;
      r2.z /= q2;
      const c2 = {
        x: r2.y * r1.z - r2.z * r1.y,
        y: r2.z * r1.x - r2.x * r1.z,
        z: r2.x * r1.y - r2.y * r1.x
      };
      const m2 = sqrt(c2.x * c2.x + c2.y * c2.y + c2.z * c2.z);
      c2.x /= m2;
      c2.y /= m2;
      c2.z /= m2;
      const R = [
        c2.x * c2.x,
        c2.x * c2.y - c2.z,
        c2.x * c2.z + c2.y,
        c2.x * c2.y + c2.z,
        c2.y * c2.y,
        c2.y * c2.z - c2.x,
        c2.x * c2.z - c2.y,
        c2.y * c2.z + c2.x,
        c2.z * c2.z
      ];
      const n2 = {
        t: t2,
        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
      };
      return n2;
    }
    hull(t2) {
      let p2 = this.points, _p = [], q2 = [], idx = 0;
      q2[idx++] = p2[0];
      q2[idx++] = p2[1];
      q2[idx++] = p2[2];
      if (this.order === 3) {
        q2[idx++] = p2[3];
      }
      while (p2.length > 1) {
        _p = [];
        for (let i2 = 0, pt, l2 = p2.length - 1; i2 < l2; i2++) {
          pt = utils.lerp(t2, p2[i2], p2[i2 + 1]);
          q2[idx++] = pt;
          _p.push(pt);
        }
        p2 = _p;
      }
      return q2;
    }
    split(t1, t2) {
      if (t1 === 0 && !!t2) {
        return this.split(t2).left;
      }
      if (t2 === 1) {
        return this.split(t1).right;
      }
      const q2 = this.hull(t1);
      const result = {
        left: this.order === 2 ? new Bezier([q2[0], q2[3], q2[5]]) : new Bezier([q2[0], q2[4], q2[7], q2[9]]),
        right: this.order === 2 ? new Bezier([q2[5], q2[4], q2[2]]) : new Bezier([q2[9], q2[8], q2[6], q2[3]]),
        span: q2
      };
      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
      if (!t2) {
        return result;
      }
      t2 = utils.map(t2, t1, 1, 0, 1);
      return result.right.split(t2).left;
    }
    extrema() {
      const result = {};
      let roots = [];
      this.dims.forEach(
        (function(dim) {
          let mfn = function(v2) {
            return v2[dim];
          };
          let p2 = this.dpoints[0].map(mfn);
          result[dim] = utils.droots(p2);
          if (this.order === 3) {
            p2 = this.dpoints[1].map(mfn);
            result[dim] = result[dim].concat(utils.droots(p2));
          }
          result[dim] = result[dim].filter(function(t2) {
            return t2 >= 0 && t2 <= 1;
          });
          roots = roots.concat(result[dim].sort(utils.numberSort));
        }).bind(this)
      );
      result.values = roots.sort(utils.numberSort).filter(function(v2, idx) {
        return roots.indexOf(v2) === idx;
      });
      return result;
    }
    bbox() {
      const extrema = this.extrema(), result = {};
      this.dims.forEach(
        (function(d2) {
          result[d2] = utils.getminmax(this, d2, extrema[d2]);
        }).bind(this)
      );
      return result;
    }
    overlaps(curve) {
      const lbbox = this.bbox(), tbbox = curve.bbox();
      return utils.bboxoverlap(lbbox, tbbox);
    }
    offset(t2, d2) {
      if (typeof d2 !== "undefined") {
        const c2 = this.get(t2), n2 = this.normal(t2);
        const ret = {
          c: c2,
          n: n2,
          x: c2.x + n2.x * d2,
          y: c2.y + n2.y * d2
        };
        if (this._3d) {
          ret.z = c2.z + n2.z * d2;
        }
        return ret;
      }
      if (this._linear) {
        const nv = this.normal(0), coords = this.points.map(function(p2) {
          const ret = {
            x: p2.x + t2 * nv.x,
            y: p2.y + t2 * nv.y
          };
          if (p2.z && nv.z) {
            ret.z = p2.z + t2 * nv.z;
          }
          return ret;
        });
        return [new Bezier(coords)];
      }
      return this.reduce().map(function(s2) {
        if (s2._linear) {
          return s2.offset(t2)[0];
        }
        return s2.scale(t2);
      });
    }
    simple() {
      if (this.order === 3) {
        const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
        const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
        if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;
      }
      const n1 = this.normal(0);
      const n2 = this.normal(1);
      let s2 = n1.x * n2.x + n1.y * n2.y;
      if (this._3d) {
        s2 += n1.z * n2.z;
      }
      return abs(acos(s2)) < pi / 3;
    }
    reduce() {
      let i2, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [];
      let extrema = this.extrema().values;
      if (extrema.indexOf(0) === -1) {
        extrema = [0].concat(extrema);
      }
      if (extrema.indexOf(1) === -1) {
        extrema.push(1);
      }
      for (t1 = extrema[0], i2 = 1; i2 < extrema.length; i2++) {
        t2 = extrema[i2];
        segment = this.split(t1, t2);
        segment._t1 = t1;
        segment._t2 = t2;
        pass1.push(segment);
        t1 = t2;
      }
      pass1.forEach(function(p1) {
        t1 = 0;
        t2 = 0;
        while (t2 <= 1) {
          for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
            segment = p1.split(t1, t2);
            if (!segment.simple()) {
              t2 -= step;
              if (abs(t1 - t2) < step) {
                return [];
              }
              segment = p1.split(t1, t2);
              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
              segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);
              pass2.push(segment);
              t1 = t2;
              break;
            }
          }
        }
        if (t1 < 1) {
          segment = p1.split(t1, 1);
          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
          segment._t2 = p1._t2;
          pass2.push(segment);
        }
      });
      return pass2;
    }
    translate(v2, d1, d2) {
      d2 = typeof d2 === "number" ? d2 : d1;
      const o2 = this.order;
      let d3 = this.points.map((_2, i2) => (1 - i2 / o2) * d1 + i2 / o2 * d2);
      return new Bezier(
        this.points.map((p2, i2) => ({
          x: p2.x + v2.x * d3[i2],
          y: p2.y + v2.y * d3[i2]
        }))
      );
    }
    scale(d2) {
      const order = this.order;
      let distanceFn = false;
      if (typeof d2 === "function") {
        distanceFn = d2;
      }
      if (distanceFn && order === 2) {
        return this.raise().scale(distanceFn);
      }
      const clockwise = this.clockwise;
      const points = this.points;
      if (this._linear) {
        return this.translate(
          this.normal(0),
          distanceFn ? distanceFn(0) : d2,
          distanceFn ? distanceFn(1) : d2
        );
      }
      const r1 = distanceFn ? distanceFn(0) : d2;
      const r2 = distanceFn ? distanceFn(1) : d2;
      const v2 = [this.offset(0, 10), this.offset(1, 10)];
      const np = [];
      const o2 = utils.lli4(v2[0], v2[0].c, v2[1], v2[1].c);
      if (!o2) {
        throw new Error("cannot scale this curve. Try reducing it first.");
      }
      [0, 1].forEach(function(t2) {
        const p2 = np[t2 * order] = utils.copy(points[t2 * order]);
        p2.x += (t2 ? r2 : r1) * v2[t2].n.x;
        p2.y += (t2 ? r2 : r1) * v2[t2].n.y;
      });
      if (!distanceFn) {
        [0, 1].forEach((t2) => {
          if (order === 2 && !!t2) return;
          const p2 = np[t2 * order];
          const d3 = this.derivative(t2);
          const p22 = { x: p2.x + d3.x, y: p2.y + d3.y };
          np[t2 + 1] = utils.lli4(p2, p22, o2, points[t2 + 1]);
        });
        return new Bezier(np);
      }
      [0, 1].forEach(function(t2) {
        if (order === 2 && !!t2) return;
        var p2 = points[t2 + 1];
        var ov = {
          x: p2.x - o2.x,
          y: p2.y - o2.y
        };
        var rc = distanceFn ? distanceFn((t2 + 1) / order) : d2;
        if (distanceFn && !clockwise) rc = -rc;
        var m2 = sqrt(ov.x * ov.x + ov.y * ov.y);
        ov.x /= m2;
        ov.y /= m2;
        np[t2 + 1] = {
          x: p2.x + rc * ov.x,
          y: p2.y + rc * ov.y
        };
      });
      return new Bezier(np);
    }
    outline(d1, d2, d3, d4) {
      d2 = d2 === void 0 ? d1 : d2;
      if (this._linear) {
        const n2 = this.normal(0);
        const start2 = this.points[0];
        const end = this.points[this.points.length - 1];
        let s2, mid, e2;
        if (d3 === void 0) {
          d3 = d1;
          d4 = d2;
        }
        s2 = { x: start2.x + n2.x * d1, y: start2.y + n2.y * d1 };
        e2 = { x: end.x + n2.x * d3, y: end.y + n2.y * d3 };
        mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
        const fline = [s2, mid, e2];
        s2 = { x: start2.x - n2.x * d2, y: start2.y - n2.y * d2 };
        e2 = { x: end.x - n2.x * d4, y: end.y - n2.y * d4 };
        mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
        const bline = [e2, mid, s2];
        const ls2 = utils.makeline(bline[2], fline[0]);
        const le2 = utils.makeline(fline[2], bline[0]);
        const segments2 = [ls2, new Bezier(fline), le2, new Bezier(bline)];
        return new PolyBezier(segments2);
      }
      const reduced = this.reduce(), len = reduced.length, fcurves = [];
      let bcurves = [], p2, alen = 0, tlen = this.length();
      const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";
      function linearDistanceFunction(s2, e2, tlen2, alen2, slen) {
        return function(v2) {
          const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d5 = e2 - s2;
          return utils.map(v2, 0, 1, s2 + f1 * d5, s2 + f2 * d5);
        };
      }
      reduced.forEach(function(segment) {
        const slen = segment.length();
        if (graduated) {
          fcurves.push(
            segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
          );
          bcurves.push(
            segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
          );
        } else {
          fcurves.push(segment.scale(d1));
          bcurves.push(segment.scale(-d2));
        }
        alen += slen;
      });
      bcurves = bcurves.map(function(s2) {
        p2 = s2.points;
        if (p2[3]) {
          s2.points = [p2[3], p2[2], p2[1], p2[0]];
        } else {
          s2.points = [p2[2], p2[1], p2[0]];
        }
        return s2;
      }).reverse();
      const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
      return new PolyBezier(segments);
    }
    outlineshapes(d1, d2, curveIntersectionThreshold) {
      d2 = d2 || d1;
      const outline = this.outline(d1, d2).curves;
      const shapes = [];
      for (let i2 = 1, len = outline.length; i2 < len / 2; i2++) {
        const shape = utils.makeshape(
          outline[i2],
          outline[len - i2],
          curveIntersectionThreshold
        );
        shape.startcap.virtual = i2 > 1;
        shape.endcap.virtual = i2 < len / 2 - 1;
        shapes.push(shape);
      }
      return shapes;
    }
    intersects(curve, curveIntersectionThreshold) {
      if (!curve) return this.selfintersects(curveIntersectionThreshold);
      if (curve.p1 && curve.p2) {
        return this.lineIntersects(curve);
      }
      if (curve instanceof Bezier) {
        curve = curve.reduce();
      }
      return this.curveintersects(
        this.reduce(),
        curve,
        curveIntersectionThreshold
      );
    }
    lineIntersects(line) {
      const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);
      return utils.roots(this.points, line).filter((t2) => {
        var p2 = this.get(t2);
        return utils.between(p2.x, mx, MX) && utils.between(p2.y, my, MY);
      });
    }
    selfintersects(curveIntersectionThreshold) {
      const reduced = this.reduce(), len = reduced.length - 2, results = [];
      for (let i2 = 0, result, left, right; i2 < len; i2++) {
        left = reduced.slice(i2, i2 + 1);
        right = reduced.slice(i2 + 2);
        result = this.curveintersects(left, right, curveIntersectionThreshold);
        results.push(...result);
      }
      return results;
    }
    curveintersects(c1, c2, curveIntersectionThreshold) {
      const pairs2 = [];
      c1.forEach(function(l2) {
        c2.forEach(function(r2) {
          if (l2.overlaps(r2)) {
            pairs2.push({ left: l2, right: r2 });
          }
        });
      });
      let intersections = [];
      pairs2.forEach(function(pair) {
        const result = utils.pairiteration(
          pair.left,
          pair.right,
          curveIntersectionThreshold
        );
        if (result.length > 0) {
          intersections = intersections.concat(result);
        }
      });
      return intersections;
    }
    arcs(errorThreshold) {
      errorThreshold = errorThreshold || 0.5;
      return this._iterate(errorThreshold, []);
    }
    _error(pc, np1, s2, e2) {
      const q2 = (e2 - s2) / 4, c1 = this.get(s2 + q2), c2 = this.get(e2 - q2), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
      return abs(d1 - ref) + abs(d2 - ref);
    }
    _iterate(errorThreshold, circles) {
      let t_s = 0, t_e = 1, safety;
      do {
        safety = 0;
        t_e = 1;
        let np1 = this.get(t_s), np2, np3, arc, prev_arc;
        let curr_good = false, prev_good = false, done;
        let t_m = t_e, prev_e = 1;
        do {
          prev_good = curr_good;
          prev_arc = arc;
          t_m = (t_s + t_e) / 2;
          np2 = this.get(t_m);
          np3 = this.get(t_e);
          arc = utils.getccenter(np1, np2, np3);
          arc.interval = {
            start: t_s,
            end: t_e
          };
          let error = this._error(arc, np1, t_s, t_e);
          curr_good = error <= errorThreshold;
          done = prev_good && !curr_good;
          if (!done) prev_e = t_e;
          if (curr_good) {
            if (t_e >= 1) {
              arc.interval.end = prev_e = 1;
              prev_arc = arc;
              if (t_e > 1) {
                let d2 = {
                  x: arc.x + arc.r * cos(arc.e),
                  y: arc.y + arc.r * sin(arc.e)
                };
                arc.e += utils.angle({ x: arc.x, y: arc.y }, d2, this.get(1));
              }
              break;
            }
            t_e = t_e + (t_e - t_s) / 2;
          } else {
            t_e = t_m;
          }
        } while (!done && safety++ < 100);
        if (safety >= 100) {
          break;
        }
        prev_arc = prev_arc ? prev_arc : arc;
        circles.push(prev_arc);
        t_s = prev_e;
      } while (t_e < 1);
      return circles;
    }
  }
  function _arrayLikeToArray$1(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
    return n2;
  }
  function _arrayWithHoles$1(r2) {
    if (Array.isArray(r2)) return r2;
  }
  function _arrayWithoutHoles$1(r2) {
    if (Array.isArray(r2)) return _arrayLikeToArray$1(r2);
  }
  function _iterableToArray$1(r2) {
    if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
  }
  function _iterableToArrayLimit$1(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
        else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2)) return;
        } finally {
          if (o2) throw n2;
        }
      }
      return a2;
    }
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _objectWithoutProperties(e2, t2) {
    if (null == e2) return {};
    var o2, r2, i2 = _objectWithoutPropertiesLoose(e2, t2);
    if (Object.getOwnPropertySymbols) {
      var s2 = Object.getOwnPropertySymbols(e2);
      for (r2 = 0; r2 < s2.length; r2++) o2 = s2[r2], t2.includes(o2) || {}.propertyIsEnumerable.call(e2, o2) && (i2[o2] = e2[o2]);
    }
    return i2;
  }
  function _objectWithoutPropertiesLoose(r2, e2) {
    if (null == r2) return {};
    var t2 = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (e2.includes(n2)) continue;
      t2[n2] = r2[n2];
    }
    return t2;
  }
  function _slicedToArray$1(r2, e2) {
    return _arrayWithHoles$1(r2) || _iterableToArrayLimit$1(r2, e2) || _unsupportedIterableToArray$1(r2, e2) || _nonIterableRest$1();
  }
  function _toConsumableArray$1(r2) {
    return _arrayWithoutHoles$1(r2) || _iterableToArray$1(r2) || _unsupportedIterableToArray$1(r2) || _nonIterableSpread$1();
  }
  function _toPrimitive$1(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(t2);
  }
  function _toPropertyKey$1(t2) {
    var i2 = _toPrimitive$1(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _unsupportedIterableToArray$1(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray$1(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$1(r2, a2) : void 0;
    }
  }
  var index = function() {
    var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var keyAccessors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var multiItem = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var flattenKeys = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var keys = (keyAccessors instanceof Array ? keyAccessors.length ? keyAccessors : [void 0] : [keyAccessors]).map(function(key) {
      return {
        keyAccessor: key,
        isProp: !(key instanceof Function)
      };
    });
    var indexedResult = list.reduce(function(res, item) {
      var iterObj = res;
      var itemVal = item;
      keys.forEach(function(_ref, idx) {
        var keyAccessor = _ref.keyAccessor, isProp = _ref.isProp;
        var key;
        if (isProp) {
          var _itemVal = itemVal, propVal = _itemVal[keyAccessor], rest = _objectWithoutProperties(_itemVal, [keyAccessor].map(_toPropertyKey$1));
          key = propVal;
          itemVal = rest;
        } else {
          key = keyAccessor(itemVal, idx);
        }
        if (idx + 1 < keys.length) {
          if (!iterObj.hasOwnProperty(key)) {
            iterObj[key] = {};
          }
          iterObj = iterObj[key];
        } else {
          if (multiItem) {
            if (!iterObj.hasOwnProperty(key)) {
              iterObj[key] = [];
            }
            iterObj[key].push(itemVal);
          } else {
            iterObj[key] = itemVal;
          }
        }
      });
      return res;
    }, {});
    if (multiItem instanceof Function) {
      (function reduce(node) {
        var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        if (level === keys.length) {
          Object.keys(node).forEach(function(k2) {
            return node[k2] = multiItem(node[k2]);
          });
        } else {
          Object.values(node).forEach(function(child) {
            return reduce(child, level + 1);
          });
        }
      })(indexedResult);
    }
    var result = indexedResult;
    if (flattenKeys) {
      result = [];
      (function flatten(node) {
        var accKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        if (accKeys.length === keys.length) {
          result.push({
            keys: accKeys,
            vals: node
          });
        } else {
          Object.entries(node).forEach(function(_ref2) {
            var _ref3 = _slicedToArray$1(_ref2, 2), key = _ref3[0], val = _ref3[1];
            return flatten(val, [].concat(_toConsumableArray$1(accKeys), [key]));
          });
        }
      })(indexedResult);
      if (keyAccessors instanceof Array && keyAccessors.length === 0 && result.length === 1) {
        result[0].keys = [];
      }
    }
    return result;
  };
  function initRange(domain, range) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range).domain(domain);
        break;
    }
    return this;
  }
  const implicit = Symbol("implicit");
  function ordinal() {
    var index2 = new InternMap(), domain = [], range = [], unknown = implicit;
    function scale(d2) {
      let i2 = index2.get(d2);
      if (i2 === void 0) {
        if (unknown !== implicit) return unknown;
        index2.set(d2, i2 = domain.push(d2) - 1);
      }
      return range[i2 % range.length];
    }
    scale.domain = function(_2) {
      if (!arguments.length) return domain.slice();
      domain = [], index2 = new InternMap();
      for (const value of _2) {
        if (index2.has(value)) continue;
        index2.set(value, domain.push(value) - 1);
      }
      return scale;
    };
    scale.range = function(_2) {
      return arguments.length ? (range = Array.from(_2), scale) : range.slice();
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function colors(specifier) {
    var n2 = specifier.length / 6 | 0, colors2 = new Array(n2), i2 = 0;
    while (i2 < n2) colors2[i2] = "#" + specifier.slice(i2 * 6, ++i2 * 6);
    return colors2;
  }
  const schemePaired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
  function styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;
    if (typeof document === "undefined") {
      return;
    }
    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";
    if (insertAt === "top") {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }
    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }
  var css_248z = ".force-graph-container canvas {\n  display: block;\n  user-select: none;\n  outline: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.force-graph-container .clickable {\n  cursor: pointer;\n}\n\n.force-graph-container .grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.force-graph-container .grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}\n";
  styleInject(css_248z);
  function _arrayLikeToArray(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
    return n2;
  }
  function _arrayWithHoles(r2) {
    if (Array.isArray(r2)) return r2;
  }
  function _arrayWithoutHoles(r2) {
    if (Array.isArray(r2)) return _arrayLikeToArray(r2);
  }
  function _construct(t2, e2, r2) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o2 = [null];
    o2.push.apply(o2, e2);
    var p2 = new (t2.bind.apply(t2, o2))();
    return p2;
  }
  function _defineProperty(e2, r2, t2) {
    return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e2[r2] = t2, e2;
  }
  function _isNativeReflectConstruct() {
    try {
      var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t3) {
    }
    return (_isNativeReflectConstruct = function() {
      return !!t2;
    })();
  }
  function _iterableToArray(r2) {
    if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
        else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2)) return;
        } finally {
          if (o2) throw n2;
        }
      }
      return a2;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread2(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  function _slicedToArray(r2, e2) {
    return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
  }
  function _toConsumableArray(r2) {
    return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
  }
  function _toPrimitive(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function _toPropertyKey(t2) {
    var i2 = _toPrimitive(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _unsupportedIterableToArray(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
    }
  }
  var autoColorScale = ordinal(schemePaired);
  function autoColorObjects(objects, colorByAccessor, colorField) {
    if (!colorByAccessor || typeof colorField !== "string") return;
    objects.filter(function(obj) {
      return !obj[colorField];
    }).forEach(function(obj) {
      obj[colorField] = autoColorScale(colorByAccessor(obj));
    });
  }
  function getDagDepths(_ref, idAccessor) {
    var nodes = _ref.nodes, links = _ref.links;
    var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$nodeFilter = _ref2.nodeFilter, nodeFilter = _ref2$nodeFilter === void 0 ? function() {
      return true;
    } : _ref2$nodeFilter, _ref2$onLoopError = _ref2.onLoopError, onLoopError = _ref2$onLoopError === void 0 ? function(loopIds) {
      throw "Invalid DAG structure! Found cycle in node path: ".concat(loopIds.join(" -> "), ".");
    } : _ref2$onLoopError;
    var graph = {};
    nodes.forEach(function(node) {
      return graph[idAccessor(node)] = {
        data: node,
        out: [],
        depth: -1,
        skip: !nodeFilter(node)
      };
    });
    links.forEach(function(_ref3) {
      var source = _ref3.source, target = _ref3.target;
      var sourceId = getNodeId(source);
      var targetId = getNodeId(target);
      if (!graph.hasOwnProperty(sourceId)) throw "Missing source node with id: ".concat(sourceId);
      if (!graph.hasOwnProperty(targetId)) throw "Missing target node with id: ".concat(targetId);
      var sourceNode = graph[sourceId];
      var targetNode = graph[targetId];
      sourceNode.out.push(targetNode);
      function getNodeId(node) {
        return _typeof(node) === "object" ? idAccessor(node) : node;
      }
    });
    var foundLoops = [];
    traverse(Object.values(graph));
    var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2), node = _ref5[1];
      return !node.skip;
    }).map(function(_ref6) {
      var _ref7 = _slicedToArray(_ref6, 2), id2 = _ref7[0], node = _ref7[1];
      return _defineProperty({}, id2, node.depth);
    }))));
    return nodeDepths;
    function traverse(nodes2) {
      var nodeStack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var _loop = function _loop2() {
        var node = nodes2[i2];
        if (nodeStack.indexOf(node) !== -1) {
          var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function(d2) {
            return idAccessor(d2.data);
          });
          if (!foundLoops.some(function(foundLoop) {
            return foundLoop.length === loop.length && foundLoop.every(function(id2, idx) {
              return id2 === loop[idx];
            });
          })) {
            foundLoops.push(loop);
            onLoopError(loop);
          }
          return 1;
        }
        if (currentDepth > node.depth) {
          node.depth = currentDepth;
          traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));
        }
      };
      for (var i2 = 0, l2 = nodes2.length; i2 < l2; i2++) {
        if (_loop()) continue;
      }
    }
  }
  var DAG_LEVEL_NODE_RATIO = 2;
  var notifyRedraw = function notifyRedraw2(_2, state) {
    return state.onNeedsRedraw && state.onNeedsRedraw();
  };
  var updDataPhotons = function updDataPhotons2(_2, state) {
    if (!state.isShadow) {
      var linkParticlesAccessor = index$3(state.linkDirectionalParticles);
      state.graphData.links.forEach(function(link) {
        var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));
        if (numPhotons) {
          link.__photons = _toConsumableArray(Array(numPhotons)).map(function() {
            return {};
          });
        } else {
          delete link.__photons;
        }
      });
    }
  };
  var CanvasForceGraph = index$4({
    props: {
      graphData: {
        "default": {
          nodes: [],
          links: []
        },
        onChange: function onChange(_2, state) {
          state.engineRunning = false;
          updDataPhotons(_2, state);
        }
      },
      dagMode: {
        onChange: function onChange(dagMode, state) {
          !dagMode && (state.graphData.nodes || []).forEach(function(n2) {
            return n2.fx = n2.fy = void 0;
          });
        }
      },
      dagLevelDistance: {},
      dagNodeFilter: {
        "default": function _default2(node) {
          return true;
        }
      },
      onDagError: {
        triggerUpdate: false
      },
      nodeRelSize: {
        "default": 4,
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      // area per val unit
      nodeId: {
        "default": "id"
      },
      nodeVal: {
        "default": "val",
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      nodeColor: {
        "default": "color",
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      nodeAutoColorBy: {},
      nodeCanvasObject: {
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      nodeCanvasObjectMode: {
        "default": function _default2() {
          return "replace";
        },
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      nodeVisibility: {
        "default": true,
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkSource: {
        "default": "source"
      },
      linkTarget: {
        "default": "target"
      },
      linkVisibility: {
        "default": true,
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkColor: {
        "default": "color",
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkAutoColorBy: {},
      linkLineDash: {
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkWidth: {
        "default": 1,
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkCurvature: {
        "default": 0,
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkCanvasObject: {
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkCanvasObjectMode: {
        "default": function _default2() {
          return "replace";
        },
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkDirectionalArrowLength: {
        "default": 0,
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkDirectionalArrowColor: {
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      linkDirectionalArrowRelPos: {
        "default": 0.5,
        triggerUpdate: false,
        onChange: notifyRedraw
      },
      // value between 0<>1 indicating the relative pos along the (exposed) line
      linkDirectionalParticles: {
        "default": 0,
        triggerUpdate: false,
        onChange: updDataPhotons
      },
      // animate photons travelling in the link direction
      linkDirectionalParticleSpeed: {
        "default": 0.01,
        triggerUpdate: false
      },
      // in link length ratio per frame
      linkDirectionalParticleOffset: {
        "default": 0,
        triggerUpdate: false
      },
      // starting position offset along the link's length, like a pre-delay. Values between [0, 1]
      linkDirectionalParticleWidth: {
        "default": 4,
        triggerUpdate: false
      },
      linkDirectionalParticleColor: {
        triggerUpdate: false
      },
      linkDirectionalParticleCanvasObject: {
        triggerUpdate: false
      },
      globalScale: {
        "default": 1,
        triggerUpdate: false
      },
      d3AlphaMin: {
        "default": 0,
        triggerUpdate: false
      },
      d3AlphaDecay: {
        "default": 0.0228,
        triggerUpdate: false,
        onChange: function onChange(alphaDecay, state) {
          state.forceLayout.alphaDecay(alphaDecay);
        }
      },
      d3AlphaTarget: {
        "default": 0,
        triggerUpdate: false,
        onChange: function onChange(alphaTarget, state) {
          state.forceLayout.alphaTarget(alphaTarget);
        }
      },
      d3VelocityDecay: {
        "default": 0.4,
        triggerUpdate: false,
        onChange: function onChange(velocityDecay, state) {
          state.forceLayout.velocityDecay(velocityDecay);
        }
      },
      warmupTicks: {
        "default": 0,
        triggerUpdate: false
      },
      // how many times to tick the force engine at init before starting to render
      cooldownTicks: {
        "default": Infinity,
        triggerUpdate: false
      },
      cooldownTime: {
        "default": 15e3,
        triggerUpdate: false
      },
      // ms
      onUpdate: {
        "default": function _default2() {
        },
        triggerUpdate: false
      },
      onFinishUpdate: {
        "default": function _default2() {
        },
        triggerUpdate: false
      },
      onEngineTick: {
        "default": function _default2() {
        },
        triggerUpdate: false
      },
      onEngineStop: {
        "default": function _default2() {
        },
        triggerUpdate: false
      },
      onNeedsRedraw: {
        triggerUpdate: false
      },
      isShadow: {
        "default": false,
        triggerUpdate: false
      }
    },
    methods: {
      // Expose d3 forces for external manipulation
      d3Force: function d3Force(state, forceName, forceFn) {
        if (forceFn === void 0) {
          return state.forceLayout.force(forceName);
        }
        state.forceLayout.force(forceName, forceFn);
        return this;
      },
      d3ReheatSimulation: function d3ReheatSimulation(state) {
        state.forceLayout.alpha(1);
        this.resetCountdown();
        return this;
      },
      // reset cooldown state
      resetCountdown: function resetCountdown(state) {
        state.cntTicks = 0;
        state.startTickTime = /* @__PURE__ */ new Date();
        state.engineRunning = true;
        return this;
      },
      isEngineRunning: function isEngineRunning(state) {
        return !!state.engineRunning;
      },
      tickFrame: function tickFrame(state) {
        !state.isShadow && layoutTick();
        paintLinks();
        !state.isShadow && paintArrows();
        !state.isShadow && paintPhotons();
        paintNodes();
        return this;
        function layoutTick() {
          if (state.engineRunning) {
            if (++state.cntTicks > state.cooldownTicks || /* @__PURE__ */ new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {
              state.engineRunning = false;
              state.onEngineStop();
            } else {
              state.forceLayout.tick();
              state.onEngineTick();
            }
          }
        }
        function paintNodes() {
          var getVisibility = index$3(state.nodeVisibility);
          var getVal = index$3(state.nodeVal);
          var getColor = index$3(state.nodeColor);
          var getNodeCanvasObjectMode = index$3(state.nodeCanvasObjectMode);
          var ctx = state.ctx;
          var padAmount = state.isShadow / state.globalScale;
          var visibleNodes = state.graphData.nodes.filter(getVisibility);
          ctx.save();
          visibleNodes.forEach(function(node) {
            var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);
            if (state.nodeCanvasObject && (nodeCanvasObjectMode === "before" || nodeCanvasObjectMode === "replace")) {
              state.nodeCanvasObject(node, ctx, state.globalScale);
              if (nodeCanvasObjectMode === "replace") {
                ctx.restore();
                return;
              }
            }
            var r2 = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;
            ctx.beginPath();
            ctx.arc(node.x, node.y, r2, 0, 2 * Math.PI, false);
            ctx.fillStyle = getColor(node) || "rgba(31, 120, 180, 0.92)";
            ctx.fill();
            if (state.nodeCanvasObject && nodeCanvasObjectMode === "after") {
              state.nodeCanvasObject(node, state.ctx, state.globalScale);
            }
          });
          ctx.restore();
        }
        function paintLinks() {
          var getVisibility = index$3(state.linkVisibility);
          var getColor = index$3(state.linkColor);
          var getWidth = index$3(state.linkWidth);
          var getLineDash = index$3(state.linkLineDash);
          var getCurvature = index$3(state.linkCurvature);
          var getLinkCanvasObjectMode = index$3(state.linkCanvasObjectMode);
          var ctx = state.ctx;
          var padAmount = state.isShadow * 2;
          var visibleLinks = state.graphData.links.filter(getVisibility);
          visibleLinks.forEach(calcLinkControlPoints);
          var beforeCustomLinks = [], afterCustomLinks = [], defaultPaintLinks = visibleLinks;
          if (state.linkCanvasObject) {
            var replaceCustomLinks = [], otherCustomLinks = [];
            visibleLinks.forEach(function(d2) {
              return ({
                before: beforeCustomLinks,
                after: afterCustomLinks,
                replace: replaceCustomLinks
              }[getLinkCanvasObjectMode(d2)] || otherCustomLinks).push(d2);
            });
            defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);
            beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);
          }
          ctx.save();
          beforeCustomLinks.forEach(function(link) {
            return state.linkCanvasObject(link, ctx, state.globalScale);
          });
          ctx.restore();
          var linksPerColor = index(defaultPaintLinks, [getColor, getWidth, getLineDash]);
          ctx.save();
          Object.entries(linksPerColor).forEach(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), color2 = _ref2[0], linksPerWidth = _ref2[1];
            var lineColor = !color2 || color2 === "undefined" ? "rgba(0,0,0,0.15)" : color2;
            Object.entries(linksPerWidth).forEach(function(_ref3) {
              var _ref4 = _slicedToArray(_ref3, 2), width = _ref4[0], linesPerLineDash = _ref4[1];
              var lineWidth = (width || 1) / state.globalScale + padAmount;
              Object.entries(linesPerLineDash).forEach(function(_ref5) {
                var _ref6 = _slicedToArray(_ref5, 2);
                _ref6[0];
                var links = _ref6[1];
                var lineDashSegments = getLineDash(links[0]);
                ctx.beginPath();
                links.forEach(function(link) {
                  var start2 = link.source;
                  var end = link.target;
                  if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
                  ctx.moveTo(start2.x, start2.y);
                  var controlPoints = link.__controlPoints;
                  if (!controlPoints) {
                    ctx.lineTo(end.x, end.y);
                  } else {
                    ctx[controlPoints.length === 2 ? "quadraticCurveTo" : "bezierCurveTo"].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));
                  }
                });
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = lineWidth;
                ctx.setLineDash(lineDashSegments || []);
                ctx.stroke();
              });
            });
          });
          ctx.restore();
          ctx.save();
          afterCustomLinks.forEach(function(link) {
            return state.linkCanvasObject(link, ctx, state.globalScale);
          });
          ctx.restore();
          function calcLinkControlPoints(link) {
            var curvature = getCurvature(link);
            if (!curvature) {
              link.__controlPoints = null;
              return;
            }
            var start2 = link.source;
            var end = link.target;
            if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
            var l2 = Math.sqrt(Math.pow(end.x - start2.x, 2) + Math.pow(end.y - start2.y, 2));
            if (l2 > 0) {
              var a2 = Math.atan2(end.y - start2.y, end.x - start2.x);
              var d2 = l2 * curvature;
              var cp = {
                // control point
                x: (start2.x + end.x) / 2 + d2 * Math.cos(a2 - Math.PI / 2),
                y: (start2.y + end.y) / 2 + d2 * Math.sin(a2 - Math.PI / 2)
              };
              link.__controlPoints = [cp.x, cp.y];
            } else {
              var _d = curvature * 70;
              link.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];
            }
          }
        }
        function paintArrows() {
          var ARROW_WH_RATIO = 1.6;
          var ARROW_VLEN_RATIO = 0.2;
          var getLength = index$3(state.linkDirectionalArrowLength);
          var getRelPos = index$3(state.linkDirectionalArrowRelPos);
          var getVisibility = index$3(state.linkVisibility);
          var getColor = index$3(state.linkDirectionalArrowColor || state.linkColor);
          var getNodeVal = index$3(state.nodeVal);
          var ctx = state.ctx;
          ctx.save();
          state.graphData.links.filter(getVisibility).forEach(function(link) {
            var arrowLength = getLength(link);
            if (!arrowLength || arrowLength < 0) return;
            var start2 = link.source;
            var end = link.target;
            if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
            var startR = Math.sqrt(Math.max(0, getNodeVal(start2) || 1)) * state.nodeRelSize;
            var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;
            var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));
            var arrowColor = getColor(link) || "rgba(0,0,0,0.28)";
            var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;
            var bzLine = link.__controlPoints && _construct(Bezier, [start2.x, start2.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y]));
            var getCoordsAlongLine = bzLine ? function(t2) {
              return bzLine.get(t2);
            } : function(t2) {
              return {
                // straight line: interpolate linearly
                x: start2.x + (end.x - start2.x) * t2 || 0,
                y: start2.y + (end.y - start2.y) * t2 || 0
              };
            };
            var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start2.x, 2) + Math.pow(end.y - start2.y, 2));
            var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;
            var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);
            var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);
            var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);
            var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;
            ctx.beginPath();
            ctx.moveTo(arrowHead.x, arrowHead.y);
            ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));
            ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);
            ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));
            ctx.fillStyle = arrowColor;
            ctx.fill();
          });
          ctx.restore();
        }
        function paintPhotons() {
          var getNumPhotons = index$3(state.linkDirectionalParticles);
          var getSpeed = index$3(state.linkDirectionalParticleSpeed);
          var getOffset = index$3(state.linkDirectionalParticleOffset);
          var getDiameter = index$3(state.linkDirectionalParticleWidth);
          var getVisibility = index$3(state.linkVisibility);
          var getColor = index$3(state.linkDirectionalParticleColor || state.linkColor);
          var ctx = state.ctx;
          ctx.save();
          state.graphData.links.filter(getVisibility).forEach(function(link) {
            var numCyclePhotons = getNumPhotons(link);
            if (!link.hasOwnProperty("__photons") || !link.__photons.length) return;
            var start2 = link.source;
            var end = link.target;
            if (!start2 || !end || !start2.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
            var particleSpeed = getSpeed(link);
            var particleOffset = Math.abs(getOffset(link));
            var photons = link.__photons || [];
            var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);
            var photonColor = getColor(link) || "rgba(0,0,0,0.28)";
            ctx.fillStyle = photonColor;
            var bzLine = link.__controlPoints ? _construct(Bezier, [start2.x, start2.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y])) : null;
            var cyclePhotonIdx = 0;
            var needsCleanup = false;
            photons.forEach(function(photon) {
              var singleHop = !!photon.__singleHop;
              if (!photon.hasOwnProperty("__progressRatio")) {
                photon.__progressRatio = singleHop ? 0 : (cyclePhotonIdx + particleOffset) / numCyclePhotons;
              }
              !singleHop && cyclePhotonIdx++;
              photon.__progressRatio += particleSpeed;
              if (photon.__progressRatio >= 1) {
                if (!singleHop) {
                  photon.__progressRatio = photon.__progressRatio % 1;
                } else {
                  needsCleanup = true;
                  return;
                }
              }
              var photonPosRatio = photon.__progressRatio;
              var coords = bzLine ? bzLine.get(photonPosRatio) : {
                // straight line: interpolate linearly
                x: start2.x + (end.x - start2.x) * photonPosRatio || 0,
                y: start2.y + (end.y - start2.y) * photonPosRatio || 0
              };
              if (state.linkDirectionalParticleCanvasObject) {
                state.linkDirectionalParticleCanvasObject(coords.x, coords.y, link, ctx, state.globalScale);
              } else {
                ctx.beginPath();
                ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);
                ctx.fill();
              }
            });
            if (needsCleanup) {
              link.__photons = link.__photons.filter(function(photon) {
                return !photon.__singleHop || photon.__progressRatio <= 1;
              });
            }
          });
          ctx.restore();
        }
      },
      emitParticle: function emitParticle(state, link) {
        if (link) {
          !link.__photons && (link.__photons = []);
          link.__photons.push({
            __singleHop: true
          });
        }
        return this;
      }
    },
    stateInit: function stateInit() {
      return {
        forceLayout: forceSimulation().force("link", forceLink()).force("charge", forceManyBody()).force("center", forceCenter()).force("dagRadial", null).stop(),
        engineRunning: false
      };
    },
    init: function init2(canvasCtx, state) {
      state.ctx = canvasCtx;
    },
    update: function update(state, changedProps) {
      state.engineRunning = false;
      state.onUpdate();
      if (state.nodeAutoColorBy !== null) {
        autoColorObjects(state.graphData.nodes, index$3(state.nodeAutoColorBy), state.nodeColor);
      }
      if (state.linkAutoColorBy !== null) {
        autoColorObjects(state.graphData.links, index$3(state.linkAutoColorBy), state.linkColor);
      }
      state.graphData.links.forEach(function(link) {
        link.source = link[state.linkSource];
        link.target = link[state.linkTarget];
      });
      state.forceLayout.stop().alpha(1).nodes(state.graphData.nodes);
      var linkForce = state.forceLayout.force("link");
      if (linkForce) {
        linkForce.id(function(d2) {
          return d2[state.nodeId];
        }).links(state.graphData.links);
      }
      var nodeDepths = state.dagMode && getDagDepths(state.graphData, function(node) {
        return node[state.nodeId];
      }, {
        nodeFilter: state.dagNodeFilter,
        onLoopError: state.onDagError || void 0
      });
      var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));
      var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? 0.7 : 1);
      if (["lr", "rl", "td", "bu"].includes(changedProps.dagMode)) {
        var resetProp = ["lr", "rl"].includes(changedProps.dagMode) ? "fx" : "fy";
        state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
          return delete node[resetProp];
        });
      }
      if (["lr", "rl", "td", "bu"].includes(state.dagMode)) {
        var invert = ["rl", "bu"].includes(state.dagMode);
        var fixFn = function fixFn2(node) {
          return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);
        };
        var _resetProp = ["lr", "rl"].includes(state.dagMode) ? "fx" : "fy";
        state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
          return node[_resetProp] = fixFn(node);
        });
      }
      state.forceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? forceRadial(function(node) {
        var nodeDepth = nodeDepths[node[state.nodeId]] || -1;
        return (state.dagMode === "radialin" ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;
      }).strength(function(node) {
        return state.dagNodeFilter(node) ? 1 : 0;
      }) : null);
      for (var i2 = 0; i2 < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i2++) {
        state.forceLayout.tick();
      }
      this.resetCountdown();
      state.onFinishUpdate();
    }
  });
  function linkKapsule(kapsulePropNames, kapsuleType) {
    var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];
    var dummyK = new kapsuleType();
    dummyK._destructor && dummyK._destructor();
    return {
      linkProp: function linkProp(prop) {
        return {
          "default": dummyK[prop](),
          onChange: function onChange(v2, state) {
            propNames.forEach(function(propName) {
              return state[propName][prop](v2);
            });
          },
          triggerUpdate: false
        };
      },
      linkMethod: function linkMethod(method) {
        return function(state) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var returnVals = [];
          propNames.forEach(function(propName) {
            var kapsuleInstance = state[propName];
            var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);
            if (returnVal !== kapsuleInstance) {
              returnVals.push(returnVal);
            }
          });
          return returnVals.length ? returnVals[0] : this;
        };
      }
    };
  }
  var HOVER_CANVAS_THROTTLE_DELAY = 800;
  var ZOOM2NODES_FACTOR = 4;
  var DRAG_CLICK_TOLERANCE_PX = 5;
  var bindFG = linkKapsule("forceGraph", CanvasForceGraph);
  var bindBoth = linkKapsule(["forceGraph", "shadowGraph"], CanvasForceGraph);
  var linkedProps = Object.assign.apply(Object, _toConsumableArray(["nodeColor", "nodeAutoColorBy", "nodeCanvasObject", "nodeCanvasObjectMode", "linkColor", "linkAutoColorBy", "linkLineDash", "linkWidth", "linkCanvasObject", "linkCanvasObjectMode", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleOffset", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleCanvasObject", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "d3AlphaMin", "d3AlphaDecay", "d3VelocityDecay", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map(function(p2) {
    return _defineProperty({}, p2, bindFG.linkProp(p2));
  })).concat(_toConsumableArray(["nodeRelSize", "nodeId", "nodeVal", "nodeVisibility", "linkSource", "linkTarget", "linkVisibility", "linkCurvature"].map(function(p2) {
    return _defineProperty({}, p2, bindBoth.linkProp(p2));
  }))));
  var linkedMethods = Object.assign.apply(Object, _toConsumableArray(["d3Force", "d3ReheatSimulation", "emitParticle"].map(function(p2) {
    return _defineProperty({}, p2, bindFG.linkMethod(p2));
  })));
  function adjustCanvasSize(state) {
    if (state.canvas) {
      var curWidth = state.canvas.width;
      var curHeight = state.canvas.height;
      if (curWidth === 300 && curHeight === 150) {
        curWidth = curHeight = 0;
      }
      var pxScale = window.devicePixelRatio;
      curWidth /= pxScale;
      curHeight /= pxScale;
      [state.canvas, state.shadowCanvas].forEach(function(canvas) {
        canvas.style.width = "".concat(state.width, "px");
        canvas.style.height = "".concat(state.height, "px");
        canvas.width = state.width * pxScale;
        canvas.height = state.height * pxScale;
        if (!curWidth && !curHeight) {
          canvas.getContext("2d").scale(pxScale, pxScale);
        }
      });
      var k2 = transform(state.canvas).k;
      state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k2, (state.height - curHeight) / 2 / k2);
      state.needsRedraw = true;
    }
  }
  function resetTransform(ctx) {
    var pxRatio = window.devicePixelRatio;
    ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);
  }
  function clearCanvas(ctx, width, height) {
    ctx.save();
    resetTransform(ctx);
    ctx.clearRect(0, 0, width, height);
    ctx.restore();
  }
  var forceGraph = index$4({
    props: _objectSpread2({
      width: {
        "default": window.innerWidth,
        onChange: function onChange(_2, state) {
          return adjustCanvasSize(state);
        },
        triggerUpdate: false
      },
      height: {
        "default": window.innerHeight,
        onChange: function onChange(_2, state) {
          return adjustCanvasSize(state);
        },
        triggerUpdate: false
      },
      graphData: {
        "default": {
          nodes: [],
          links: []
        },
        onChange: function onChange(d2, state) {
          [d2.nodes, d2.links].every(function(arr) {
            return (arr || []).every(function(d3) {
              return !d3.hasOwnProperty("__indexColor");
            });
          }) && state.colorTracker.reset();
          [{
            type: "Node",
            objs: d2.nodes
          }, {
            type: "Link",
            objs: d2.links
          }].forEach(hexIndex);
          state.forceGraph.graphData(d2);
          state.shadowGraph.graphData(d2);
          function hexIndex(_ref4) {
            var type2 = _ref4.type, objs = _ref4.objs;
            objs.filter(function(d3) {
              if (!d3.hasOwnProperty("__indexColor")) return true;
              var cur = state.colorTracker.lookup(d3.__indexColor);
              return !cur || !cur.hasOwnProperty("d") || cur.d !== d3;
            }).forEach(function(d3) {
              d3.__indexColor = state.colorTracker.register({
                type: type2,
                d: d3
              });
            });
          }
        },
        triggerUpdate: false
      },
      backgroundColor: {
        onChange: function onChange(color2, state) {
          state.canvas && color2 && (state.canvas.style.background = color2);
        },
        triggerUpdate: false
      },
      nodeLabel: {
        "default": "name",
        triggerUpdate: false
      },
      nodePointerAreaPaint: {
        onChange: function onChange(paintFn, state) {
          state.shadowGraph.nodeCanvasObject(!paintFn ? null : function(node, ctx, globalScale) {
            return paintFn(node, node.__indexColor, ctx, globalScale);
          });
          state.flushShadowCanvas && state.flushShadowCanvas();
        },
        triggerUpdate: false
      },
      linkPointerAreaPaint: {
        onChange: function onChange(paintFn, state) {
          state.shadowGraph.linkCanvasObject(!paintFn ? null : function(link, ctx, globalScale) {
            return paintFn(link, link.__indexColor, ctx, globalScale);
          });
          state.flushShadowCanvas && state.flushShadowCanvas();
        },
        triggerUpdate: false
      },
      linkLabel: {
        "default": "name",
        triggerUpdate: false
      },
      linkHoverPrecision: {
        "default": 4,
        triggerUpdate: false
      },
      minZoom: {
        "default": 0.01,
        onChange: function onChange(minZoom, state) {
          state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);
        },
        triggerUpdate: false
      },
      maxZoom: {
        "default": 1e3,
        onChange: function onChange(maxZoom, state) {
          state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);
        },
        triggerUpdate: false
      },
      enableNodeDrag: {
        "default": true,
        triggerUpdate: false
      },
      enableZoomInteraction: {
        "default": true,
        triggerUpdate: false
      },
      enablePanInteraction: {
        "default": true,
        triggerUpdate: false
      },
      enableZoomPanInteraction: {
        "default": true,
        triggerUpdate: false
      },
      // to be deprecated
      enablePointerInteraction: {
        "default": true,
        onChange: function onChange(_2, state) {
          state.hoverObj = null;
        },
        triggerUpdate: false
      },
      autoPauseRedraw: {
        "default": true,
        triggerUpdate: false
      },
      onNodeDrag: {
        "default": function _default2() {
        },
        triggerUpdate: false
      },
      onNodeDragEnd: {
        "default": function _default2() {
        },
        triggerUpdate: false
      },
      onNodeClick: {
        triggerUpdate: false
      },
      onNodeRightClick: {
        triggerUpdate: false
      },
      onNodeHover: {
        triggerUpdate: false
      },
      onLinkClick: {
        triggerUpdate: false
      },
      onLinkRightClick: {
        triggerUpdate: false
      },
      onLinkHover: {
        triggerUpdate: false
      },
      onBackgroundClick: {
        triggerUpdate: false
      },
      onBackgroundRightClick: {
        triggerUpdate: false
      },
      showPointerCursor: {
        "default": true,
        triggerUpdate: false
      },
      onZoom: {
        triggerUpdate: false
      },
      onZoomEnd: {
        triggerUpdate: false
      },
      onRenderFramePre: {
        triggerUpdate: false
      },
      onRenderFramePost: {
        triggerUpdate: false
      }
    }, linkedProps),
    aliases: {
      // Prop names supported for backwards compatibility
      stopAnimation: "pauseAnimation"
    },
    methods: _objectSpread2({
      graph2ScreenCoords: function graph2ScreenCoords(state, x2, y2) {
        var t2 = transform(state.canvas);
        return {
          x: x2 * t2.k + t2.x,
          y: y2 * t2.k + t2.y
        };
      },
      screen2GraphCoords: function screen2GraphCoords(state, x2, y2) {
        var t2 = transform(state.canvas);
        return {
          x: (x2 - t2.x) / t2.k,
          y: (y2 - t2.y) / t2.k
        };
      },
      centerAt: function centerAt(state, x2, y2, transitionDuration) {
        if (!state.canvas) return null;
        if (x2 !== void 0 || y2 !== void 0) {
          var finalPos = Object.assign({}, x2 !== void 0 ? {
            x: x2
          } : {}, y2 !== void 0 ? {
            y: y2
          } : {});
          if (!transitionDuration) {
            setCenter(finalPos);
          } else {
            state.tweenGroup.add(new Tween(getCenter()).to(finalPos, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(setCenter).start());
          }
          return this;
        }
        return getCenter();
        function getCenter() {
          var t2 = transform(state.canvas);
          return {
            x: (state.width / 2 - t2.x) / t2.k,
            y: (state.height / 2 - t2.y) / t2.k
          };
        }
        function setCenter(_ref5) {
          var x3 = _ref5.x, y3 = _ref5.y;
          state.zoom.translateTo(state.zoom.__baseElem, x3 === void 0 ? getCenter().x : x3, y3 === void 0 ? getCenter().y : y3);
          state.needsRedraw = true;
        }
      },
      zoom: function zoom2(state, k2, transitionDuration) {
        if (!state.canvas) return null;
        if (k2 !== void 0) {
          if (!transitionDuration) {
            setZoom(k2);
          } else {
            state.tweenGroup.add(new Tween({
              k: getZoom()
            }).to({
              k: k2
            }, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(function(_ref6) {
              var k3 = _ref6.k;
              return setZoom(k3);
            }).start());
          }
          return this;
        }
        return getZoom();
        function getZoom() {
          return transform(state.canvas).k;
        }
        function setZoom(k3) {
          state.zoom.scaleTo(state.zoom.__baseElem, k3);
          state.needsRedraw = true;
        }
      },
      zoomToFit: function zoomToFit(state) {
        var transitionDuration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var padding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
        for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
          bboxArgs[_key - 3] = arguments[_key];
        }
        var bbox = this.getGraphBbox.apply(this, bboxArgs);
        if (bbox) {
          var center = {
            x: (bbox.x[0] + bbox.x[1]) / 2,
            y: (bbox.y[0] + bbox.y[1]) / 2
          };
          var zoomK = Math.max(1e-12, Math.min(1e12, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));
          this.centerAt(center.x, center.y, transitionDuration);
          this.zoom(zoomK, transitionDuration);
        }
        return this;
      },
      getGraphBbox: function getGraphBbox(state) {
        var nodeFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
          return true;
        };
        var getVal = index$3(state.nodeVal);
        var getR = function getR2(node) {
          return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;
        };
        var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function(node) {
          return {
            x: node.x,
            y: node.y,
            r: getR(node)
          };
        });
        return !nodesPos.length ? null : {
          x: [min$1(nodesPos, function(node) {
            return node.x - node.r;
          }), max$1(nodesPos, function(node) {
            return node.x + node.r;
          })],
          y: [min$1(nodesPos, function(node) {
            return node.y - node.r;
          }), max$1(nodesPos, function(node) {
            return node.y + node.r;
          })]
        };
      },
      pauseAnimation: function pauseAnimation(state) {
        if (state.animationFrameRequestId) {
          cancelAnimationFrame(state.animationFrameRequestId);
          state.animationFrameRequestId = null;
        }
        return this;
      },
      resumeAnimation: function resumeAnimation(state) {
        if (!state.animationFrameRequestId) {
          this._animationCycle();
        }
        return this;
      },
      _destructor: function _destructor() {
        this.pauseAnimation();
        this.graphData({
          nodes: [],
          links: []
        });
      }
    }, linkedMethods),
    stateInit: function stateInit() {
      return {
        lastSetZoom: 1,
        zoom: zoom(),
        forceGraph: new CanvasForceGraph(),
        shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor("__indexColor").linkColor("__indexColor").isShadow(true),
        colorTracker: new _default$1(),
        // indexed objects for rgb lookup
        tweenGroup: new Group()
      };
    },
    init: function init2(domNode, state) {
      var _this = this;
      domNode.innerHTML = "";
      var container = document.createElement("div");
      container.classList.add("force-graph-container");
      container.style.position = "relative";
      domNode.appendChild(container);
      state.canvas = document.createElement("canvas");
      if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;
      container.appendChild(state.canvas);
      state.shadowCanvas = document.createElement("canvas");
      var ctx = state.canvas.getContext("2d");
      var shadowCtx = state.shadowCanvas.getContext("2d", {
        willReadFrequently: true
      });
      var pointerPos = {
        x: -1e12,
        y: -1e12
      };
      var getObjUnderPointer = function getObjUnderPointer2() {
        var obj = null;
        var pxScale = window.devicePixelRatio;
        var px = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;
        px && (obj = state.colorTracker.lookup(px.data));
        return obj;
      };
      select(state.canvas).call(drag().subject(function() {
        if (!state.enableNodeDrag) {
          return null;
        }
        var obj = getObjUnderPointer();
        return obj && obj.type === "Node" ? obj.d : null;
      }).on("start", function(ev) {
        var obj = ev.subject;
        obj.__initialDragPos = {
          x: obj.x,
          y: obj.y,
          fx: obj.fx,
          fy: obj.fy
        };
        if (!ev.active) {
          obj.fx = obj.x;
          obj.fy = obj.y;
        }
        state.canvas.classList.add("grabbable");
      }).on("drag", function(ev) {
        var obj = ev.subject;
        var initPos = obj.__initialDragPos;
        var dragPos = ev;
        var k2 = transform(state.canvas).k;
        var translate = {
          x: initPos.x + (dragPos.x - initPos.x) / k2 - obj.x,
          y: initPos.y + (dragPos.y - initPos.y) / k2 - obj.y
        };
        ["x", "y"].forEach(function(c2) {
          return obj["f".concat(c2)] = obj[c2] = initPos[c2] + (dragPos[c2] - initPos[c2]) / k2;
        });
        if (!obj.__dragged && DRAG_CLICK_TOLERANCE_PX >= Math.sqrt(sum(["x", "y"].map(function(k3) {
          return Math.pow(ev[k3] - initPos[k3], 2);
        })))) return;
        state.forceGraph.d3AlphaTarget(0.3).resetCountdown();
        state.isPointerDragging = true;
        obj.__dragged = true;
        state.onNodeDrag(obj, translate);
      }).on("end", function(ev) {
        var obj = ev.subject;
        var initPos = obj.__initialDragPos;
        var translate = {
          x: obj.x - initPos.x,
          y: obj.y - initPos.y
        };
        if (initPos.fx === void 0) {
          obj.fx = void 0;
        }
        if (initPos.fy === void 0) {
          obj.fy = void 0;
        }
        delete obj.__initialDragPos;
        if (state.forceGraph.d3AlphaTarget()) {
          state.forceGraph.d3AlphaTarget(0).resetCountdown();
        }
        state.canvas.classList.remove("grabbable");
        state.isPointerDragging = false;
        if (obj.__dragged) {
          delete obj.__dragged;
          state.onNodeDragEnd(obj, translate);
        }
      }));
      state.zoom(state.zoom.__baseElem = select(state.canvas));
      state.zoom.__baseElem.on("dblclick.zoom", null);
      state.zoom.filter(function(ev) {
        return (
          // disable zoom interaction
          !ev.button && state.enableZoomPanInteraction && (ev.type !== "wheel" || index$3(state.enableZoomInteraction)(ev)) && (ev.type === "wheel" || index$3(state.enablePanInteraction)(ev))
        );
      }).on("zoom", function(ev) {
        var t2 = ev.transform;
        [ctx, shadowCtx].forEach(function(c2) {
          resetTransform(c2);
          c2.translate(t2.x, t2.y);
          c2.scale(t2.k, t2.k);
        });
        state.isPointerDragging = true;
        state.onZoom && state.onZoom(_objectSpread2(_objectSpread2({}, t2), _this.centerAt()));
        state.needsRedraw = true;
      }).on("end", function(ev) {
        state.isPointerDragging = false;
        state.onZoomEnd && state.onZoomEnd(_objectSpread2(_objectSpread2({}, ev.transform), _this.centerAt()));
      });
      adjustCanvasSize(state);
      state.forceGraph.onNeedsRedraw(function() {
        return state.needsRedraw = true;
      }).onFinishUpdate(function() {
        if (transform(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {
          state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));
          state.needsRedraw = true;
        }
      });
      state.tooltip = new index$2(container);
      ["pointermove", "pointerdown"].forEach(function(evType) {
        return container.addEventListener(evType, function(ev) {
          if (evType === "pointerdown") {
            state.isPointerPressed = true;
            state.pointerDownEvent = ev;
          }
          !state.isPointerDragging && ev.type === "pointermove" && state.onBackgroundClick && (ev.pressure > 0 || state.isPointerPressed) && (ev.pointerType === "mouse" || ev.movementX === void 0 || [ev.movementX, ev.movementY].some(function(m2) {
            return Math.abs(m2) > 1;
          })) && (state.isPointerDragging = true);
          var offset = getOffset(container);
          pointerPos.x = ev.pageX - offset.left;
          pointerPos.y = ev.pageY - offset.top;
          function getOffset(el) {
            var rect = el.getBoundingClientRect(), scrollLeft = window.pageXOffset || document.documentElement.scrollLeft, scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            return {
              top: rect.top + scrollTop,
              left: rect.left + scrollLeft
            };
          }
        }, {
          passive: true
        });
      });
      container.addEventListener("pointerup", function(ev) {
        if (!state.isPointerPressed) {
          return;
        }
        state.isPointerPressed = false;
        if (state.isPointerDragging) {
          state.isPointerDragging = false;
          return;
        }
        var cbEvents = [ev, state.pointerDownEvent];
        requestAnimationFrame(function() {
          if (ev.button === 0) {
            if (state.hoverObj) {
              var fn = state["on".concat(state.hoverObj.type, "Click")];
              fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));
            } else {
              state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);
            }
          }
          if (ev.button === 2) {
            if (state.hoverObj) {
              var _fn = state["on".concat(state.hoverObj.type, "RightClick")];
              _fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));
            } else {
              state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);
            }
          }
        });
      }, {
        passive: true
      });
      container.addEventListener("contextmenu", function(ev) {
        if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true;
        ev.preventDefault();
        return false;
      });
      state.forceGraph(ctx);
      state.shadowGraph(shadowCtx);
      var refreshShadowCanvas = throttle(function() {
        clearCanvas(shadowCtx, state.width, state.height);
        state.shadowGraph.linkWidth(function(l2) {
          return index$3(state.linkWidth)(l2) + state.linkHoverPrecision;
        });
        var t2 = transform(state.canvas);
        state.shadowGraph.globalScale(t2.k).tickFrame();
      }, HOVER_CANVAS_THROTTLE_DELAY);
      state.flushShadowCanvas = refreshShadowCanvas.flush;
      (this._animationCycle = function animate() {
        var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function(d2) {
          return d2.__photons && d2.__photons.length;
        });
        state.needsRedraw = false;
        if (state.enablePointerInteraction) {
          var obj = !state.isPointerDragging ? getObjUnderPointer() : null;
          if (obj !== state.hoverObj) {
            var prevObj = state.hoverObj;
            var prevObjType = prevObj ? prevObj.type : null;
            var objType = obj ? obj.type : null;
            if (prevObjType && prevObjType !== objType) {
              var fn = state["on".concat(prevObjType, "Hover")];
              fn && fn(null, prevObj.d);
            }
            if (objType) {
              var _fn2 = state["on".concat(objType, "Hover")];
              _fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);
            }
            state.tooltip.content(obj ? index$3(state["".concat(obj.type.toLowerCase(), "Label")])(obj.d) || null : null);
            state.canvas.classList[(obj && state["on".concat(objType, "Click")] || !obj && state.onBackgroundClick) && index$3(state.showPointerCursor)(obj === null || obj === void 0 ? void 0 : obj.d) ? "add" : "remove"]("clickable");
            state.hoverObj = obj;
          }
          doRedraw && refreshShadowCanvas();
        }
        if (doRedraw) {
          clearCanvas(ctx, state.width, state.height);
          var globalScale = transform(state.canvas).k;
          state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);
          state.forceGraph.globalScale(globalScale).tickFrame();
          state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);
        }
        state.tweenGroup.update();
        state.animationFrameRequestId = requestAnimationFrame(animate);
      })();
    },
    update: function updateFn(state) {
    }
  });
  /*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT */
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [sequence];
  }
  function extend(target, source) {
    var index2, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
        key = sourceKeys[index2];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  var isNothing_1 = isNothing;
  var isObject_1 = isObject;
  var toArray_1 = toArray;
  var repeat_1 = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend;
  var common = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
  };
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark) return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException$1(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;
  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  var exception = YAMLException$1;
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "â†’") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string, max2) {
    return common.repeat(" ", max2 - string.length) + string;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== "number") options.indent = 1;
    if (typeof options.linesBefore !== "number") options.linesBefore = 3;
    if (typeof options.linesAfter !== "number") options.linesAfter = 2;
    var re = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = "", i2, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i2 = 1; i2 <= options.linesBefore; i2++) {
      if (foundLineNo - i2 < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i2],
        lineEnds[foundLineNo - i2],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
        maxLineLength
      );
      result = common.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
    for (i2 = 1; i2 <= options.linesAfter; i2++) {
      if (foundLineNo + i2 >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i2],
        lineEnds[foundLineNo + i2],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
        maxLineLength
      );
      result += common.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  var snippet = makeSnippet;
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    if (map2 !== null) {
      Object.keys(map2).forEach(function(style) {
        map2[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type$1(tag2, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag2 + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag2;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag2 + '" YAML type.');
    }
  }
  var type = Type$1;
  function compileList(schema2, name) {
    var result = [];
    schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index2, length;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
      arguments[index2].forEach(collectType);
    }
    return result;
  }
  function Schema$1(definition) {
    return this.extend(definition);
  }
  Schema$1.prototype.extend = function extend2(definition) {
    var implicit2 = [];
    var explicit = [];
    if (definition instanceof type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit) implicit2 = implicit2.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
      throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit2.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type$1.loadKind && type$1.loadKind !== "scalar") {
        throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type$1.multi) {
        throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit2);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  var schema = Schema$1;
  var str = new type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  var seq = new type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  var map = new type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });
  function resolveYamlNull(data) {
    if (data === null) return true;
    var max2 = data.length;
    return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  var _null = new type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max2 = data.length;
    return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  var bool = new type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max2 = data.length, index2 = 0, hasDigits = false, ch;
    if (!max2) return false;
    ch = data[index2];
    if (ch === "-" || ch === "+") {
      ch = data[++index2];
    }
    if (ch === "0") {
      if (index2 + 1 === max2) return true;
      ch = data[++index2];
      if (ch === "b") {
        index2++;
        for (; index2 < max2; index2++) {
          ch = data[index2];
          if (ch === "_") continue;
          if (ch !== "0" && ch !== "1") return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index2++;
        for (; index2 < max2; index2++) {
          ch = data[index2];
          if (ch === "_") continue;
          if (!isHexCode(data.charCodeAt(index2))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index2++;
        for (; index2 < max2; index2++) {
          ch = data[index2];
          if (ch === "_") continue;
          if (!isOctCode(data.charCodeAt(index2))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_") return false;
    for (; index2 < max2; index2++) {
      ch = data[index2];
      if (ch === "_") continue;
      if (!isDecCode(data.charCodeAt(index2))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_") return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-") sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
      if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  var int = new type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  var float = new type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });
  var core = json;
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var timestamp = new type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  var merge = new type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++) {
      code = map2.indexOf(data.charAt(idx));
      if (code > 64) continue;
      if (code < 0) return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map2.indexOf(input.charAt(idx));
    }
    tailbits = max2 % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max2 % 3;
    if (tail === 0) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    } else if (tail === 2) {
      result += map2[bits >> 10 & 63];
      result += map2[bits >> 4 & 63];
      result += map2[bits << 2 & 63];
      result += map2[64];
    } else if (tail === 1) {
      result += map2[bits >> 2 & 63];
      result += map2[bits << 4 & 63];
      result += map2[64];
      result += map2[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  var binary = new type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2 = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
    for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
      pair = object[index2];
      pairHasKey = false;
      if (_toString$2.call(pair) !== "[object Object]") return false;
      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }
      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  var omap = new type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  var _toString$1 = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index2, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
      pair = object[index2];
      if (_toString$1.call(pair) !== "[object Object]") return false;
      keys = Object.keys(pair);
      if (keys.length !== 1) return false;
      result[index2] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index2, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
      pair = object[index2];
      keys = Object.keys(pair);
      result[index2] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  var pairs = new type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  var set = new type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });
  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc;
    if (48 <= c2 && c2 <= 57) {
      return c2 - 48;
    }
    lc = c2 | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c2) {
    if (c2 === 120) {
      return 2;
    }
    if (c2 === 117) {
      return 4;
    }
    if (c2 === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c2) {
    if (48 <= c2 && c2 <= 57) {
      return c2 - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "Â…" : c2 === 95 ? "Â " : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    if (c2 <= 65535) {
      return String.fromCharCode(c2);
    }
    return String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  function setProperty(object, key, value) {
    if (key === "__proto__") {
      Object.defineProperty(object, key, {
        configurable: true,
        enumerable: true,
        writable: true,
        value
      });
    } else {
      object[key] = value;
    }
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  function State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || _default;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start2, end, checkJson) {
    var _position, _length, _character, _result;
    if (start2 < end) {
      _result = state.input.slice(start2, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index2, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
      key = sourceKeys[index2];
      if (!_hasOwnProperty$1.call(destination, key)) {
        setProperty(destination, key, source[key]);
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index2, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
        if (Array.isArray(keyNode[index2])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
          keyNode[index2] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
          mergeMappings(state, _result, valueNode[index2], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      setProperty(_result, keyNode, valueNode);
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat("\n", emptyLines);
        }
      } else {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33) return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38) return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type2 = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = /* @__PURE__ */ Object.create(null);
    state.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0) readLineBreak(state);
      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
      iterator(documents[index2]);
    }
  }
  function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception("expected a single document in the stream, but found more");
  }
  var loadAll_1 = loadAll$1;
  var load_1 = load$1;
  var loader = {
    loadAll: loadAll_1,
    load: load_1
  };
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys, index2, length, tag2, style, type2;
    if (map2 === null) return {};
    result = {};
    keys = Object.keys(map2);
    for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
      tag2 = keys[index2];
      style = String(map2[tag2]);
      if (tag2.slice(0, 2) === "!!") {
        tag2 = "tag:yaml.org,2002:" + tag2.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag2];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag2] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || _default;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n") result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index2, length, type2;
    for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
      type2 = state.implicitTypes[index2];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
  }
  function isNsCharOrWhitespace(c2) {
    return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c2, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c2) {
    return !isWhitespace(c2) && c2 !== CHAR_COLON;
  }
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i2;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
        char = codePointAt(string, i2);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
        char = codePointAt(string, i2);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i2;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function() {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(
        string,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new exception("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    var breakRe = / [^ ]/g;
    var match;
    var start2 = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start2 > width) {
        end = curr > start2 ? curr : next;
        result += "\n" + line.slice(start2, end);
        start2 = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start2 > width && curr > start2) {
      result += line.slice(start2, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start2);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string[i2];
        if (char >= 65536) result += string[i2 + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index2, length, value;
    for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
      value = object[index2];
      if (state.replacer) {
        value = state.replacer.call(object, String(index2), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index2, length, value;
    for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
      value = object[index2];
      if (state.replacer) {
        value = state.replacer.call(object, String(index2), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
    for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
      pairBuffer = "";
      if (_result !== "") pairBuffer += ", ";
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index2];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024) pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new exception("sortKeys must be a boolean or a function");
    }
    for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index2];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index2, length, type2, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
      type2 = typeList[index2];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state.tag = type2.representName(object);
          } else {
            state.tag = type2.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type2.represent) {
          style = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type2 = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(
          state.tag[0] === "!" ? state.tag.slice(1) : state.tag
        ).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index2, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index2]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index2, length;
    if (object !== null && typeof object === "object") {
      index2 = objects.indexOf(object);
      if (index2 !== -1) {
        if (duplicatesIndexes.indexOf(index2) === -1) {
          duplicatesIndexes.push(index2);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
            inspectNode(object[index2], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
            inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump$1(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
    return "";
  }
  var dump_1 = dump$1;
  var dumper = {
    dump: dump_1
  };
  function renamed(from, to) {
    return function() {
      throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  var Type = type;
  var Schema = schema;
  var FAILSAFE_SCHEMA = failsafe;
  var JSON_SCHEMA = json;
  var CORE_SCHEMA = core;
  var DEFAULT_SCHEMA = _default;
  var load = loader.load;
  var loadAll = loader.loadAll;
  var dump = dumper.dump;
  var YAMLException = exception;
  var types = {
    binary,
    float,
    map,
    null: _null,
    pairs,
    set,
    timestamp,
    bool,
    int,
    merge,
    omap,
    seq,
    str
  };
  var safeLoad = renamed("safeLoad", "load");
  var safeLoadAll = renamed("safeLoadAll", "loadAll");
  var safeDump = renamed("safeDump", "dump");
  var jsYaml = {
    Type,
    Schema,
    FAILSAFE_SCHEMA,
    JSON_SCHEMA,
    CORE_SCHEMA,
    DEFAULT_SCHEMA,
    load,
    loadAll,
    dump,
    YAMLException,
    types,
    safeLoad,
    safeLoadAll,
    safeDump
  };
  let conn = null;
  let masterFileList = [];
  let folderTree = {};
  let tagTree = {};
  let currentView = "folders";
  let currentPath = null;
  let selectedFolderPath = "";
  let isReadingMode = false;
  let panelState = { graph: true, backlinks: true };
  let currentList = [];
  let renderedCount = 0;
  let graphInstance = null;
  let easyMDE = null;
  let ctxTarget = "";
  let ctxTargetType = null;
  let currentYamlData = null;
  let contentWithoutYaml = "";
  let navigationHistory = [];
  function showWelcomeScreen() {
    const preview = document.getElementById("custom-preview");
    if (!preview) return;
    const welcomeHTML = `
        <div style="padding: 40px; max-width: 700px; margin: 0 auto;">
            <h1 style="color: var(--interactive-accent); margin-bottom: 10px;">
                <i class="fa-solid fa-satellite-dish"></i> Welcome to Note Relay
            </h1>
            <p style="color: var(--text-muted); font-size: 0.95em; margin-bottom: 30px;">
                Remote access to your Obsidian vault from anywhere
            </p>
            
            <h2 style="color: var(--text-normal); margin-top: 30px;">ðŸš€ Getting Started</h2>
            <ul style="line-height: 1.8;">
                <li><strong>Select a note</strong> from the file tree on the left to start reading</li>
                <li><strong>Create new notes</strong> using the <i class="fa-regular fa-file-lines"></i> button</li>
                <li><strong>Toggle edit mode</strong> with the <i class="fa-regular fa-eye"></i> button in the toolbar</li>
                <li><strong>Search notes</strong> using the filter box above the note list</li>
            </ul>
            
            <h2 style="color: var(--text-normal); margin-top: 30px;">âŒ¨ï¸ Keyboard Shortcuts</h2>
            <ul style="line-height: 1.8;">
                <li><kbd>Cmd/Ctrl + S</kbd> - Save current note</li>
                <li><kbd>Cmd/Ctrl + K</kbd> - Create link in editor</li>
                <li><kbd>Escape</kbd> - Close menus</li>
            </ul>
            
            <h2 style="color: var(--text-normal); margin-top: 30px;">âœ¨ Features</h2>
            <ul style="line-height: 1.8;">
                <li><strong>Live Preview</strong> - High-fidelity markdown rendering</li>
                <li><strong>Local Graph</strong> - Visualize note connections</li>
                <li><strong>Backlinks</strong> - See which notes link to the current note</li>
                <li><strong>Full Editing</strong> - Create, rename, delete files and folders</li>
                <li><strong>Theme Support</strong> - Uses your Obsidian theme CSS</li>
            </ul>
            
            <p style="margin-top: 40px; padding: 20px; background: var(--background-secondary); border-radius: 8px; border-left: 4px solid var(--interactive-accent);">
                <strong>ðŸ’¡ Tip:</strong> Right-click on files and folders for additional options
            </p>
        </div>
    `;
    preview.innerHTML = welcomeHTML;
    preview.style.display = "block";
    const editorEl = document.querySelector(".EasyMDEContainer");
    const loading = document.getElementById("preview-loading");
    const viewBtn = document.getElementById("view-btn");
    const saveBtn = document.getElementById("save-btn");
    if (editorEl) editorEl.style.display = "none";
    if (loading) loading.style.display = "none";
    if (viewBtn) viewBtn.style.display = "none";
    if (saveBtn) saveBtn.style.display = "none";
  }
  function initApp() {
    console.log("ðŸš€ Note Relay V2 Bundle Loaded - Build: Production");
    console.log("âœ… Initializing Note Relay UI");
    conn = new LocalConnection();
    const savedPanels = localStorage.getItem("panelState");
    if (savedPanels) {
      panelState = JSON.parse(savedPanels);
      applyPanelState();
    }
    setupEventListeners();
    setTimeout(() => {
      easyMDE = initEditor("editor");
      if (!easyMDE) {
        console.error("âŒ Failed to initialize EasyMDE editor");
      } else {
        console.log("âœ… EasyMDE editor initialized");
      }
      showWelcomeScreen();
    }, 100);
    conn.onMessage = handleMessage;
    initSidebarResize();
    updateIcons();
    console.log("âœ… App initialization complete");
  }
  function setupEventListeners() {
    const btn = document.getElementById("connect-btn");
    const passwordInput = document.getElementById("password-input");
    if (btn) btn.addEventListener("click", connectToVault);
    if (passwordInput) {
      passwordInput.focus();
      passwordInput.addEventListener("keydown", (e2) => {
        if (e2.key === "Enter") connectToVault();
      });
    }
    window.addEventListener("mousedown", (e2) => {
      const menu = document.getElementById("context-menu");
      if (menu && menu.style.display === "block" && !e2.target.closest(".context-menu")) {
        menu.style.display = "none";
      }
    }, true);
    window.addEventListener("blur", () => {
      const menu = document.getElementById("context-menu");
      if (menu) menu.style.display = "none";
    });
    window.addEventListener("keydown", (e2) => {
      if (e2.key === "Escape") {
        const menu = document.getElementById("context-menu");
        if (menu) menu.style.display = "none";
      }
    });
    document.addEventListener("contextmenu", handleContextMenuDisplay);
    document.addEventListener("click", handleDocumentClick);
    document.addEventListener("keydown", (e2) => {
      if ((e2.ctrlKey || e2.metaKey) && e2.key === "s") {
        e2.preventDefault();
        saveFile();
      }
    });
  }
  async function handleDocumentClick(e2) {
    var _a, _b;
    if (e2.target.type === "checkbox" && e2.target.closest("#custom-preview")) {
      e2.preventDefault();
      e2.stopPropagation();
      if (e2.target.classList.contains("dataview")) {
        return;
      }
      await handleCheckboxClick(e2.target);
      return;
    }
    if (e2.target.classList.contains("internal-link")) {
      e2.preventDefault();
      let target = e2.target.getAttribute("href");
      if (!target.endsWith(".md")) target = target + ".md";
      loadFile(target);
      return;
    }
    if (e2.target.classList.contains("tag")) {
      e2.preventDefault();
      const tagName = ((_a = e2.target.getAttribute("href")) == null ? void 0 : _a.replace("#", "")) || e2.target.textContent.replace("#", "");
      if (tagName) {
        currentView = "tags";
        document.querySelectorAll(".tab").forEach((t2) => t2.classList.remove("active"));
        document.getElementById("tab-tags").classList.add("active");
        renderSidebar();
        const tagNode = (_b = tagTree._sub) == null ? void 0 : _b[tagName];
        if (tagNode && tagNode._files) {
          prepareNoteList(tagNode._files);
          setTimeout(() => {
            document.querySelectorAll(".tree-label").forEach((label) => {
              if (label.textContent.includes(tagName)) {
                label.classList.add("selected");
              }
            });
          }, 100);
        }
      }
      return;
    }
    if (e2.target.closest(".dataview-container") || e2.target.closest(".block-language-dataview")) {
      e2.preventDefault();
      return;
    }
  }
  async function handleCheckboxClick(checkbox) {
    var _a, _b;
    if (window._checkboxSaveInProgress) {
      console.log("â³ Checkbox save already in progress, skipping...");
      checkbox.checked = !checkbox.checked;
      return;
    }
    window._checkboxSaveInProgress = true;
    const newCheckedState = checkbox.checked;
    const listItem = checkbox.closest("li");
    if (listItem && currentPath) {
      const file = masterFileList.find((f2) => f2.path === currentPath);
      if (file) {
        try {
          console.log("ðŸ“ Checkbox clicked, fetching file content...");
          const result = await conn.send("GET_FILE", { path: currentPath });
          let content = ((_a = result.data) == null ? void 0 : _a.data) || ((_b = result.data) == null ? void 0 : _b.content) || result.data;
          if (typeof content !== "string") {
            console.error("Content is not a string");
            checkbox.checked = !checkbox.checked;
            window._checkboxSaveInProgress = false;
            return;
          }
          const taskRegex = /^(\s*[-*+]\s+\[)([xX\s])(\])/gm;
          let checkboxIndex = 0;
          const allCheckboxes = Array.from(document.querySelectorAll('#custom-preview input[type="checkbox"]'));
          const normalCheckboxes = allCheckboxes.filter((cb) => !cb.classList.contains("dataview"));
          const targetIndex = normalCheckboxes.indexOf(checkbox);
          console.log(`ðŸŽ¯ Target checkbox index: ${targetIndex} of ${normalCheckboxes.length} normal checkboxes`);
          let found = false;
          content = content.replace(taskRegex, (match, prefix, status, suffix) => {
            if (checkboxIndex === targetIndex) {
              found = true;
              const newStatus = newCheckedState ? "x" : " ";
              console.log(`âœï¸ Updating checkbox ${checkboxIndex}: [${status}] â†’ [${newStatus}]`);
              checkboxIndex++;
              return prefix + newStatus + suffix;
            }
            checkboxIndex++;
            return match;
          });
          if (!found) {
            console.error("âŒ Checkbox not found in content");
            checkbox.checked = !checkbox.checked;
            window._checkboxSaveInProgress = false;
            return;
          }
          const preview = document.getElementById("custom-preview");
          const scrollPos = preview ? preview.scrollTop : 0;
          console.log(`ðŸ“ Saving scroll position BEFORE save: ${scrollPos}`);
          window._savedScrollPosition = scrollPos;
          window._isCheckboxUpdate = true;
          console.log("ðŸ’¾ Saving checkbox state...");
          await conn.send("SAVE_FILE", { path: currentPath, data: content });
          console.log("âœ… Checkbox saved, refreshing preview...");
          if (isReadingMode) {
            await new Promise((resolve) => setTimeout(resolve, 100));
            await conn.send("GET_RENDERED_FILE", { path: currentPath });
          } else {
            if (easyMDE) {
              const cursorPos = easyMDE.codemirror.getCursor();
              easyMDE.value(content);
              easyMDE.codemirror.setCursor(cursorPos);
            }
          }
          console.log("ðŸŽ‰ Checkbox update complete!");
        } catch (err) {
          console.error("âŒ Failed to save checkbox state:", err);
          checkbox.checked = !checkbox.checked;
        } finally {
          window._checkboxSaveInProgress = false;
        }
      }
    } else {
      window._checkboxSaveInProgress = false;
    }
  }
  async function connectToVault() {
    const btn = document.getElementById("connect-btn");
    const pass = document.getElementById("password-input").value;
    if (!pass) {
      alert("Password required");
      return;
    }
    btn.disabled = true;
    btn.innerText = "Connecting...";
    try {
      const onStatusUpdate = (msg) => {
        document.getElementById("status-text").innerText = msg;
      };
      await conn.connect(pass, onStatusUpdate);
    } catch (error) {
      if (error.message === "Authentication required") {
        log("Session expired. Please log in to the dashboard first.");
        btn.innerText = "Login Required";
      } else {
        log("Connection Error: " + error.message);
        btn.innerText = "Retry";
      }
      btn.disabled = false;
      console.error("Connection error:", error);
    }
  }
  function handleMessage(msg) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    console.log("ðŸŽ¯ Message received:", msg.type);
    if (msg.type === "CONNECTED") {
      document.getElementById("connect-overlay").style.display = "none";
      document.getElementById("app-container").classList.add("active");
      initSidebarResize();
      setTimeout(async () => {
        await conn.send("GET_TREE");
      }, 200);
      return;
    }
    if (msg.type === "TREE") {
      console.log("ðŸ“Š TREE data received:", {
        hasData: !!msg.data,
        fileCount: (_b = (_a = msg.data) == null ? void 0 : _a.files) == null ? void 0 : _b.length,
        folderCount: (_d = (_c = msg.data) == null ? void 0 : _c.folders) == null ? void 0 : _d.length,
        hasCss: !!((_e = msg.data) == null ? void 0 : _e.css)
      });
      if (masterFileList.length === 0) {
        document.getElementById("connect-overlay").style.display = "none";
        document.getElementById("app-container").classList.add("active");
        initSidebarResize();
      }
      if (msg.data.css) {
        applyTheme(msg.data.css);
      }
      const result = processFileData(msg.data);
      console.log("ðŸ“Š Processed data:", {
        masterFileListCount: result.masterFileList.length,
        folderTreeFiles: (_f = result.folderTree._files) == null ? void 0 : _f.length,
        tagTreeCount: Object.keys(result.tagTree).length
      });
      masterFileList.length === 0;
      masterFileList = result.masterFileList;
      folderTree = result.folderTree;
      tagTree = result.tagTree;
      console.log("ðŸŽ¨ Rendering sidebar and note list");
      renderSidebar();
      prepareNoteList(folderTree._files.length > 0 ? folderTree._files : masterFileList.slice(0, 100));
      return;
    }
    if (msg.type === "FILE") {
      const filePath = ((_g = msg.meta) == null ? void 0 : _g.path) || msg.path;
      const content = msg.data.data || msg.data;
      console.log("ðŸ“„ Loading file:", filePath, "Current mode:", isReadingMode ? "READ" : "EDIT");
      easyMDE.value(content);
      easyMDE.codemirror.clearHistory();
      if (window._yamlSaveInProgress || window._checkboxSaveInProgress) {
        console.log("â¸ï¸ Save in progress, content loaded for processing");
        return;
      }
      if (isReadingMode) {
        const loading = document.getElementById("preview-loading");
        const preview = document.getElementById("custom-preview");
        if (loading) loading.style.display = "flex";
        if (preview) preview.style.display = "none";
        toggleViewMode();
        setTimeout(() => toggleViewMode(), 50);
      } else {
        if (easyMDE) easyMDE.codemirror.refresh();
      }
      renderBacklinks(msg.data.backlinks);
      if (panelState.graph) renderLocalGraph(filePath);
      return;
    }
    if (msg.type === "RENDERED_FILE") {
      const isCheckboxUpdate = window._savedScrollPosition !== void 0;
      if (isCheckboxUpdate) {
        console.log("ðŸ“ RENDERED_FILE from checkbox update, will preserve scroll");
      }
      if (msg.data.files) {
        const result = processFileData({ files: msg.data.files });
        masterFileList = result.masterFileList;
        folderTree = result.folderTree;
        tagTree = result.tagTree;
      }
      if (msg.data.css) {
        applyTheme(msg.data.css);
      }
      currentYamlData = msg.data.yaml;
      if (currentYamlData && !contentWithoutYaml && easyMDE) {
        const editorContent = easyMDE.value();
        const yamlMatch = editorContent.match(/^---\n[\s\S]*?\n---\n?/);
        if (yamlMatch) {
          contentWithoutYaml = editorContent.slice(yamlMatch[0].length);
        } else {
          contentWithoutYaml = editorContent;
        }
      }
      renderYamlProperties(msg.data.yaml, ((_h = msg.meta) == null ? void 0 : _h.path) || msg.path);
      const preserveScroll = window._isCheckboxUpdate === true;
      console.log(`ðŸ” RENDERED_FILE: preserveScroll=${preserveScroll}, savedPos=${window._savedScrollPosition}`);
      renderPreview(msg.data.html, preserveScroll);
      renderBacklinks(msg.data.backlinks || []);
      const renderedPath = ((_i = msg.meta) == null ? void 0 : _i.path) || msg.path;
      if (panelState.graph && renderedPath) renderLocalGraph(renderedPath);
      return;
    }
  }
  function applyTheme(css) {
    console.log("ðŸŽ¨ APPLY THEME - START");
    let styleTag = document.getElementById("obsidian-theme-vars");
    if (!styleTag) {
      styleTag = document.createElement("style");
      styleTag.id = "obsidian-theme-vars";
      document.head.appendChild(styleTag);
    }
    styleTag.textContent = css;
    console.log("ðŸ“ CSS injected, length:", css.length);
    document.body.offsetHeight;
    setTimeout(() => {
      applyThemeToElements();
      console.log("âœ… APPLY THEME - COMPLETE");
    }, 50);
  }
  function applyThemeToElements() {
    const root2 = document.documentElement;
    const primaryBg = getComputedStyle(root2).getPropertyValue("--background-primary").trim();
    const secondaryBg = getComputedStyle(root2).getPropertyValue("--background-secondary").trim();
    const secondaryAltBg = getComputedStyle(root2).getPropertyValue("--background-secondary-alt").trim();
    const textNormal = getComputedStyle(root2).getPropertyValue("--text-normal").trim();
    const textMuted = getComputedStyle(root2).getPropertyValue("--text-muted").trim();
    getComputedStyle(root2).getPropertyValue("--text-faint").trim();
    const textAccent = getComputedStyle(root2).getPropertyValue("--text-accent").trim();
    getComputedStyle(root2).getPropertyValue("--text-accent-hover").trim();
    const borderColor = getComputedStyle(root2).getPropertyValue("--background-modifier-border").trim();
    const hoverBg = getComputedStyle(root2).getPropertyValue("--background-modifier-hover").trim();
    const interactiveAccent = getComputedStyle(root2).getPropertyValue("--interactive-accent").trim();
    console.log("ðŸŽ¨ Applying comprehensive theme...");
    console.log("Border color extracted:", borderColor);
    console.log("Hover background extracted:", hoverBg);
    if (borderColor) {
      document.querySelectorAll("#sidebar, #pane-notes, #local-graph-container, #app-ribbon").forEach((el) => {
        el.style.setProperty("border-right", `1px solid ${borderColor}`, "important");
      });
      document.querySelectorAll(".brand-header, .explorer-toolbar, .context-header, #editor-header, .pane-header, .search-box-container").forEach((el) => {
        el.style.setProperty("border-bottom", `1px solid ${borderColor}`, "important");
      });
      document.querySelectorAll("#context-panel").forEach((el) => {
        el.style.setProperty("border-top", `1px solid ${borderColor}`, "important");
      });
    }
    if (primaryBg) {
      document.querySelectorAll("body, #content-area, #main-content, #custom-preview, #graph-canvas, #local-graph-container").forEach((el) => {
        el.style.setProperty("background", primaryBg, "important");
      });
    }
    if (secondaryBg) {
      document.querySelectorAll("#sidebar, #sidebar-tree-area, #note-list-container, .pane-header, .explorer-toolbar").forEach((el) => {
        el.style.setProperty("background", secondaryBg, "important");
      });
    }
    if (textNormal) {
      document.querySelectorAll(".tree-text, .note-card, .note-title, #sidebar-tree-area, #note-list-container, .brand-header, #filename").forEach((el) => {
        el.style.setProperty("color", textNormal, "important");
      });
    }
    if (textMuted && textNormal && hoverBg) {
      document.querySelectorAll(".nav-btn, .header-btn, .ribbon-btn").forEach((btn) => {
        btn.style.setProperty("color", textMuted, "important");
        btn.addEventListener("mouseenter", () => {
          btn.style.setProperty("color", textNormal, "important");
          btn.style.setProperty("background-color", hoverBg, "important");
        });
        btn.addEventListener("mouseleave", () => {
          if (!btn.classList.contains("active")) {
            btn.style.setProperty("color", textMuted, "important");
            btn.style.setProperty("background-color", "transparent", "important");
          }
        });
      });
      document.querySelectorAll(".header-btn i, .nav-btn i, .ribbon-btn i, .tree-icon, .tree-icon i, .brand-header i").forEach((el) => {
        el.style.setProperty("color", "inherit", "important");
      });
    }
    if (textMuted && textNormal && hoverBg) {
      document.querySelectorAll(".file-tree-item").forEach((item) => {
        item.style.setProperty("color", textMuted, "important");
        item.addEventListener("mouseenter", () => {
          item.style.setProperty("color", textNormal, "important");
          item.style.setProperty("background-color", hoverBg, "important");
        });
        item.addEventListener("mouseleave", () => {
          item.style.setProperty("color", textMuted, "important");
          item.style.setProperty("background-color", "transparent", "important");
        });
      });
    }
    if (textMuted && textAccent) {
      document.querySelectorAll(".tab").forEach((tab) => {
        if (tab.classList.contains("active")) {
          tab.style.setProperty("color", textAccent, "important");
          tab.style.setProperty("border-bottom-color", textAccent, "important");
        } else {
          tab.style.setProperty("color", textMuted, "important");
        }
      });
    }
    if (secondaryBg && borderColor) {
      document.querySelectorAll(".context-menu").forEach((el) => {
        el.style.setProperty("background-color", secondaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
      });
    }
    if (textNormal && hoverBg) {
      document.querySelectorAll(".menu-item").forEach((item) => {
        item.style.setProperty("color", textNormal, "important");
        item.addEventListener("mouseenter", () => {
          item.style.setProperty("background-color", hoverBg, "important");
        });
        item.addEventListener("mouseleave", () => {
          item.style.setProperty("background-color", "transparent", "important");
        });
      });
    }
    if (borderColor) {
      document.querySelectorAll(".menu-separator").forEach((el) => {
        el.style.setProperty("background-color", borderColor, "important");
      });
    }
    if (textAccent) {
      document.querySelectorAll(".header-btn.active, .nav-btn.active").forEach((el) => {
        el.style.setProperty("color", textAccent, "important");
      });
    }
    if (interactiveAccent || textAccent) {
      document.querySelectorAll(".note-card.active").forEach((el) => {
        el.style.setProperty("background-color", interactiveAccent || textAccent, "important");
        el.style.setProperty("color", primaryBg || "#ffffff", "important");
      });
    }
    if (interactiveAccent) {
      document.querySelectorAll(".save-btn, #save-btn").forEach((el) => {
        el.style.setProperty("background-color", interactiveAccent, "important");
        el.style.setProperty("color", "#ffffff", "important");
      });
    }
    if (textNormal) {
      document.querySelectorAll("#custom-preview, #custom-preview p, #custom-preview li, #custom-preview td, .property-value, .yaml-content").forEach((el) => {
        el.style.setProperty("color", textNormal, "important");
      });
    }
    if (textNormal) {
      document.querySelectorAll("#custom-preview h1, #custom-preview h2, #custom-preview h3, #custom-preview h4, #custom-preview h5, #custom-preview h6").forEach((el) => {
        el.style.setProperty("color", textNormal, "important");
      });
    }
    if (textAccent) {
      document.querySelectorAll("#custom-preview a, .internal-link").forEach((el) => {
        el.style.setProperty("color", textAccent, "important");
      });
    }
    if (secondaryAltBg && textNormal) {
      document.querySelectorAll("#custom-preview pre, #custom-preview code").forEach((el) => {
        el.style.setProperty("background-color", secondaryAltBg, "important");
        el.style.setProperty("color", textNormal, "important");
      });
    }
    if (borderColor) {
      document.querySelectorAll("#custom-preview table, #custom-preview th, #custom-preview td").forEach((el) => {
        el.style.setProperty("border-color", borderColor, "important");
      });
    }
    if (secondaryAltBg) {
      document.querySelectorAll("#custom-preview th").forEach((el) => {
        el.style.setProperty("background-color", secondaryAltBg, "important");
      });
    }
    if (textMuted && borderColor) {
      document.querySelectorAll("#custom-preview blockquote").forEach((el) => {
        el.style.setProperty("color", textMuted, "important");
        el.style.setProperty("border-left-color", borderColor, "important");
      });
    }
    if (borderColor) {
      document.querySelectorAll(".pane-header, .brand-header, .explorer-toolbar, #editor-header, .note-card, #sidebar, #local-graph-container, #backlinks-container, .context-header, #app-ribbon, .resize-handle").forEach((el) => {
        el.style.setProperty("border-color", borderColor, "important");
      });
    }
    if (secondaryBg && borderColor) {
      document.querySelectorAll(".yaml-properties-container").forEach((el) => {
        el.style.setProperty("background-color", secondaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
      });
    }
    if (secondaryBg && textNormal && borderColor) {
      document.querySelectorAll(".yaml-header").forEach((el) => {
        el.style.setProperty("background-color", secondaryBg, "important");
        el.style.setProperty("color", textNormal, "important");
        el.style.setProperty("border-bottom", `1px solid ${borderColor}`, "important");
      });
    }
    if (textMuted) {
      document.querySelectorAll(".yaml-key").forEach((el) => {
        el.style.setProperty("color", textMuted, "important");
      });
    }
    if (primaryBg && borderColor && textNormal) {
      document.querySelectorAll('.yaml-value input[type="text"], .yaml-value input[type="date"], .yaml-value input[type="number"], .yaml-value textarea').forEach((el) => {
        el.style.setProperty("background-color", primaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
        el.style.setProperty("color", textNormal, "important");
      });
    }
    if (hoverBg) {
      document.querySelectorAll(".yaml-property").forEach((row) => {
        row.addEventListener("mouseenter", () => {
          row.style.setProperty("background-color", hoverBg, "important");
        });
        row.addEventListener("mouseleave", () => {
          row.style.setProperty("background-color", "transparent", "important");
        });
      });
    }
    if (primaryBg && borderColor && textNormal) {
      document.querySelectorAll(".yaml-add-property button").forEach((el) => {
        el.style.setProperty("background-color", primaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
        el.style.setProperty("color", textNormal, "important");
      });
    }
    if (textNormal && borderColor) {
      document.querySelectorAll(".plugin-view-badge").forEach((el) => {
        el.style.setProperty("border-bottom", `1px solid ${borderColor}`, "important");
      });
      document.querySelectorAll(".plugin-label").forEach((el) => {
        el.style.setProperty("color", textNormal, "important");
      });
    }
    if (primaryBg && borderColor) {
      document.querySelectorAll(".yaml-tag-dropdown").forEach((el) => {
        el.style.setProperty("background-color", primaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
      });
    }
    if (textNormal && hoverBg) {
      document.querySelectorAll(".yaml-tag-suggestion").forEach((item) => {
        item.style.setProperty("color", textNormal, "important");
        item.addEventListener("mouseenter", () => {
          item.style.setProperty("background-color", hoverBg, "important");
        });
        item.addEventListener("mouseleave", () => {
          item.style.setProperty("background-color", "transparent", "important");
        });
      });
    }
    if (primaryBg && borderColor) {
      document.querySelectorAll(".yaml-property-dropdown").forEach((el) => {
        el.style.setProperty("background-color", primaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
      });
    }
    if (primaryBg && borderColor && textNormal) {
      document.querySelectorAll(".yaml-property-search").forEach((el) => {
        el.style.setProperty("background-color", primaryBg, "important");
        el.style.setProperty("border-bottom", `1px solid ${borderColor}`, "important");
        el.style.setProperty("color", textNormal, "important");
      });
    }
    if (textNormal && hoverBg) {
      document.querySelectorAll(".yaml-property-suggestion").forEach((item) => {
        item.style.setProperty("color", textNormal, "important");
        item.addEventListener("mouseenter", () => {
          item.style.setProperty("background-color", hoverBg, "important");
        });
        item.addEventListener("mouseleave", () => {
          item.style.setProperty("background-color", "transparent", "important");
        });
      });
    }
    if (primaryBg && borderColor) {
      document.querySelectorAll(".yaml-type-selector").forEach((el) => {
        el.style.setProperty("background-color", primaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
      });
    }
    if (primaryBg && borderColor) {
      document.querySelectorAll(".yaml-link-dropdown").forEach((el) => {
        el.style.setProperty("background-color", primaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
      });
    }
    if (textNormal && hoverBg) {
      document.querySelectorAll(".yaml-link-suggestion").forEach((item) => {
        item.style.setProperty("color", textNormal, "important");
        item.addEventListener("mouseenter", () => {
          item.style.setProperty("background-color", hoverBg, "important");
        });
        item.addEventListener("mouseleave", () => {
          item.style.setProperty("background-color", "transparent", "important");
        });
      });
    }
    if (primaryBg && borderColor) {
      document.querySelectorAll(".yaml-link-value").forEach((el) => {
        el.style.setProperty("background-color", primaryBg, "important");
        el.style.setProperty("border", `1px solid ${borderColor}`, "important");
      });
    }
    if (textAccent) {
      document.querySelectorAll(".yaml-internal-link").forEach((el) => {
        el.style.setProperty("color", textAccent, "important");
        el.style.setProperty("background-color", hoverBg || "rgba(76, 79, 105, 0.075)", "important");
      });
    }
    if (textMuted && textNormal && hoverBg) {
      document.querySelectorAll(".yaml-edit-link").forEach((btn) => {
        btn.style.setProperty("color", textMuted, "important");
        btn.addEventListener("mouseenter", () => {
          btn.style.setProperty("color", textNormal, "important");
          btn.style.setProperty("background-color", hoverBg, "important");
        });
        btn.addEventListener("mouseleave", () => {
          btn.style.setProperty("color", textMuted, "important");
          btn.style.setProperty("background-color", "transparent", "important");
        });
      });
    }
    if (textNormal && borderColor) {
      document.querySelectorAll(".yaml-type-selector-header").forEach((el) => {
        el.style.setProperty("background-color", secondaryBg, "important");
        el.style.setProperty("color", textNormal, "important");
        el.style.setProperty("border-bottom", `1px solid ${borderColor}`, "important");
      });
    }
    if (textNormal && hoverBg) {
      document.querySelectorAll(".yaml-type-option").forEach((item) => {
        item.style.setProperty("color", textNormal, "important");
        item.addEventListener("mouseenter", () => {
          item.style.setProperty("background-color", hoverBg, "important");
        });
        item.addEventListener("mouseleave", () => {
          item.style.setProperty("background-color", "transparent", "important");
        });
      });
    }
    const tagBg = getComputedStyle(root2).getPropertyValue("--tag-background").trim() || secondaryAltBg;
    const tagColor = getComputedStyle(root2).getPropertyValue("--tag-color").trim() || textAccent;
    if (tagBg || tagColor) {
      document.querySelectorAll(".yaml-tag-chip").forEach((el) => {
        if (tagBg) el.style.setProperty("background-color", tagBg, "important");
        if (tagColor) el.style.setProperty("color", tagColor, "important");
      });
    }
    if (tagBg || tagColor) {
      document.querySelectorAll('#custom-preview a[href^="#"]').forEach((el) => {
        if (tagBg) el.style.setProperty("background-color", tagBg, "important");
        if (tagColor) el.style.setProperty("color", tagColor, "important");
        el.style.setProperty("padding", "2px 8px", "important");
        el.style.setProperty("border-radius", "12px", "important");
        el.style.setProperty("display", "inline-flex", "important");
      });
    }
    const graphCanvas = document.querySelector("#graph-canvas canvas");
    if (graphCanvas && primaryBg) {
      graphCanvas.style.setProperty("background", primaryBg, "important");
      if (graphInstance) {
        graphInstance.backgroundColor(primaryBg);
      }
    }
    console.log("âœ… Comprehensive theme applied");
  }
  function renderPreview(html, preserveScroll = false) {
    const preview = document.getElementById("custom-preview");
    const loading = document.getElementById("preview-loading");
    const savedScrollTop = window._savedScrollPosition || 0;
    if (preserveScroll) {
      console.log(`ðŸ“ Using saved scroll position: ${savedScrollTop}`);
    }
    if (html) {
      preview.innerHTML = html;
      if (window.Prism) {
        preview.querySelectorAll("pre code").forEach((block) => {
          window.Prism.highlightElement(block);
        });
      }
      preview.querySelectorAll('mjx-c[class*="mjx-c"]').forEach((el) => {
        const match = el.className.match(/mjx-c([0-9A-F]+)/i);
        if (match && !el.textContent) {
          const codePoint = parseInt(match[1], 16);
          el.textContent = String.fromCodePoint(codePoint);
        }
      });
      addCopyButtons(preview);
      addDataviewTaskWarnings(preview);
      addCalloutIcons(preview);
    }
    if (loading) {
      loading.style.display = "none";
    }
    if (preview) {
      preview.style.display = "block";
      if (preserveScroll && savedScrollTop > 0) {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            preview.scrollTop = savedScrollTop;
            console.log(`âœ… Restored scroll position to: ${savedScrollTop}, actual: ${preview.scrollTop}`);
            delete window._savedScrollPosition;
            delete window._isCheckboxUpdate;
          });
        });
      } else {
        preview.scrollTop = 0;
        console.log(`ðŸ“ Reset scroll to top (not a checkbox update)`);
        delete window._isCheckboxUpdate;
      }
    }
    console.log("âœ… Preview rendered and visible");
  }
  function addCopyButtons(container) {
    container.querySelectorAll("pre").forEach((pre) => {
      var _a;
      if ((_a = pre.parentNode.classList) == null ? void 0 : _a.contains("code-block-wrapper")) return;
      const wrapper = document.createElement("div");
      wrapper.className = "code-block-wrapper";
      wrapper.style.cssText = "position: relative; margin: 1em 0;";
      pre.parentNode.insertBefore(wrapper, pre);
      wrapper.appendChild(pre);
      const copyBtn = document.createElement("button");
      copyBtn.className = "code-copy-btn";
      copyBtn.innerHTML = copy;
      copyBtn.style.cssText = "position: absolute !important; top: 8px !important; right: 8px !important; padding: 6px 10px !important; border-radius: 4px !important; cursor: pointer !important; z-index: 999 !important; display: block !important;";
      copyBtn.onclick = () => {
        var _a2;
        const code = ((_a2 = pre.querySelector("code")) == null ? void 0 : _a2.textContent) || pre.textContent;
        navigator.clipboard.writeText(code).then(() => {
          copyBtn.innerHTML = check;
          copyBtn.classList.add("copied");
          setTimeout(() => {
            copyBtn.innerHTML = copy;
            copyBtn.classList.remove("copied");
          }, 2e3);
        });
      };
      wrapper.appendChild(copyBtn);
    });
  }
  function addDataviewTaskWarnings(container) {
    container.querySelectorAll(".block-language-dataview").forEach((dataviewContainer) => {
      const hasTaskCheckboxes = dataviewContainer.querySelector('input[type="checkbox"].task-list-item-checkbox');
      if (hasTaskCheckboxes && !dataviewContainer.querySelector(".dataview-task-warning")) {
        const banner = document.createElement("div");
        banner.className = "dataview-task-warning";
        banner.innerHTML = `
                <svg viewBox="0 0 24 24" width="16" height="16" style="display: inline-block; vertical-align: middle; margin-right: 6px;">
                    <path fill="currentColor" d="M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" />
                </svg>
                <span>Tasks in this dataview are read-only. Complete tasks in the source files to update them here.</span>
            `;
        dataviewContainer.insertBefore(banner, dataviewContainer.firstChild);
      }
    });
  }
  function addCalloutIcons(container) {
    const calloutIcons = {
      info: '<circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M12 16v-4M12 8h.01"/>',
      tip: '<path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"/><path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M12 2v1m0 18v1M4.22 4.22l.707.707m12.728 12.728.707.707M2 12h1m18 0h1M4.22 19.78l.707-.707M18.36 5.64l.707-.707M9 16v5h6v-5m-1-9V3h-2v4"/>',
      warning: '<path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M12 9v4m0 4h.01"/>',
      danger: '<path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0Z"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M12 9v4m0 4h.01"/>',
      error: '<circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="m15 9-6 6m0-6 6 6"/>',
      note: '<path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M14 2v6h6"/>',
      success: '<path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M20 6 9 17l-5-5"/>',
      check: '<path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M20 6 9 17l-5-5"/>',
      quote: '<path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1z"/><path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"/>',
      example: '<rect width="18" height="18" x="3" y="3" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M9 9h6M9 15h6"/>',
      question: '<circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M12 17h.01"/>',
      abstract: '<rect width="18" height="18" x="3" y="3" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M9 9h6M9 15h6"/>',
      todo: '<circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M12 8v4l2 2"/>',
      bug: '<path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="m8 2 1.88 1.88M14.12 3.88 16 2M9 7.13v-1a3.003 3.003 0 1 1 6 0v1"/><path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6Z"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M12 20v-9M6.53 9C4.6 8.8 3 7.1 3 5m3.53 8H3m15.53-4C19.4 8.8 21 7.1 21 5m-2.47 4H21m-2.47 4H21"/>',
      failure: '<circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><path stroke="currentColor" stroke-width="2" stroke-linecap="round" d="m15 9-6 6m0-6 6 6"/>'
    };
    container.querySelectorAll(".callout").forEach((callout) => {
      const type2 = callout.getAttribute("data-callout") || "note";
      const iconSvg = callout.querySelector(".callout-icon svg");
      if (iconSvg && !iconSvg.hasChildNodes()) {
        const iconPath = calloutIcons[type2] || calloutIcons["note"];
        iconSvg.setAttribute("viewBox", "0 0 24 24");
        iconSvg.innerHTML = iconPath;
        iconSvg.style.display = "block";
      }
    });
  }
  function renderYamlProperties(yamlData, path) {
    const container = document.getElementById("yaml-properties-container");
    if (!container) return;
    const hasYaml = yamlData && Object.keys(yamlData).length > 0;
    const PLUGIN_VIEWS = {
      "kanban-plugin": { icon: "ðŸ“‹", label: "Kanban Board", author: "mgmeyers" },
      "dataview": { icon: "ðŸ“Š", label: "Dataview Query", author: "blacksmithgu" },
      "excalidraw-plugin": { icon: "âœï¸", label: "Excalidraw Drawing", author: "zsolt" }
    };
    let detectedPlugin = null;
    if (hasYaml) {
      Object.keys(yamlData).forEach((key) => {
        if (PLUGIN_VIEWS[key]) {
          detectedPlugin = { key, ...PLUGIN_VIEWS[key] };
        }
      });
    }
    const isCollapsed = localStorage.getItem("yamlCollapsed") === "true";
    const propertiesHtml = hasYaml ? Object.entries(yamlData).map(
      ([key, value]) => renderYamlProperty(key, value)
    ).join("") : '<div style="padding: 8px; color: var(--text-muted); font-size: 12px; text-align: center;">No properties yet</div>';
    const pluginBadgeHtml = detectedPlugin ? `
        <div class="plugin-view-badge">
            <span class="plugin-icon">${detectedPlugin.icon}</span>
            <span class="plugin-label">${detectedPlugin.label}</span>
            <button class="plugin-toggle-btn" onclick="console.log('ðŸ–±ï¸ Badge clicked!'); if (typeof window.togglePluginView === 'function') { window.togglePluginView(); } else { console.error('âŒ window.togglePluginView is not a function:', typeof window.togglePluginView); }">
                <i class="fa-solid fa-eye"></i> Toggle View
            </button>
            <span class="plugin-attribution">by ${detectedPlugin.author}</span>
        </div>
    ` : "";
    container.innerHTML = `
        <div class="yaml-header" onclick="window.toggleYamlCollapse()">
            <span>
                <i class="fa-solid fa-chevron-${isCollapsed ? "right" : "down"}"></i>
                Properties
            </span>
        </div>
        ${pluginBadgeHtml}
        <div class="yaml-content ${isCollapsed ? "collapsed" : ""}">
            ${propertiesHtml}
            <div class="yaml-add-property">
                <button onclick="window.addYamlProperty(event)">
                    <i class="fa-solid fa-plus"></i> Add property
                </button>
            </div>
        </div>
    `;
    container.style.display = "block";
    setTimeout(() => applyThemeToElements(), 10);
  }
  function renderYamlProperty(key, value, path) {
    if (Array.isArray(value)) {
      const chips = value.map((item) => `
            <span class="yaml-tag-chip">
                ${item}
                <i class="fa-solid fa-xmark" onclick="window.removeYamlArrayItem('${key}', '${item}')"></i>
            </span>
        `).join("");
      return `
            <div class="yaml-property" data-key="${key}">
                <div class="yaml-key">${key}</div>
                <div class="yaml-value yaml-tags">
                    ${chips}
                    <input type="text" 
                           class="yaml-tag-input" 
                           placeholder="Add ${key}..."
                           onfocus="window.showTagDropdown(this, '${key}')"
                           oninput="window.filterTagDropdown(this, '${key}')"
                           onblur="window.hideTagDropdown()"
                           onkeydown="window.handleYamlArrayInput(event, '${key}')">
                </div>
                <i class="fa-solid fa-trash yaml-delete-property" 
                   onclick="window.deleteYamlProperty('${key}')"
                   title="Delete property"></i>
            </div>
        `;
    }
    if (typeof value === "boolean") {
      return `
            <div class="yaml-property" data-key="${key}">
                <div class="yaml-key">${key}</div>
                <div class="yaml-value">
                    <input type="checkbox" 
                           ${value ? "checked" : ""}
                           onchange="window.updateYamlProperty('${key}', this.checked)">
                </div>
                <i class="fa-solid fa-trash yaml-delete-property" 
                   onclick="window.deleteYamlProperty('${key}')"
                   title="Delete property"></i>
            </div>
        `;
    }
    const valueString = String(value || "");
    const isDateFormat = /^\d{4}-\d{2}-\d{2}$/.test(valueString);
    const isDateProperty = ["date", "created", "modified", "due"].includes(key);
    if (isDateFormat || isDateProperty) {
      return `
            <div class="yaml-property" data-key="${key}">
                <div class="yaml-key">${key}</div>
                <div class="yaml-value">
                    <input type="date" 
                           value="${value}" 
                           onchange="window.updateYamlProperty('${key}', this.value)">
                </div>
                <i class="fa-solid fa-trash yaml-delete-property" 
                   onclick="window.deleteYamlProperty('${key}')"
                   title="Delete property"></i>
            </div>
        `;
    }
    if (typeof value === "number" || !isNaN(value) && value !== "" && !isNaN(parseFloat(value))) {
      return `
            <div class="yaml-property" data-key="${key}">
                <div class="yaml-key">${key}</div>
                <div class="yaml-value">
                    <input type="number" 
                           value="${value}" 
                           step="any"
                           onchange="window.updateYamlProperty('${key}', parseFloat(this.value) || 0)"
                           onkeydown="if(event.key==='Enter') this.blur()">
                </div>
                <i class="fa-solid fa-trash yaml-delete-property" 
                   onclick="window.deleteYamlProperty('${key}')"
                   title="Delete property"></i>
            </div>
        `;
    }
    const stringValue = String(value || "");
    const hasWikilink = stringValue.includes("[[") && stringValue.includes("]]");
    if (hasWikilink) {
      let html = stringValue;
      const linkRegex = /\[\[([^\]]+)\]\]/g;
      html = html.replace(linkRegex, (match, linkText) => {
        return `<a href="${linkText}.md" class="internal-link yaml-internal-link"><i class="fa-solid fa-link"></i> ${linkText}</a>`;
      });
      return `
            <div class="yaml-property" data-key="${key}">
                <div class="yaml-key">${key}</div>
                <div class="yaml-value yaml-link-value">
                    <span class="yaml-link-content">${html}</span>
                    <button class="yaml-edit-link" onclick="window.editYamlLink('${key}', this)" title="Edit link">
                        <i class="fa-solid fa-pencil"></i>
                    </button>
                </div>
                <i class="fa-solid fa-trash yaml-delete-property" 
                   onclick="window.deleteYamlProperty('${key}')"
                   title="Delete property"></i>
            </div>
        `;
    }
    if (stringValue.includes("\n") || stringValue.length > 100) {
      const escapedValue2 = stringValue.replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `
            <div class="yaml-property" data-key="${key}">
                <div class="yaml-key">${key}</div>
                <div class="yaml-value">
                    <textarea rows="3"
                              onblur="window.updateYamlProperty('${key}', this.value)"
                              onkeydown="if(event.key==='Enter' && event.ctrlKey) this.blur()">${escapedValue2}</textarea>
                </div>
                <i class="fa-solid fa-trash yaml-delete-property" 
                   onclick="window.deleteYamlProperty('${key}')"
                   title="Delete property"></i>
            </div>
        `;
    }
    const escapedValue = stringValue.replace(/"/g, "&quot;");
    return `
        <div class="yaml-property" data-key="${key}">
            <div class="yaml-key">${key}</div>
            <div class="yaml-value">
                <input type="text" 
                       value="${escapedValue}" 
                       onfocus="window.checkForLinkAutocomplete(this, '${key}')"
                       oninput="window.filterLinkAutocomplete(this, '${key}')"
                       onblur="window.hideLinkAutocomplete(); window.updateYamlProperty('${key}', this.value)"
                       onkeydown="if(event.key==='Enter') this.blur()">
            </div>
            <i class="fa-solid fa-trash yaml-delete-property" 
               onclick="window.deleteYamlProperty('${key}')"
               title="Delete property"></i>
        </div>
    `;
  }
  window.toggleYamlCollapse = function() {
    const content = document.querySelector(".yaml-content");
    const icon = document.querySelector(".yaml-header i:first-child");
    if (content && icon) {
      const isCollapsed = content.classList.toggle("collapsed");
      icon.className = `fa-solid fa-chevron-${isCollapsed ? "right" : "down"}`;
      localStorage.setItem("yamlCollapsed", isCollapsed);
    }
  };
  function renderPluginData(data) {
    console.log("ðŸŽ¨ ========== WEB UI RECEIVED DATA ==========");
    console.log("ðŸ“ renderedHTML length:", data.renderedHTML ? data.renderedHTML.length : 0);
    console.log("ðŸŽ¨ pluginCSS exists:", !!data.pluginCSS);
    const preview = document.getElementById("custom-preview");
    if (preview && data.renderedHTML) {
      let pluginName = "Obsidian Plugin";
      if (data.viewType === "kanban") {
        pluginName = "Kanban Plugin by mgmeyers";
      }
      preview.innerHTML = `
            <div style="padding: 0px;">
                <div style="background: var(--background-secondary); padding: 8px 12px; border-radius: 6px; margin-bottom: 8px;">
                    <strong>${pluginName}</strong>
                    <span style="float: right; color: var(--text-muted);">Read-only view</span>
                </div>
                ${data.renderedHTML}
            </div>
        `;
      if (data.pluginCSS) {
        console.log("ðŸ’‰ Injecting plugin CSS into DOM...");
        let pluginStyleTag = document.getElementById("plugin-styles");
        if (!pluginStyleTag) {
          pluginStyleTag = document.createElement("style");
          pluginStyleTag.id = "plugin-styles";
          document.head.appendChild(pluginStyleTag);
        }
        const kanbanFallbackCSS = `
/* Kanban Horizontal Board Fallback Styles */
.kanban-plugin__item-wrapper {
    padding: 4px !important;
}

.kanban-plugin__item {
    background-color: var(--background-primary, #ffffff) !important;
    border: 1px solid var(--background-modifier-border, #e0e0e0) !important;
    border-radius: var(--radius-m, 5px) !important;
    padding: 8px !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
    margin-bottom: 4px !important;
}

.kanban-plugin__item:hover {
    border-color: var(--background-modifier-border-hover, #d0d0d0) !important;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) !important;
}

.kanban-plugin__lane {
    background-color: var(--background-secondary, #f5f5f5) !important;
    border-radius: var(--radius-m, 5px) !important;
    padding: 8px !important;
}

.kanban-plugin__lane-header-wrapper {
    padding: 8px !important;
    border-bottom: 1px solid var(--background-modifier-border, #e0e0e0) !important;
    margin-bottom: 8px !important;
}

.kanban-plugin__lane-items {
    padding: 8px !important;
    gap: 8px !important;
}

/* Hide interactive elements (read-only view) */
.kanban-plugin__lane-grip,
.kanban-plugin__lane-action-wrapper,
.kanban-plugin__item-prefix-button,
.kanban-plugin__item-postfix-button,
.kanban-plugin__item-metadata-wrapper .clickable-icon,
.kanban-plugin__grow-wrap button,
.kanban-plugin__item-button-wrapper,
.kanban-plugin__lane-setting-wrapper,
.kanban-plugin__item-grip,
.kanban-plugin__lane-collapse,
.kanban-plugin__lane-settings,
.kanban-plugin__lane-settings-button-wrapper,
.kanban-plugin__lane-settings-button {
    display: none !important;
}

/* Disable drag and drop interactions */
.kanban-plugin__item,
.kanban-plugin__lane {
    cursor: default !important;
}
`;
        pluginStyleTag.textContent = data.pluginCSS + "\n" + kanbanFallbackCSS;
      }
      setTimeout(() => applyThemeToElements(), 100);
    }
  }
  window.togglePluginView = async function() {
    console.log("ðŸŽ¯ togglePluginView called!", { currentPath, hasConn: !!conn });
    if (!currentPath || !conn) {
      console.error("âŒ togglePluginView failed: missing currentPath or conn", { currentPath, conn });
      return;
    }
    try {
      const response = await conn.send("OPEN_FILE", { path: currentPath });
      const data = response.data || response;
      if (data.renderedHTML && data.renderedHTML.length > 0) {
        renderPluginData(data);
        const editorContainer = document.querySelector(".EasyMDEContainer");
        if (editorContainer && editorContainer.style.display !== "none") {
          isReadingMode = true;
          const btn = document.getElementById("view-btn");
          const preview = document.getElementById("custom-preview");
          const loading = document.getElementById("preview-loading");
          const saveBtn = document.getElementById("save-btn");
          if (btn) {
            btn.innerHTML = '<i class="fa-solid fa-pen-to-square"></i>';
            btn.title = "Switch to Edit Mode";
          }
          if (saveBtn) saveBtn.style.display = "none";
          editorContainer.style.display = "none";
          if (loading) loading.style.display = "none";
          if (preview) preview.style.display = "block";
        }
        return;
      }
      if (data.html && data.html.length > 0) {
        const preview = document.getElementById("custom-preview");
        if (preview) {
          let pluginType = "Unknown";
          if (data.yaml) {
            if (data.yaml["kanban-plugin"]) pluginType = "Kanban Board (Markdown Structure)";
            else if (data.yaml["dataview"]) pluginType = "Dataview";
            else if (data.yaml["excalidraw-plugin"]) pluginType = "Excalidraw";
          }
          preview.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="background: var(--background-secondary); padding: 10px; border-radius: 6px; margin-bottom: 16px;">
                            <strong>${pluginType}</strong>
                            <span style="float: right; color: var(--text-muted);">Read-only structure</span>
                        </div>
                        ${data.html}
                    </div>
                `;
          const editorContainer = document.querySelector(".EasyMDEContainer");
          if (editorContainer && editorContainer.style.display !== "none") {
            await toggleViewMode();
          }
          setTimeout(() => applyThemeToElements(), 100);
        }
        return;
      }
      const message = document.createElement("div");
      message.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--background-secondary);
            color: var(--text-normal);
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10000;
            border: 1px solid var(--background-modifier-border);
        `;
      message.innerHTML = '<i class="fa-solid fa-exclamation-triangle"></i> Could not render view';
      document.body.appendChild(message);
      setTimeout(() => message.remove(), 3e3);
    } catch (error) {
      console.error("Failed to get plugin view:", error);
      alert("Could not capture plugin view from Obsidian: " + error.message);
    }
  };
  window.updateYamlProperty = async function(key, value) {
    if (!currentYamlData || !currentPath) return;
    currentYamlData[key] = value;
    await saveYamlToFile();
  };
  window.handleYamlArrayInput = function(event, key) {
    if (event.key === "Enter" && event.target.value.trim()) {
      event.preventDefault();
      const value = event.target.value.trim();
      addYamlArrayItem(key, value);
      event.target.value = "";
      window.hideTagDropdown();
    } else if (event.key === "ArrowDown") {
      event.preventDefault();
      const dropdown = document.querySelector(".yaml-tag-dropdown");
      if (dropdown) {
        const firstItem = dropdown.querySelector(".yaml-tag-suggestion");
        if (firstItem) firstItem.focus();
      }
    } else if (event.key === "Escape") {
      window.hideTagDropdown();
    }
  };
  window.showTagDropdown = function(input, key) {
    const allTags = [];
    if (tagTree && typeof tagTree === "object") {
      if (tagTree._sub && typeof tagTree._sub === "object") {
        Object.keys(tagTree._sub).forEach((tag2) => {
          const cleanTag = tag2.replace(/^#/, "");
          if (cleanTag) allTags.push(cleanTag);
        });
      } else if (tagTree._children && typeof tagTree._children === "object") {
        Object.keys(tagTree._children).forEach((tag2) => {
          const cleanTag = tag2.replace(/^#/, "");
          if (cleanTag) allTags.push(cleanTag);
        });
      } else {
        Object.keys(tagTree).forEach((tag2) => {
          if (!tag2.startsWith("_")) {
            const cleanTag = tag2.replace(/^#/, "");
            if (cleanTag) allTags.push(cleanTag);
          }
        });
      }
    }
    if (allTags.length === 0) return;
    const usedTags = currentYamlData && currentYamlData[key] ? currentYamlData[key] : [];
    const availableTags = allTags.filter((tag2) => !usedTags.includes(tag2));
    if (availableTags.length === 0) return;
    displayTagDropdown(input, availableTags, key);
  };
  window.filterTagDropdown = function(input, key) {
    const searchTerm = input.value.toLowerCase();
    const allTags = [];
    if (tagTree && typeof tagTree === "object") {
      if (tagTree._sub && typeof tagTree._sub === "object") {
        Object.keys(tagTree._sub).forEach((tag2) => {
          const cleanTag = tag2.replace(/^#/, "");
          if (cleanTag) allTags.push(cleanTag);
        });
      } else if (tagTree._children && typeof tagTree._children === "object") {
        Object.keys(tagTree._children).forEach((tag2) => {
          const cleanTag = tag2.replace(/^#/, "");
          if (cleanTag) allTags.push(cleanTag);
        });
      } else {
        Object.keys(tagTree).forEach((tag2) => {
          if (!tag2.startsWith("_")) {
            const cleanTag = tag2.replace(/^#/, "");
            if (cleanTag) allTags.push(cleanTag);
          }
        });
      }
    }
    if (allTags.length === 0) return;
    const usedTags = currentYamlData && currentYamlData[key] ? currentYamlData[key] : [];
    const filteredTags = allTags.filter(
      (tag2) => !usedTags.includes(tag2) && tag2.toLowerCase().includes(searchTerm)
    );
    if (filteredTags.length === 0) {
      window.hideTagDropdown();
      return;
    }
    displayTagDropdown(input, filteredTags, key);
  };
  function displayTagDropdown(input, tags, key) {
    const existing = document.querySelector(".yaml-tag-dropdown");
    if (existing) existing.remove();
    const rect = input.getBoundingClientRect();
    const dropdown = document.createElement("div");
    dropdown.className = "yaml-tag-dropdown";
    dropdown.style.position = "fixed";
    dropdown.style.top = rect.bottom + 2 + "px";
    dropdown.style.left = rect.left + "px";
    dropdown.style.minWidth = rect.width + "px";
    const displayTags = tags.slice(0, 8);
    dropdown.innerHTML = displayTags.map((tag2) => `
        <div class="yaml-tag-suggestion" 
             tabindex="0"
             onmousedown="window.selectTag('${tag2}', '${key}')"
             onkeydown="if(event.key==='Enter') window.selectTag('${tag2}', '${key}')">
            <i class="fa-solid fa-tag"></i> ${tag2}
        </div>
    `).join("");
    document.body.appendChild(dropdown);
    setTimeout(() => applyThemeToElements(), 10);
  }
  window.selectTag = async function(tag2, key) {
    await addYamlArrayItem(key, tag2);
    const input = document.querySelector(".yaml-tag-input");
    if (input) {
      input.value = "";
      setTimeout(() => {
        input.focus();
        window.showTagDropdown(input, key);
      }, 100);
    }
  };
  window.hideTagDropdown = function() {
    setTimeout(() => {
      const dropdown = document.querySelector(".yaml-tag-dropdown");
      if (dropdown) dropdown.remove();
    }, 200);
  };
  async function addYamlArrayItem(key, item) {
    if (!currentYamlData) currentYamlData = {};
    if (!currentYamlData[key]) currentYamlData[key] = [];
    const itemTrimmed = item.trim();
    if (currentYamlData[key].includes(itemTrimmed)) {
      console.log(`Tag "${itemTrimmed}" already exists, skipping`);
      return;
    }
    currentYamlData[key].push(itemTrimmed);
    await saveYamlToFile();
    renderYamlProperties(currentYamlData);
  }
  window.removeYamlArrayItem = async function(key, item) {
    if (!currentYamlData || !currentYamlData[key]) return;
    currentYamlData[key] = currentYamlData[key].filter((v2) => v2 !== item);
    if (currentYamlData[key].length === 0) {
      delete currentYamlData[key];
    }
    await saveYamlToFile();
    renderYamlProperties(currentYamlData);
  };
  window.addYamlProperty = function(event) {
    const button = event.target.closest("button");
    if (!button) return;
    const commonProperties = [
      "tags",
      "aliases",
      "cssclass",
      "cssclasses",
      "date",
      "created",
      "modified",
      "due",
      "author",
      "title",
      "description",
      "summary",
      "category",
      "type",
      "status",
      "priority",
      "publish",
      "draft",
      "featured",
      "image",
      "banner",
      "cover",
      "link",
      "url",
      "source"
    ];
    const existingProps = currentYamlData ? Object.keys(currentYamlData) : [];
    const availableProps = commonProperties.filter((prop) => !existingProps.includes(prop));
    if (availableProps.length === 0 && existingProps.length > 0) {
      availableProps.push("+ Custom property...");
    }
    showPropertyDropdown(button, availableProps);
  };
  function showPropertyDropdown(button, properties) {
    const existing = document.querySelector(".yaml-property-dropdown");
    if (existing) existing.remove();
    const rect = button.getBoundingClientRect();
    const dropdown = document.createElement("div");
    dropdown.className = "yaml-property-dropdown";
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.left = `${rect.left}px`;
    const searchInput = document.createElement("input");
    searchInput.type = "text";
    searchInput.className = "yaml-property-search";
    searchInput.placeholder = "Type to filter or add custom...";
    dropdown.appendChild(searchInput);
    const suggestionsDiv = document.createElement("div");
    suggestionsDiv.className = "yaml-property-suggestions";
    dropdown.appendChild(suggestionsDiv);
    displayPropertySuggestions(suggestionsDiv, properties);
    searchInput.addEventListener("input", (e2) => {
      const value = e2.target.value.toLowerCase();
      if (value) {
        const filtered = properties.filter(
          (prop) => prop.toLowerCase().includes(value) && prop !== "+ Custom property..."
        );
        if (!filtered.includes(value)) {
          filtered.push(`+ Add "${e2.target.value}"`);
        }
        displayPropertySuggestions(suggestionsDiv, filtered, e2.target.value);
      } else {
        displayPropertySuggestions(suggestionsDiv, properties);
      }
    });
    searchInput.addEventListener("keydown", (e2) => {
      if (e2.key === "Escape") {
        dropdown.remove();
      } else if (e2.key === "Enter") {
        const firstSuggestion = suggestionsDiv.querySelector(".yaml-property-suggestion");
        if (firstSuggestion) {
          firstSuggestion.click();
        }
      } else if (e2.key === "ArrowDown") {
        e2.preventDefault();
        const firstSuggestion = suggestionsDiv.querySelector(".yaml-property-suggestion");
        if (firstSuggestion) firstSuggestion.focus();
      }
    });
    setTimeout(() => {
      document.addEventListener("click", function closeDropdown(e2) {
        if (!dropdown.contains(e2.target) && e2.target !== button) {
          dropdown.remove();
          document.removeEventListener("click", closeDropdown);
        }
      });
    }, 100);
    document.body.appendChild(dropdown);
    searchInput.focus();
    setTimeout(() => applyThemeToElements(), 10);
  }
  function displayPropertySuggestions(container, properties, customValue = null) {
    container.innerHTML = properties.map((prop) => {
      if (prop.startsWith('+ Add "')) {
        const propName = customValue;
        return `
                <div class="yaml-property-suggestion" 
                     tabindex="0"
                     onmousedown="window.selectProperty('${propName}')"
                     onkeydown="if(event.key==='Enter') window.selectProperty('${propName}')">
                    <i class="fa-solid fa-plus"></i> Add "${propName}"
                </div>
            `;
      } else if (prop === "+ Custom property...") {
        return `
                <div class="yaml-property-suggestion yaml-custom" 
                     tabindex="0">
                    <i class="fa-solid fa-keyboard"></i> <em>Type to add custom property</em>
                </div>
            `;
      } else {
        const icon = getPropertyIcon(prop);
        return `
                <div class="yaml-property-suggestion" 
                     tabindex="0"
                     onmousedown="window.selectProperty('${prop}')"
                     onkeydown="if(event.key==='Enter') window.selectProperty('${prop}')">
                    <i class="fa-solid fa-${icon}"></i> ${prop}
                </div>
            `;
      }
    }).join("");
  }
  function getPropertyIcon(prop) {
    if (prop === "tags") return "tag";
    if (prop === "aliases") return "clone";
    if (["date", "created", "modified", "due"].includes(prop)) return "calendar";
    if (["author", "title", "description", "summary"].includes(prop)) return "file-lines";
    if (["category", "type", "status"].includes(prop)) return "folder";
    if (["image", "banner", "cover"].includes(prop)) return "image";
    if (["link", "url", "source"].includes(prop)) return "link";
    if (["publish", "draft", "featured"].includes(prop)) return "eye";
    if (prop === "priority") return "star";
    if (["cssclass", "cssclasses"].includes(prop)) return "paintbrush";
    return "circle";
  }
  window.selectProperty = async function(propName) {
    const dropdown = document.querySelector(".yaml-property-dropdown");
    if (dropdown) dropdown.remove();
    const sanitizedKey = propName.trim().replace(/[^a-zA-Z0-9_-]/g, "");
    if (!sanitizedKey) {
      alert("Invalid property name. Use only letters, numbers, hyphens, and underscores.");
      return;
    }
    if (!currentYamlData) currentYamlData = {};
    if (currentYamlData[sanitizedKey] !== void 0) {
      alert("Property already exists.");
      return;
    }
    if (sanitizedKey === "tags" || sanitizedKey === "aliases" || sanitizedKey === "cssclasses") {
      currentYamlData[sanitizedKey] = [];
      await saveYamlToFile();
      renderYamlProperties(currentYamlData);
    } else if (["date", "created", "modified", "due"].includes(sanitizedKey)) {
      currentYamlData[sanitizedKey] = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      await saveYamlToFile();
      renderYamlProperties(currentYamlData);
    } else if (["publish", "draft", "featured"].includes(sanitizedKey)) {
      currentYamlData[sanitizedKey] = false;
      await saveYamlToFile();
      renderYamlProperties(currentYamlData);
    } else {
      showPropertyTypeSelector(sanitizedKey);
    }
  };
  function showPropertyTypeSelector(propName) {
    const container = document.getElementById("yaml-properties-container");
    if (!container) return;
    const rect = container.getBoundingClientRect();
    const dropdown = document.createElement("div");
    dropdown.className = "yaml-type-selector";
    dropdown.style.top = `${rect.top + 100}px`;
    dropdown.style.left = `${rect.left + rect.width / 2 - 150}px`;
    dropdown.innerHTML = `
        <div class="yaml-type-header">
            Choose type for "${propName}"
        </div>
        <div class="yaml-type-option" onclick="window.createPropertyWithType('${propName}', 'text')">
            <i class="fa-solid fa-font"></i>
            <div>
                <strong>Text</strong>
                <span>Single line text</span>
            </div>
        </div>
        <div class="yaml-type-option" onclick="window.createPropertyWithType('${propName}', 'number')">
            <i class="fa-solid fa-hashtag"></i>
            <div>
                <strong>Number</strong>
                <span>Numeric value</span>
            </div>
        </div>
        <div class="yaml-type-option" onclick="window.createPropertyWithType('${propName}', 'checkbox')">
            <i class="fa-solid fa-check-square"></i>
            <div>
                <strong>Checkbox</strong>
                <span>True/false toggle</span>
            </div>
        </div>
        <div class="yaml-type-option" onclick="window.createPropertyWithType('${propName}', 'date')">
            <i class="fa-solid fa-calendar"></i>
            <div>
                <strong>Date</strong>
                <span>Date picker</span>
            </div>
        </div>
        <div class="yaml-type-option" onclick="window.createPropertyWithType('${propName}', 'list')">
            <i class="fa-solid fa-list"></i>
            <div>
                <strong>List</strong>
                <span>Array of items</span>
            </div>
        </div>
        <div class="yaml-type-option" onclick="window.createPropertyWithType('${propName}', 'multiline')">
            <i class="fa-solid fa-align-left"></i>
            <div>
                <strong>Multiline Text</strong>
                <span>Long text area</span>
            </div>
        </div>
        <div class="yaml-type-option" onclick="window.createPropertyWithType('${propName}', 'link')">
            <i class="fa-solid fa-link"></i>
            <div>
                <strong>Link</strong>
                <span>Internal wiki-link</span>
            </div>
        </div>
    `;
    setTimeout(() => {
      document.addEventListener("click", function closeSelector(e2) {
        if (!dropdown.contains(e2.target)) {
          dropdown.remove();
          document.removeEventListener("click", closeSelector);
        }
      });
    }, 100);
    document.body.appendChild(dropdown);
    setTimeout(() => applyThemeToElements(), 10);
  }
  window.createPropertyWithType = async function(propName, type2) {
    const selector2 = document.querySelector(".yaml-type-selector");
    if (selector2) selector2.remove();
    if (!currentYamlData) currentYamlData = {};
    switch (type2) {
      case "text":
        currentYamlData[propName] = "";
        break;
      case "number":
        currentYamlData[propName] = 0;
        break;
      case "checkbox":
        currentYamlData[propName] = false;
        break;
      case "date":
        currentYamlData[propName] = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        break;
      case "list":
        currentYamlData[propName] = [];
        break;
      case "multiline":
        currentYamlData[propName] = "";
        break;
      case "link":
        currentYamlData[propName] = "";
        break;
      default:
        currentYamlData[propName] = "";
    }
    await saveYamlToFile();
    renderYamlProperties(currentYamlData);
    setTimeout(() => {
      const newProp = document.querySelector(`.yaml-property[data-key="${propName}"] input, .yaml-property[data-key="${propName}"] textarea`);
      if (newProp) newProp.focus();
    }, 100);
  };
  window.deleteYamlProperty = async function(key) {
    if (!currentYamlData || !key) return;
    if (!confirm(`Delete property "${key}"?`)) return;
    delete currentYamlData[key];
    await saveYamlToFile();
    renderYamlProperties(currentYamlData);
  };
  window.editYamlLink = function(key, button) {
    const property = button.closest(".yaml-property");
    const valueDiv = property.querySelector(".yaml-value");
    const currentValue = currentYamlData[key] || "";
    valueDiv.innerHTML = `
        <input type="text" 
               class="yaml-link-edit"
               value="${currentValue.replace(/"/g, "&quot;")}" 
               onfocus="window.checkForLinkAutocomplete(this, '${key}')"
               oninput="window.filterLinkAutocomplete(this, '${key}')"
               onblur="window.hideLinkAutocomplete(); window.saveLinkEdit('${key}', this.value)"
               onkeydown="if(event.key==='Enter') this.blur()">
    `;
    const input = valueDiv.querySelector("input");
    input.focus();
    input.setSelectionRange(input.value.length, input.value.length);
  };
  window.saveLinkEdit = async function(key, value) {
    await window.updateYamlProperty(key, value);
    renderYamlProperties(currentYamlData);
  };
  window.checkForLinkAutocomplete = function(input, key) {
    const value = input.value;
    if (value.includes("[[") && !value.endsWith("]]")) {
      window.showLinkAutocomplete(input, key);
    }
  };
  window.showLinkAutocomplete = function(input, key) {
    const existing = document.querySelector(".yaml-link-dropdown");
    if (existing) existing.remove();
    const allFiles = masterFileList.map((file) => {
      const path = file.path || file;
      return path.replace(".md", "").split("/").pop();
    }).filter(Boolean).sort();
    if (allFiles.length === 0) return;
    const rect = input.getBoundingClientRect();
    const dropdown = document.createElement("div");
    dropdown.className = "yaml-link-dropdown";
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.left = `${rect.left}px`;
    dropdown.style.minWidth = `${rect.width}px`;
    const value = input.value;
    const linkStart = value.lastIndexOf("[[");
    const searchTerm = linkStart >= 0 ? value.substring(linkStart + 2).toLowerCase() : "";
    const filtered = searchTerm ? allFiles.filter((file) => file.toLowerCase().includes(searchTerm)) : allFiles.slice(0, 50);
    displayLinkSuggestions(dropdown, filtered, input, key);
    document.body.appendChild(dropdown);
    setTimeout(() => applyThemeToElements(), 10);
  };
  window.filterLinkAutocomplete = function(input, key) {
    const value = input.value;
    if (value.includes("[[")) {
      const dropdown = document.querySelector(".yaml-link-dropdown");
      if (!dropdown) {
        window.showLinkAutocomplete(input, key);
      } else {
        const allFiles = masterFileList.map((file) => {
          const path = file.path || file;
          return path.replace(".md", "").split("/").pop();
        }).filter(Boolean).sort();
        const linkStart = value.lastIndexOf("[[");
        const searchTerm = linkStart >= 0 ? value.substring(linkStart + 2).toLowerCase() : "";
        const filtered = searchTerm ? allFiles.filter((file) => file.toLowerCase().includes(searchTerm)) : allFiles.slice(0, 50);
        displayLinkSuggestions(dropdown, filtered, input, key);
      }
    } else {
      window.hideLinkAutocomplete();
    }
  };
  function displayLinkSuggestions(container, files, input, key) {
    container.innerHTML = files.map((file) => `
        <div class="yaml-link-suggestion" 
             tabindex="0"
             onmousedown="window.selectLink('${file}', '${key}')"
             onkeydown="if(event.key==='Enter') window.selectLink('${file}', '${key}')">
            <i class="fa-solid fa-file"></i> ${file}
        </div>
    `).join("");
    if (files.length === 0) {
      container.innerHTML = '<div class="yaml-link-suggestion yaml-custom"><em>No matches found</em></div>';
    }
  }
  window.selectLink = function(fileName, key) {
    const input = document.querySelector('.yaml-property[data-key="' + key + '"] input');
    if (!input) return;
    const value = input.value;
    const linkStart = value.lastIndexOf("[[");
    if (linkStart >= 0) {
      const before = value.substring(0, linkStart);
      input.value = before + "[[" + fileName + "]]";
    } else {
      input.value = "[[" + fileName + "]]";
    }
    window.hideLinkAutocomplete();
    input.focus();
  };
  window.hideLinkAutocomplete = function() {
    setTimeout(() => {
      const dropdown = document.querySelector(".yaml-link-dropdown");
      if (dropdown) dropdown.remove();
    }, 200);
  };
  async function saveYamlToFile() {
    if (!currentPath) {
      console.error("âŒ No currentPath set");
      return;
    }
    try {
      console.log("ðŸ’¾ Starting YAML save for:", currentPath);
      console.log("Current YAML data:", JSON.stringify(currentYamlData, null, 2));
      console.log("Current mode:", isReadingMode ? "PREVIEW" : "EDIT");
      window._yamlSaveInProgress = true;
      console.log("ðŸš© Set _yamlSaveInProgress flag");
      console.log("ðŸ“¡ Requesting GET_FILE...");
      await conn.send("GET_FILE", { path: currentPath });
      console.log("â³ Waiting 200ms for file content...");
      await new Promise((resolve) => setTimeout(resolve, 200));
      const rawContent = easyMDE ? easyMDE.value() : "";
      console.log("ðŸ“ Raw content length:", rawContent.length);
      console.log("First 200 chars:", rawContent.substring(0, 200));
      if (!rawContent) {
        throw new Error("Could not fetch file content");
      }
      let bodyContent = rawContent;
      const yamlMatch = rawContent.match(/^---\n[\s\S]*?\n---\n?/);
      if (yamlMatch) {
        console.log("âœ‚ï¸ Found YAML frontmatter, extracting body");
        console.log("YAML block:", yamlMatch[0].substring(0, 100));
        bodyContent = rawContent.slice(yamlMatch[0].length);
      } else {
        console.log("â„¹ï¸ No existing YAML frontmatter found");
      }
      console.log("Body content length:", bodyContent.length);
      let newContent = bodyContent;
      if (currentYamlData && Object.keys(currentYamlData).length > 0) {
        console.log("ðŸ”¨ Reconstructing file with new YAML...");
        const yamlString = jsYaml.dump(currentYamlData, {
          indent: 2,
          lineWidth: -1,
          noRefs: true,
          sortKeys: false
        });
        console.log("Generated YAML:", yamlString);
        newContent = `---
${yamlString}---
${bodyContent}`;
      }
      console.log("New content length:", newContent.length);
      console.log("First 200 chars of new content:", newContent.substring(0, 200));
      contentWithoutYaml = bodyContent;
      console.log("ðŸ’¾ Sending SAVE_FILE command...");
      await conn.send("SAVE_FILE", { path: currentPath, data: newContent });
      console.log("âœ… YAML saved, refreshing preview...");
      if (isReadingMode) {
        console.log("ðŸ“º Preview mode: refreshing rendered view");
        await new Promise((resolve) => setTimeout(resolve, 100));
        console.log("ðŸ“¡ Requesting GET_RENDERED_FILE...");
        await conn.send("GET_RENDERED_FILE", { path: currentPath });
      } else {
        console.log("âœï¸ Edit mode: updating editor with new content");
        if (easyMDE) {
          const cursorPos = easyMDE.codemirror.getCursor();
          easyMDE.value(newContent);
          easyMDE.codemirror.setCursor(cursorPos);
        }
      }
      console.log("ðŸŽ‰ YAML save complete!");
    } catch (err) {
      console.error("âŒ Failed to save YAML:", err);
      console.error("Error stack:", err.stack);
      alert("Failed to save properties: " + err.message);
    } finally {
      console.log("ðŸ Clearing _yamlSaveInProgress flag");
      window._yamlSaveInProgress = false;
    }
  }
  function renderSidebar() {
    const container = document.getElementById("file-tree");
    const previouslyOpen = /* @__PURE__ */ new Set();
    container.querySelectorAll(".tree-children.open").forEach((el) => {
      const label = el.previousElementSibling;
      const path = label == null ? void 0 : label.getAttribute("data-path");
      if (path) previouslyOpen.add(path);
    });
    container.innerHTML = "";
    const tree = currentView === "folders" ? folderTree : tagTree;
    const iconSet = { folder, tag };
    const onNodeClick = (fullPath, files) => {
      if (currentView === "folders") {
        selectedFolderPath = fullPath;
      }
      prepareNoteList(files);
    };
    renderNode(tree, container, 0, "", currentView, iconSet, onNodeClick);
    let targetPath = null;
    if (currentView === "folders") {
      if (selectedFolderPath) {
        targetPath = selectedFolderPath;
      } else if (currentPath && currentPath.includes("/")) {
        targetPath = currentPath.substring(0, currentPath.lastIndexOf("/") + 1);
      }
    }
    const ancestorPaths = [];
    if (targetPath) {
      const parts = targetPath.split("/").filter(Boolean);
      let acc = "";
      parts.forEach((part) => {
        acc += part + "/";
        ancestorPaths.push(acc);
      });
    }
    const pathsToOpen = /* @__PURE__ */ new Set([...previouslyOpen, ...ancestorPaths]);
    pathsToOpen.forEach((path) => {
      const label = container.querySelector(`.tree-label[data-path="${CSS.escape(path)}"]`);
      const children2 = label ? label.nextElementSibling : null;
      const caret = label ? label.querySelector(".caret") : null;
      if (children2 && caret) {
        children2.classList.add("open");
        caret.innerHTML = "â–¼";
      }
    });
    if (targetPath) {
      const targetLabel = container.querySelector(`.tree-label[data-path="${CSS.escape(targetPath)}"]`);
      if (targetLabel) {
        document.querySelectorAll(".tree-label").forEach((d2) => d2.classList.remove("selected"));
        targetLabel.classList.add("selected");
      }
    }
    setTimeout(() => applyThemeToElements(), 10);
  }
  function prepareNoteList(files) {
    currentList = prepareList(files);
    renderedCount = 0;
    const container = document.getElementById("note-list");
    if (container) {
      container.innerHTML = "";
    }
    renderBatch();
  }
  function renderBatch() {
    const container = document.getElementById("note-list");
    const batchSize = 50;
    const end = Math.min(renderedCount + batchSize, currentList.length);
    for (let i2 = renderedCount; i2 < end; i2++) {
      const file = currentList[i2];
      const card = document.createElement("div");
      card.className = "note-card file-tree-item";
      card.dataset.path = file.path;
      card.dataset.type = "file";
      const title = document.createElement("div");
      title.className = "note-title";
      title.textContent = file.path.split("/").pop().replace(".md", "");
      card.appendChild(title);
      card.addEventListener("click", () => loadFile(file.path));
      container.appendChild(card);
    }
    renderedCount = end;
  }
  window.navigateBack = function() {
    if (navigationHistory.length === 0) return;
    const previousPath = navigationHistory.pop();
    const tempHistory = [...navigationHistory];
    navigationHistory = [];
    loadFile(previousPath);
    navigationHistory = tempHistory;
  };
  async function loadFile(path) {
    if (currentPath && currentPath !== path) {
      navigationHistory.push(currentPath);
      if (navigationHistory.length > 50) {
        navigationHistory.shift();
      }
    }
    currentPath = path;
    const filenameEl = document.getElementById("filename");
    const filename = path.split("/").pop().replace(".md", "");
    if (navigationHistory.length > 0) {
      filenameEl.innerHTML = `
            <button id="back-btn" onclick="window.navigateBack()" title="Go back">
                <i class="fa-solid fa-arrow-left"></i>
            </button>
            <span>${filename}</span>
        `;
    } else {
      filenameEl.innerHTML = `<span>${filename}</span>`;
    }
    isReadingMode = true;
    const btn = document.getElementById("view-btn");
    const preview = document.getElementById("custom-preview");
    const loading = document.getElementById("preview-loading");
    const editorEl = document.querySelector(".EasyMDEContainer");
    const saveBtn = document.getElementById("save-btn");
    if (btn) {
      btn.style.display = "block";
      btn.innerHTML = '<i class="fa-solid fa-pen-to-square"></i>';
      btn.title = "Switch to Edit Mode";
    }
    if (saveBtn) {
      saveBtn.style.display = "none";
      saveBtn.classList.add("hidden");
    }
    if (editorEl) editorEl.style.display = "none";
    if (loading) loading.style.display = "flex";
    if (preview) preview.style.display = "none";
    await conn.send("GET_RENDERED_FILE", { path });
  }
  function renderBacklinks(links) {
    const container = document.getElementById("backlinks-list");
    if (!container) return;
    container.innerHTML = "";
    if (!links || links.length === 0) {
      container.innerHTML = '<div style="padding: 10px; color: var(--text-muted); font-style: italic;">No backlinks</div>';
      return;
    }
    const sortedLinks = [...links].sort((a2, b) => {
      const nameA = a2.split("/").pop().replace(".md", "").toLowerCase();
      const nameB = b.split("/").pop().replace(".md", "").toLowerCase();
      return nameA.localeCompare(nameB);
    });
    sortedLinks.forEach((link) => {
      const item = document.createElement("a");
      item.className = "backlink-item";
      item.textContent = link.split("/").pop().replace(".md", "");
      item.onclick = () => loadFile(link);
      container.appendChild(item);
    });
  }
  function renderLocalGraph(centerPath) {
    const container = document.getElementById("graph-canvas");
    if (!container || container.clientHeight === 0) return;
    console.log("ðŸ•¸ï¸ Rendering graph for:", centerPath);
    const style = getComputedStyle(document.body);
    const bg = style.getPropertyValue("--background-primary").trim() || "#ffffff";
    const text = style.getPropertyValue("--text-normal").trim() || "#333333";
    const textMuted = style.getPropertyValue("--text-muted").trim() || "#888888";
    const accent = style.getPropertyValue("--interactive-accent").trim() || "#7c4dff";
    const tagColor = style.getPropertyValue("--text-accent").trim() || "#e91e63";
    const centerNode = masterFileList.find((f2) => f2.path === centerPath);
    if (!centerNode) {
      container.innerHTML = '<div style="color:' + textMuted + '; text-align:center; padding-top:40px; font-style:italic;">No connections.</div>';
      return;
    }
    const nodes = /* @__PURE__ */ new Set();
    const links = [];
    nodes.add(centerPath);
    if (centerNode.links) {
      centerNode.links.forEach((target) => {
        const tFile = masterFileList.find((f2) => f2.path.endsWith(target) || f2.path.endsWith(target + ".md"));
        if (tFile) {
          nodes.add(tFile.path);
          links.push({ source: centerPath, target: tFile.path });
        }
      });
    }
    if (centerNode.tags) {
      centerNode.tags.forEach((tag2) => {
        nodes.add(tag2);
        links.push({ source: centerPath, target: tag2 });
      });
    }
    masterFileList.forEach((f2) => {
      if (f2.links && f2.links.some((l2) => centerPath.endsWith(l2) || centerPath.endsWith(l2 + ".md"))) {
        nodes.add(f2.path);
        links.push({ source: f2.path, target: centerPath });
      }
    });
    const graphNodes = Array.from(nodes).map((id2) => ({
      id: id2,
      name: id2.startsWith("#") ? id2 : id2.split("/").pop().replace(".md", ""),
      val: id2 === centerPath ? 20 : 5,
      color: id2 === centerPath ? accent : id2.startsWith("#") ? tagColor : textMuted,
      isCenter: id2 === centerPath
    }));
    console.log("ðŸ“Š Graph data:", graphNodes.length, "nodes,", links.length, "links");
    if (graphInstance && container.childElementCount > 0) {
      graphInstance.graphData({ nodes: graphNodes, links });
      graphInstance.width(container.clientWidth).height(container.clientHeight);
      graphInstance.backgroundColor(bg);
    } else {
      container.innerHTML = "";
      graphInstance = forceGraph()(container).width(container.clientWidth).height(container.clientHeight).graphData({ nodes: graphNodes, links }).backgroundColor(bg).nodeColor("color").nodeLabel("name").nodeVal("val").linkColor(() => textMuted).linkWidth(1.5).d3AlphaDecay(0.02).d3VelocityDecay(0.3).zoom(3.5).nodeCanvasObject((node, ctx, globalScale) => {
        const label = node.name;
        const fontSize = 10 / globalScale;
        ctx.font = `${fontSize}px Sans-Serif`;
        ctx.fillStyle = node.color;
        ctx.beginPath();
        ctx.arc(node.x, node.y, 4, 0, 2 * Math.PI, false);
        ctx.fill();
        const labelWidth = ctx.measureText(label).width;
        const labelPadding = 4;
        const labelOffset = 8;
        const labelX = node.x + labelOffset;
        const labelY = node.y;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        const bgX = labelX - labelPadding;
        ctx.fillStyle = bg + "dd";
        ctx.fillRect(
          bgX,
          labelY - fontSize / 2 - labelPadding / 2,
          labelWidth + labelPadding * 2,
          fontSize + labelPadding
        );
        ctx.fillStyle = node.isCenter ? accent : text;
        ctx.fillText(label, labelX, labelY);
      }).onNodeClick((node) => {
        if (node.id.startsWith("#")) {
          filterByTag(node.id);
        } else {
          loadFile(node.id);
        }
      });
    }
  }
  function initSidebarResize() {
    const handle = document.getElementById("sidebar-resize");
    const sidebar = document.getElementById("sidebar");
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    const savedWidth = localStorage.getItem("sidebarWidth");
    if (savedWidth) {
      sidebar.style.width = savedWidth + "px";
    }
    handle.addEventListener("mousedown", (e2) => {
      isResizing = true;
      startX = e2.clientX;
      startWidth = sidebar.offsetWidth;
      handle.classList.add("resizing");
      document.body.style.cursor = "col-resize";
      e2.preventDefault();
    });
    document.addEventListener("mousemove", (e2) => {
      if (!isResizing) return;
      const delta = e2.clientX - startX;
      const newWidth = Math.max(200, Math.min(500, startWidth + delta));
      sidebar.style.width = newWidth + "px";
    });
    document.addEventListener("mouseup", () => {
      if (isResizing) {
        isResizing = false;
        handle.classList.remove("resizing");
        document.body.style.cursor = "";
        localStorage.setItem("sidebarWidth", sidebar.offsetWidth);
      }
    });
  }
  function applyPanelState() {
    const graphCont = document.getElementById("local-graph-container");
    const blCont = document.getElementById("backlinks-container");
    const mainPanel = document.getElementById("context-panel");
    const graphCanvas = document.getElementById("graph-canvas");
    const blList = document.getElementById("backlinks-list");
    if (graphCanvas) graphCanvas.style.display = panelState.graph ? "block" : "none";
    if (blList) blList.style.display = panelState.backlinks ? "block" : "none";
    const iconGraph = document.getElementById("icon-graph");
    const iconBacklinks = document.getElementById("icon-backlinks");
    if (iconGraph) iconGraph.className = panelState.graph ? "fa-solid fa-chevron-down" : "fa-solid fa-chevron-up";
    if (iconBacklinks) iconBacklinks.className = panelState.backlinks ? "fa-solid fa-chevron-down" : "fa-solid fa-chevron-up";
    if (graphCont) graphCont.style.flex = panelState.graph ? "1" : "0 0 auto";
    if (blCont) blCont.style.flex = panelState.backlinks ? "1" : "0 0 auto";
    if (mainPanel) {
      if (!panelState.graph && !panelState.backlinks) {
        mainPanel.style.height = "35px";
      } else {
        mainPanel.style.height = "300px";
        if (panelState.graph && graphInstance) {
          setTimeout(() => renderLocalGraph(currentPath), 300);
        }
      }
    }
  }
  function updateIcons() {
    var _a;
    const isLight = document.body.classList.contains("light-mode");
    const isFocus = (_a = document.getElementById("app-container")) == null ? void 0 : _a.classList.contains("focus-mode");
    const themeBtn = document.getElementById("theme-btn");
    const focusBtn = document.getElementById("focus-btn");
    if (themeBtn) {
      themeBtn.innerHTML = isLight ? '<i class="fa-solid fa-moon"></i>' : '<i class="fa-solid fa-sun"></i>';
    }
    if (focusBtn) {
      focusBtn.innerHTML = isFocus ? '<i class="fa-solid fa-minimize"></i>' : '<i class="fa-solid fa-maximize"></i>';
      focusBtn.classList.toggle("active", isFocus);
    }
  }
  async function toggleViewMode() {
    isReadingMode = !isReadingMode;
    const btn = document.getElementById("view-btn");
    const preview = document.getElementById("custom-preview");
    const loading = document.getElementById("preview-loading");
    const editorEl = document.querySelector(".EasyMDEContainer");
    const saveBtn = document.getElementById("save-btn");
    console.log("ðŸ”„ Toggle view mode:", isReadingMode ? "READ" : "EDIT");
    if (isReadingMode) {
      btn.innerHTML = '<i class="fa-solid fa-pen-to-square"></i>';
      btn.title = "Switch to Edit Mode";
      if (saveBtn) {
        saveBtn.classList.add("hidden");
        saveBtn.style.display = "none";
      }
      editorEl.style.display = "none";
      loading.style.display = "flex";
      preview.style.display = "none";
      const response = await conn.send("OPEN_FILE", { path: currentPath });
      if (response && response.data) {
        const data = response.data;
        if (data.renderedHTML) {
          renderPluginData(data);
          if (loading) loading.style.display = "none";
          if (preview) preview.style.display = "block";
        } else if (data.html) {
          if (data.css) applyTheme(data.css);
          currentYamlData = data.yaml;
          renderYamlProperties(data.yaml);
          renderPreview(data.html);
          renderBacklinks(data.backlinks || []);
          if (panelState.graph) renderLocalGraph(currentPath);
        }
      }
    } else {
      btn.innerHTML = '<i class="fa-regular fa-eye"></i>';
      btn.title = "Switch to Preview Mode";
      if (saveBtn) {
        saveBtn.classList.remove("hidden");
        saveBtn.style.display = "block";
      }
      preview.style.display = "none";
      loading.style.display = "none";
      editorEl.style.display = "flex";
      await conn.send("GET_FILE", { path: currentPath });
      if (easyMDE) easyMDE.codemirror.refresh();
    }
  }
  function toggleFocus() {
    document.getElementById("app-container").classList.toggle("focus-mode");
    updateIcons();
    if (graphInstance && panelState.graph) {
      setTimeout(() => renderLocalGraph(currentPath), 300);
    }
  }
  function togglePanel(panel) {
    panelState[panel] = !panelState[panel];
    localStorage.setItem("panelState", JSON.stringify(panelState));
    applyPanelState();
  }
  async function saveFile() {
    if (!currentPath) return;
    const content = getEditorContent();
    await conn.send("SAVE_FILE", { path: currentPath, data: content });
    log("File saved!");
  }
  function switchTab(tab) {
    currentView = tab;
    document.querySelectorAll(".tab").forEach((t2) => t2.classList.remove("active"));
    document.getElementById(`tab-${tab}`).classList.add("active");
    renderSidebar();
  }
  async function refreshTree() {
    await conn.send("GET_TREE");
    setTimeout(() => {
      switchTab("folders");
      selectedFolderPath = "";
      const rootFiles = masterFileList.filter((f2) => !f2.path.includes("/"));
      prepareNoteList(rootFiles.length > 0 ? rootFiles : masterFileList);
    }, 200);
  }
  function doSearch(e2) {
    const val = e2.target.value.toLowerCase();
    const header = document.querySelector("#pane-notes .pane-header");
    if (!val) {
      prepareNoteList(masterFileList.filter((f2) => !f2.path.includes("/")));
      if (header) header.innerText = "NOTES";
    } else {
      const results = masterFileList.filter(
        (f2) => f2.path.toLowerCase().includes(val) || f2.tags && f2.tags.some((t2) => t2.toLowerCase().includes(val))
      );
      prepareNoteList(results);
      if (header) header.innerText = `RESULTS: ${results.length}`;
    }
  }
  async function createNote() {
    let parentDir = "";
    if (selectedFolderPath) {
      parentDir = selectedFolderPath;
    } else if (currentPath && currentPath.includes("/")) {
      parentDir = currentPath.substring(0, currentPath.lastIndexOf("/")) + "/";
    }
    const name = prompt(`New Note in ${parentDir || "Root"}:`, "Untitled");
    if (name) {
      const cleanName = name.replace(/\.md$/, "");
      const fullPath = parentDir + cleanName + ".md";
      await conn.send("CREATE_FILE", { path: fullPath });
      await conn.send("GET_TREE");
      await loadFile(fullPath);
      if (isReadingMode) await toggleViewMode();
    }
  }
  async function createFolder() {
    let parentDir = "";
    if (selectedFolderPath) {
      parentDir = selectedFolderPath;
    } else if (currentPath && currentPath.includes("/")) {
      parentDir = currentPath.substring(0, currentPath.lastIndexOf("/")) + "/";
    }
    const name = prompt(`New Folder in ${parentDir || "Root"}:`, "New Folder");
    if (name) {
      const fullPath = parentDir + name;
      await conn.send("CREATE_FOLDER", { path: fullPath });
      await conn.send("GET_TREE");
    }
  }
  function collapseAll() {
    document.querySelectorAll(".tree-children.open").forEach((el) => {
      el.classList.remove("open");
    });
    document.querySelectorAll(".caret").forEach((caret) => {
      caret.innerHTML = "â–¶";
    });
  }
  function sortFiles() {
    alert("Sort functionality coming in V2 update.");
  }
  async function openDailyNote() {
    if (!conn) {
      alert("Not connected to vault.");
      return;
    }
    try {
      console.log("ðŸ“… Sending OPEN_DAILY_NOTE command...");
      const response = await conn.send("OPEN_DAILY_NOTE", {});
      console.log("ðŸ“… Response received:", response);
      const data = response.data || response;
      if (data.success && data.path) {
        console.log("ðŸ“… Loading file:", data.path);
        const preview = document.getElementById("custom-preview");
        if (preview) preview.innerHTML = "";
        await loadFile(data.path);
        console.log("ðŸ“… File loaded successfully");
      } else if (data.message) {
        alert(data.message);
      } else {
        console.error("ðŸ“… Unexpected response format:", response);
      }
    } catch (error) {
      console.error("Failed to open daily note:", error);
      alert("Failed to open daily note. Make sure the Daily Notes plugin is enabled in Obsidian.");
    }
  }
  function openGraph() {
    if (!panelState.graph) togglePanel("graph");
    alert("Full Graph View coming in V2. Local Graph is available in the right panel.");
  }
  function openSettings() {
    alert("Settings coming in V2.");
  }
  async function ctxOpen() {
    hideContextMenu();
    if (ctxTarget && ctxTarget.length > 0 && ctxTargetType === "file") {
      await loadFile(ctxTarget);
    }
  }
  async function ctxNewNote() {
    hideContextMenu();
    let parentDir = "";
    if (ctxTarget) {
      if (ctxTarget.endsWith("/")) {
        parentDir = ctxTarget;
      } else if (ctxTarget.endsWith(".md")) {
        parentDir = ctxTarget.substring(0, ctxTarget.lastIndexOf("/")) + "/";
      }
    }
    if (parentDir === "/") parentDir = "";
    const name = prompt(`New Note in ${parentDir || "Root"}:`, "Untitled");
    if (name) {
      const cleanName = name.replace(/\.md$/, "");
      const fullPath = parentDir + cleanName + ".md";
      await conn.send("CREATE_FILE", { path: fullPath });
      await conn.send("GET_TREE");
      await loadFile(fullPath);
    }
  }
  async function ctxNewFolder() {
    hideContextMenu();
    let parentDir = "";
    if (ctxTarget) {
      if (ctxTarget.endsWith("/")) {
        parentDir = ctxTarget;
      } else if (ctxTarget.endsWith(".md")) {
        parentDir = ctxTarget.substring(0, ctxTarget.lastIndexOf("/")) + "/";
      }
    }
    if (parentDir === "/") parentDir = "";
    const name = prompt(`New Folder in ${parentDir || "Root"}:`, "New Folder");
    if (name) {
      const fullPath = parentDir + name;
      await conn.send("CREATE_FOLDER", { path: fullPath });
      await conn.send("GET_TREE");
    }
  }
  async function ctxRename() {
    hideContextMenu();
    if (!ctxTarget || ctxTarget.length === 0) {
      console.error("ctxRename: No target path");
      return;
    }
    const isFolder = ctxTargetType === "folder";
    const isFile = ctxTargetType === "file";
    const cleanTarget = ctxTarget.endsWith("/") ? ctxTarget.slice(0, -1) : ctxTarget;
    let defaultName = cleanTarget;
    if (isFile && cleanTarget.endsWith(".md")) {
      defaultName = cleanTarget.slice(0, -3);
    } else if (isFolder) {
      defaultName = cleanTarget.split("/").pop();
    }
    const promptText = isFolder ? "Rename Folder:" : "Rename / Move (Enter new path):";
    const newPathInput = prompt(promptText, defaultName);
    if (newPathInput && newPathInput !== defaultName) {
      let newPath = newPathInput;
      if (isFile && cleanTarget.endsWith(".md") && !newPath.endsWith(".md")) {
        newPath += ".md";
      }
      if (isFolder) {
        const parentPath = cleanTarget.substring(0, cleanTarget.lastIndexOf("/"));
        if (parentPath) {
          newPath = parentPath + "/" + newPath;
        }
      }
      await conn.send("RENAME_FILE", { path: cleanTarget, data: { newPath } });
      await conn.send("GET_TREE");
      if (isFile && cleanTarget.endsWith(".md")) {
        await loadFile(newPath);
      }
    }
  }
  async function ctxDelete() {
    hideContextMenu();
    if (!ctxTarget || ctxTarget.length === 0) {
      console.error("ctxDelete: No target path");
      return;
    }
    const isFolder = ctxTargetType === "folder";
    const cleanTarget = ctxTarget.endsWith("/") ? ctxTarget.slice(0, -1) : ctxTarget;
    const itemType = isFolder ? "folder" : "file";
    const displayName = isFolder ? cleanTarget.split("/").pop() : cleanTarget.split("/").pop();
    if (confirm(`Are you sure you want to delete this ${itemType}: "${displayName}"?`)) {
      await conn.send("DELETE_FILE", { path: cleanTarget });
      await conn.send("GET_TREE");
    }
  }
  function hideContextMenu() {
    const menu = document.getElementById("context-menu");
    if (menu) menu.style.display = "none";
  }
  function renderContextMenu(container, items) {
    items.forEach((item) => {
      if (item.show === false) return;
      if (item.type === "separator") {
        const sep = document.createElement("div");
        sep.className = "menu-separator";
        container.appendChild(sep);
        return;
      }
      const div = document.createElement("div");
      div.className = `menu-item ${item.danger ? "delete" : ""}`;
      div.innerHTML = `<i class="fa-solid ${item.icon}"></i> ${item.label}`;
      div.onclick = (e2) => {
        e2.stopPropagation();
        window[item.action]();
        container.style.display = "none";
      };
      container.appendChild(div);
    });
  }
  function handleContextMenuDisplay(e2) {
    if (e2.target.closest("#context-menu") || e2.target.closest(".context-menu")) {
      return;
    }
    e2.preventDefault();
    e2.stopPropagation();
    const menu = document.getElementById("context-menu");
    if (!menu) return;
    const target = e2.target.closest(".file-tree-item");
    menu.innerHTML = "";
    menu.style.display = "block";
    let x2 = e2.clientX;
    let y2 = e2.clientY;
    if (x2 + 200 > window.innerWidth) x2 = window.innerWidth - 210;
    if (y2 + 300 > window.innerHeight) y2 = window.innerHeight - 310;
    menu.style.left = `${x2}px`;
    menu.style.top = `${y2}px`;
    if (target) {
      const path = target.getAttribute("data-path");
      const type2 = target.getAttribute("data-type");
      if (!path || path.length === 0) {
        console.error("Context menu target missing data-path:", target);
        return;
      }
      if (type2 === "tag" || path.startsWith("#")) {
        menu.style.display = "none";
        return;
      }
      ctxTarget = path;
      ctxTargetType = type2;
      renderContextMenu(menu, [
        { label: "Open", icon: "fa-folder-open", action: "ctxOpen", show: type2 === "file" },
        { label: "New Note", icon: "fa-plus", action: "ctxNewNote" },
        { label: "New Folder", icon: "fa-folder", action: "ctxNewFolder" },
        { type: "separator" },
        { label: "Rename", icon: "fa-pen-to-square", action: "ctxRename" },
        { label: "Delete", icon: "fa-trash", action: "ctxDelete", danger: true }
      ]);
    } else {
      ctxTarget = selectedFolderPath || "";
      renderContextMenu(menu, [
        { label: "New Note Here", icon: "fa-plus", action: "ctxNewNote" },
        { label: "New Folder Here", icon: "fa-folder", action: "ctxNewFolder" }
      ]);
    }
  }
  function log(msg) {
    const statusEl = document.getElementById("status-text");
    if (statusEl) statusEl.innerText = msg;
  }
  window.initApp = initApp;
  window.loadFile = loadFile;
  window.saveFile = saveFile;
  window.toggleViewMode = toggleViewMode;
  window.toggleFocus = toggleFocus;
  window.togglePanel = togglePanel;
  window.switchTab = switchTab;
  window.refreshTree = refreshTree;
  window.doSearch = doSearch;
  window.createNote = createNote;
  window.createFolder = createFolder;
  window.collapseAll = collapseAll;
  window.sortFiles = sortFiles;
  window.openDailyNote = openDailyNote;
  window.openGraph = openGraph;
  window.openSettings = openSettings;
  window.ctxOpen = ctxOpen;
  window.ctxNewNote = ctxNewNote;
  window.ctxNewFolder = ctxNewFolder;
  window.ctxRename = ctxRename;
  window.ctxDelete = ctxDelete;
  console.log("ðŸ” Window functions registered:", {
    togglePluginView: typeof window.togglePluginView,
    toggleYamlCollapse: typeof window.toggleYamlCollapse,
    updateYamlProperty: typeof window.updateYamlProperty,
    addYamlProperty: typeof window.addYamlProperty
  });
  function getIdentity() {
    return window.NOTE_RELAY_IDENTITY || {
      email: null,
      vaultId: null,
      licenseType: "free",
      token: null
    };
  }
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
  function init() {
    console.log("ðŸš€ Note Relay UI Initializing...");
    const identity2 = getIdentity();
    if (identity2 && identity2.email) {
      console.log("ðŸ“§ Identity:", identity2.email);
      console.log("ðŸ”‘ License:", identity2.licenseType);
    }
    initApp();
  }
})();
